/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/Dialog/dialog.ts
var import_obsidian = require("obsidian");
var ExampleModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h6", { text: "\u60A8\u7684\u60F3\u6CD5\u662F\uFF1F" });
    const stylingTemplateSetting = new import_obsidian.Setting(contentEl);
    const stylingTemplateContent = new import_obsidian.TextAreaComponent(stylingTemplateSetting.controlEl);
    stylingTemplateSetting.settingEl.setAttribute("style", "display: grid; grid-template-columns: 1fr;");
    stylingTemplateContent.inputEl.setAttribute("style", "width: 100%;  height: 18vh;");
    stylingTemplateContent.onChange((value) => __async(this, null, function* () {
      this.result = value.replace(/\n/g, "<br>");
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("\u786E\u5B9A").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/Plugin/EditorExtension.ts
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var label = "View notes";
var addSrcButton = (app, plugin) => {
  const apply = () => app.workspace.iterateAllLeaves(addButton(app, plugin));
  app.workspace.onLayoutReady(apply);
  app.workspace.on("layout-change", apply);
};
var addButton = (app, plugin) => (leaf) => {
  if (leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.containerEl.querySelector(
    `a.view-action[aria-label="${label}"]`
  ) === null) {
    let view = leaf.view;
    let isWork = false;
    const buttonElement = view.addAction("pdf-file", label, (evt) => {
      const rightGutters = view.contentEl.querySelector("#right-gutters");
      if (isWork) {
        isWork = false;
        rightGutters.setAttribute("style", "display:block");
        rightGutters.setAttribute("style", `background-color:${plugin.settings.backgroundColor}!important;width:${plugin.settings.width}px;margin-right: 30px`);
        (0, import_obsidian2.setIcon)(buttonElement, "pdf-file");
      } else {
        isWork = true;
        rightGutters.setAttribute("style", "display:none");
        (0, import_obsidian2.setIcon)(buttonElement, "add-note-glyph");
      }
    });
  }
};
function EditingViewPlugin(app, plugin) {
  return import_view.ViewPlugin.fromClass(
    class ExamplePlugin {
      constructor(view) {
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("style", `background-color:${plugin.settings.backgroundColor}!important;width:${plugin.settings.width}px;margin-right: 30px`);
        this.dom.setAttribute("id", "right-gutters");
        this.dom.style.minHeight = view.contentHeight + "px";
        view.scrollDOM.insertAfter(this.dom, view.contentDOM.nextSibling);
        addSrcButton(app, plugin);
      }
      setCommnet(view) {
        const _get_gutter = view.dom.querySelector("#right-gutters");
        if (_get_gutter) {
          _get_gutter.empty();
          const findComment = view.contentDOM.querySelectorAll(".comment");
          if (findComment.length === 0) {
            const findStyle = view.contentDOM.querySelectorAll(".cm-line");
            findStyle.forEach(($el) => {
              let getStyles = $el.getAttribute("style");
              if (getStyles) {
                if (getStyles.endsWith("top:0px")) {
                  $el.removeAttribute("style");
                }
                ;
              }
            });
          }
          findComment.forEach((element) => {
            if (element) {
              const comments = document.createElement("div");
              comments.style.top = element.parentElement.parentElement.parentElement.offsetTop + "px";
              comments.addClass("rightComments");
              comments.innerHTML = element.innerHTML;
              _get_gutter.append(comments);
              comments.onclick = (e) => {
                comments.setAttribute("contenteditable", "plaintext-only");
                comments.style.cursor = "text";
                comments.style.border = "1px solid #00f";
              };
              comments.onblur = (e) => {
                const node = view.contentDOM.querySelector("#" + element.getAttribute("id"));
                const newText = e.target.innerText;
                const { state } = view;
                const position = view.posAtDOM(node);
                const line = state.doc.lineAt(position);
                const Exp = RegExp("(" + element.getAttribute("id") + "'>)([\\s\\S]*?)(</span>)", "g");
                const test = line.text.replace(Exp, "$1" + newText + "$3");
                view.dispatch({ changes: { from: line.from, to: line.to, insert: test.replace(/\n/g, "<br>") } });
              };
              if (comments.offsetHeight + 5 >= element.parentElement.parentElement.parentElement.offsetHeight) {
                element.parentElement.parentElement.parentElement.setAttribute("style", `height:${comments.offsetHeight + 5}px;top:0px`);
              } else {
                element.parentElement.parentElement.parentElement.removeAttribute("style");
              }
            }
          });
        }
      }
      update(update) {
        this.dom.style.minHeight = update.view.contentHeight + "px";
        this.setCommnet(update.view);
        if (update.geometryChanged) {
          dispatchEvent(new CustomEvent("notes-update"));
        }
      }
      destroy() {
        this.dom.remove();
      }
    }
  );
}

// src/Plugin/settings.ts
var import_obsidian3 = require("obsidian");
var ExampleSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("\u5BBD\u5EA6").setDesc("\u7B14\u8BB0\u533A\u5BBD\u5EA6").addText(
      (text) => text.setPlaceholder("250").setValue(this.plugin.settings.width).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.width = value;
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian3.Setting(containerEl).setName("\u80CC\u666F\u8272").setDesc("\u7B14\u8BB0\u533A\u80CC\u666F\u8272").addText(
      (text) => text.setPlaceholder("rgb(246, 248, 250)").setValue(this.plugin.settings.backgroundColor).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.backgroundColor = value;
        yield this.plugin.saveSettings();
      }))
    );
  }
};

// src/View/view.ts
var import_obsidian4 = require("obsidian");

// node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
var EMPTY_OBJ = false ? Object.freeze({}) : {};
var EMPTY_ARR = false ? Object.freeze([]) : [];
var NOOP = () => {
};
var NO = () => false;
var onRE = /^on[^a-z]/;
var isOn = (key) => onRE.test(key);
var isModelListener = (key) => key.startsWith("onUpdate:");
var extend = Object.assign;
var remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isSet = (val) => toTypeString(val) === "[object Set]";
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
var toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize(str)}` : ``
);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
var def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
var looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
var toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:([^]+)/;
var styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
var isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
var toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var activeEffectScope;
var EffectScope = class {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
};
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
var createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
var newTracked = (dep) => (dep.n & trackOpBit) > 0;
var initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
var finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
var targetMap = /* @__PURE__ */ new WeakMap();
var effectTrackDepth = 0;
var trackOpBit = 1;
var maxMarkerBits = 30;
var activeEffect;
var ITERATE_KEY = Symbol(false ? "iterate" : "");
var MAP_KEY_ITERATE_KEY = Symbol(false ? "Map key iterate" : "");
var ReactiveEffect = class {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
};
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = false ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (false) {
      activeEffect.onTrack(
        extend(
          {
            effect: activeEffect
          },
          debuggerEventExtraInfo
        )
      );
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = false ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (false) {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (false) {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (false) {
      effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
    }
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
var get$1 = /* @__PURE__ */ createGetter();
var shallowGet = /* @__PURE__ */ createGetter(false, true);
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty2(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty2;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
var set$1 = /* @__PURE__ */ createSetter();
var shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (false) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  },
  deleteProperty(target, key) {
    if (false) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
};
var shallowReactiveHandlers = /* @__PURE__ */ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
var toShallow = (value) => value;
var getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (false) {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = false ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(
        `${capitalize(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (false) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
var toReactive = (value) => isObject(value) ? reactive(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (false) {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (false) {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
var RefImpl = class {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
};
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
var shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var ComputedRefImpl = class {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
};
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = false ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (false) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}

// node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var stack = [];
function warn(msg, ...args) {
  if (true)
    return;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = false ? ErrorTypeStrings[type] : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (false) {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = /* @__PURE__ */ Promise.resolve();
var currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (false) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (false) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (false) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
var getId = (job) => job.id == null ? Infinity : job.id;
var comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (false) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = false ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
if (false) {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (false) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
          );
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (false) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (false) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
var currentRenderingInstance = null;
var currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (false) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (false) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (false) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if (false) {
      warn(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) {
      warn(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    root.transition = vnode.transition;
  }
  if (false) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
var getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
var filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
var isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
var INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (false) {
    warn(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  if (false) {
    if (immediate !== void 0) {
      warn(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const warnInvalidSource = (s) => {
    warn(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v, i) => hasChanged(v, oldValue[i])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (false) {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
var TransitionHookValidator = [Function, Array];
var BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
var BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (false) {
              warn(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            child = c;
            hasFound = true;
            if (true)
              break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (false) {
        warn(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
var BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook3 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook3(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook3(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook3(cancelHook, [el]);
        } else {
          callHook3(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook3(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook3(onLeaveCancelled, [el]);
        } else {
          callHook3(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return isFunction(options) ? /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))() : options;
}
var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
var createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
var onBeforeMount = createHook("bm");
var onMounted = createHook("m");
var onBeforeUpdate = createHook("bu");
var onUpdated = createHook("u");
var onBeforeUnmount = createHook("bum");
var onUnmounted = createHook("um");
var onServerPrefetch = createHook("sp");
var onRenderTriggered = createHook(
  "rtg"
);
var onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if (false) {
      warn(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
var getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
var publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => false ? shallowReadonly(i.props) : i.props,
  $attrs: (i) => false ? shallowReadonly(i.attrs) : i.attrs,
  $slots: (i) => false ? shallowReadonly(i.slots) : i.slots,
  $refs: (i) => false ? shallowReadonly(i.refs) : i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => true ? resolveMergedOptions(i) : i.type,
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: (i) => true ? instanceWatch.bind(i) : NOOP
});
var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
var PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (false) {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      } else if (false) {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (false) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (false) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      if (false) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
var shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = false ? createDuplicateChecker() : null;
  if (false) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (false) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) {
          checkDuplicateProperties("Methods", key);
        }
      } else if (false) {
        warn(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if (false) {
      warn(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (false) {
      warn(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!isObject(data)) {
    } else {
      instance.data = reactive(data);
      if (false) {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (false) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : false ? () => {
        warn(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : NOOP;
      const c = computed2({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (false) {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (false) {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (false) {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (false) {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (false) {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
var uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    if (false) {
      Object.defineProperty(context.config, "unwrapInjectedRef", {
        get() {
          return true;
        },
        set() {
          warn(
            `app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`
          );
        }
      });
    }
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (false) {
          warn(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (false) {
          warn(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) {
            warn(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (false) {
          warn("Mixins are only available in builds supporting Options API");
        }
        return app;
      },
      component(name, component) {
        if (false) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (false) {
          warn(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (false) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (false) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (false) {
            warn(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (false) {
            context.reload = () => {
              render2(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (false) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (false) {
          warn(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          if (false) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (false) {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (false) {
          warn(
            `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
          );
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
var currentApp = null;
function provide(key, value) {
  if (!currentInstance) {
    if (false) {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (false) {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  if (false) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (false) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (false) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (false) {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
var isInternalKey = (key) => key[0] === "_" || key === "$stable";
var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
var normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) {
      warn(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
var normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (false) {
        warn(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
var normalizeVNodeSlots = (instance, children) => {
  if (false) {
    warn(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
var initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
var updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) {
        extend(slots, children);
        trigger(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (false) {
    warn(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (false) {
          warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) {
      warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
function initFeatureFlags() {
  const needWarn = [];
  if (false) {
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (false) {
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (false) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
var queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (false) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = false ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (false) {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        isSVG
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
      if (false) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (false) {
          traverseStaticChildren(n1, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(
            n1,
            n2,
            true
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (false) {
      registerHMR(instance);
    }
    if (false) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (false) {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
    if (false) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (false) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (false) {
              endMeasure(instance, `render`);
            }
            if (false) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (false) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) {
            endMeasure(instance, `render`);
          }
          if (false) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          if (false) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        if (false) {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (false) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (false) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        if (false) {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (false) {
          devtoolsComponentUpdated(instance);
        }
        if (false) {
          popWarningContext();
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (false) {
      effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update.ownerInstance = instance;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (false) {
            warn(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (false) {
      unregisterHMR(instance);
    }
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (false) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
var isTeleport = (type) => type.__isTeleport;
var Fragment = Symbol.for("v-fgt");
var Text = Symbol.for("v-txt");
var Comment = Symbol.for("v-cmt");
var Static = Symbol.for("v-stc");
var blockStack = [];
var currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
var isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (false) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
var InternalObjectKey = `__vInternal`;
var normalizeKey = ({ key }) => key != null ? key : null;
var normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (false) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
var createVNode = false ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (false) {
    type = toRaw(type);
    warn(
      `Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: false ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
var emptyAppContext = createAppContext();
var uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
var currentInstance = null;
var getCurrentInstance = () => currentInstance || currentRenderingInstance;
var internalSetCurrentInstance;
var globalCurrentInstanceSetters;
var settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
var setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
var unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
var isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (false) {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [false ? shallowReadonly(instance.props) : instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) {
          const name = (_a = Component.name) != null ? _a : "Anonymous";
          warn(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (false) {
      warn(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (false) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (false) {
    warn(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
var compile;
var installWithProxy;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (false) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
        if (false) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (false) {
    if (!compile && Component.template) {
      warn(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      );
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    false ? {
      get(target, key) {
        markAttrsAccessed();
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (false) {
      if (instance.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (false) {
    return Object.freeze({
      get attrs() {
        return getAttrsProxy(instance);
      },
      get slots() {
        return getSlotsProxy(instance);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
var computed2 = (getterOrOptions, debugOptions) => {
  return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
var ssrContextKey = Symbol.for("v-scx");
var useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
    }
    return ctx;
  }
};
var version = "3.3.4";

// node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var svgNS = "http://www.w3.org/2000/svg";
var doc = typeof document !== "undefined" ? document : null;
var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
var nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
var importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (false) {
      if (semicolonRE.test(val)) {
        warn(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
var prefixes = ["Webkit", "Moz", "ms"];
var prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (false) {
      warn(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener2(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener2(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener2(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener2(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
var optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
var cachedNow = 0;
var p = /* @__PURE__ */ Promise.resolve();
var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
var nativeOnRE = /^on[a-z]/;
var patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
var TRANSITION = "transition";
var ANIMATION = "animation";
var Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
var callHook2 = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
var hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook2(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook2(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook2(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook2(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook2(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook2(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook2(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  if (false) {
    assertNumber(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
var endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
var positionMap = /* @__PURE__ */ new WeakMap();
var newPositionMap = /* @__PURE__ */ new WeakMap();
var TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        } else if (false) {
          warn(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
var removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
var rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
var renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
var createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (false) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (false) {
      warn(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if (false) {
    warn(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}

// node_modules/vue/dist/vue.runtime.esm-bundler.js
if (false) {
  initDev();
}

// sfc-script:E:\test\.obsidian\plugins\obsidian-codemirror-test\src\View\App.vue?type=script
var App_default = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props, {
    expose: __expose
  }) {
    __expose();
    let compomentSelf = getCurrentInstance();
    let plugin = compomentSelf.appContext.config.globalProperties.plugin;
    let container = compomentSelf.appContext.config.globalProperties.container;
    let findComment = ref();
    onMounted(() => {
      addEventListener("notes-update", reset);
    });
    onUnmounted(() => {
      removeEventListener("notes-update", reset);
    });
    function reset() {
      const view = plugin.current_note;
      const Exp = RegExp("(id='comment-id-.*'>)([\\s\\S]*?)(</span>)", "g");
      findComment.value = view.getViewData().match(Exp);
    }
    const __returned__ = {
      get compomentSelf() {
        return compomentSelf;
      },
      set compomentSelf(v) {
        compomentSelf = v;
      },
      get plugin() {
        return plugin;
      },
      set plugin(v) {
        plugin = v;
      },
      get container() {
        return container;
      },
      set container(v) {
        container = v;
      },
      get findComment() {
        return findComment;
      },
      set findComment(v) {
        findComment = v;
      },
      reset
    };
    Object.defineProperty(__returned__, "__isScriptSetup", {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

// sfc-template:E:\test\.obsidian\plugins\obsidian-codemirror-test\src\View\App.vue?type=template
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(true), createElementBlock(Fragment, null, renderList($setup.findComment, (item) => {
    return openBlock(), createElementBlock("div", null, toDisplayString(item.replace(/<[^>]+>/g, "")), 1);
  }), 256);
}

// src/View/App.vue
App_default.render = render;
App_default.__file = "src\\View\\App.vue";
App_default.__scopeId = "data-v-11ff5612";
var App_default2 = App_default;

// src/View/view.ts
var VIEW_TYPE = "right-notes-view";
var MyView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Vue Stater";
  }
  getIcon() {
    return "dice";
  }
  onOpen() {
    return __async(this, null, function* () {
      const container = this.containerEl.children[1];
      container.empty();
      const mountPoint = container.createEl("div", {
        cls: "my-plugin-view"
      });
      this.vueapp = createApp(App_default2);
      this.vueapp.config.globalProperties.plugin = this.plugin;
      this.vueapp.config.globalProperties.container = mountPoint;
      this.vueapp.mount(".my-plugin-view");
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.vueapp.unmount();
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  width: "250",
  backgroundColor: "rgb(246, 248, 250)"
};
var MyPlugin = class extends import_obsidian5.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new ExampleSettingTab(this.app, this));
      this.registerView(
        VIEW_TYPE,
        (leaf) => new MyView(leaf, this)
      );
      this.addRibbonIcon("dice", "Open my view", (evt) => {
        this.activateView();
      });
      this.registerEditorExtension(EditingViewPlugin(this.app, this));
      this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => __async(this, null, function* () {
        let view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
        if (view) {
          this.current_note = view;
        }
      })));
      this.registerEvent(
        this.app.workspace.on("editor-menu", (menu, editor, view) => {
          menu.addItem((item) => {
            item.setTitle("\u63D2\u5165\u6CE8\u91CA \u{1F448}").setIcon("document").onClick(() => __async(this, null, function* () {
              new ExampleModal(this.app, (result) => {
                const id = Math.random().toString(36).slice(2);
                editor.replaceSelection(`<span class='comment-box'><span>\u{1F4DD}</span><span class="comment" style="display:none;"  id='comment-id-${id}'>${result}</span></span>`);
              }).open();
            }));
          });
        })
      );
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
  }
  activateView() {
    return __async(this, null, function* () {
      if (this.app.workspace.getLeavesOfType(VIEW_TYPE).length === 0) {
        yield this.app.workspace.getRightLeaf(false).setViewState({
          type: VIEW_TYPE,
          active: true
        });
      }
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]
      );
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL0RpYWxvZy9kaWFsb2cudHMiLCAic3JjL1BsdWdpbi9FZGl0b3JFeHRlbnNpb24udHMiLCAic3JjL1BsdWdpbi9zZXR0aW5ncy50cyIsICJzcmMvVmlldy92aWV3LnRzIiwgIm5vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsICJub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsICJub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCAibm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsICJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCAic2ZjLXNjcmlwdDpFOlxcdGVzdFxcLm9ic2lkaWFuXFxwbHVnaW5zXFxvYnNpZGlhbi1jb2RlbWlycm9yLXRlc3RcXHNyY1xcVmlld1xcQXBwLnZ1ZT90eXBlPXNjcmlwdCIsICJzZmMtdGVtcGxhdGU6RTpcXHRlc3RcXC5vYnNpZGlhblxccGx1Z2luc1xcb2JzaWRpYW4tY29kZW1pcnJvci10ZXN0XFxzcmNcXFZpZXdcXEFwcC52dWU/dHlwZT10ZW1wbGF0ZSIsICJzcmMvVmlldy9BcHAudnVlIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQge1xyXG4gIEFwcCxcclxuICBNYXJrZG93blZpZXcsXHJcbiAgTW9kYWwsXHJcbiAgTm90aWNlLFxyXG4gIFBsdWdpbixcclxuICBQbHVnaW5TZXR0aW5nVGFiLFxyXG4gIFNldHRpbmdcclxufSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xyXG5cclxuXHJcbmltcG9ydCB7IGV4YW1wbGVQbHVnaW4gfSBmcm9tICcuL0V4YW1wbGVQbHVnaW4vRXhhbXBsZVBsdWdpbic7XHJcbmltcG9ydCB7IEV4YW1wbGVNb2RhbCB9IGZyb20gJy4vRGlhbG9nL2RpYWxvZyc7XHJcbmltcG9ydCBFZGl0aW5nVmlld1BsdWdpbiBmcm9tICcuL1BsdWdpbi9FZGl0b3JFeHRlbnNpb24nO1xyXG5pbXBvcnQgeyBFeGFtcGxlU2V0dGluZ1RhYiB9IGZyb20gJy4vUGx1Z2luL3NldHRpbmdzJztcclxuaW1wb3J0IHsgTXlWaWV3LCBWSUVXX1RZUEUgfSBmcm9tICcuL1ZpZXcvdmlldydcclxuXHJcblxyXG5cclxuaW50ZXJmYWNlIEV4YW1wbGVQbHVnaW5TZXR0aW5ncyB7XHJcbiAgd2lkdGg6IHN0cmluZztcclxuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQYXJ0aWFsPEV4YW1wbGVQbHVnaW5TZXR0aW5ncz4gPSB7XHJcbiAgd2lkdGg6IFwiMjUwXCIsXHJcbiAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0NiwgMjQ4LCAyNTApJ1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHJcbiAgc2V0dGluZ3M6IEV4YW1wbGVQbHVnaW5TZXR0aW5ncztcclxuICBjdXJyZW50X25vdGU6IE1hcmtkb3duVmlldztcclxuXHJcblxyXG4gIGFzeW5jIG9ubG9hZCgpIHtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgRXhhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyVmlldyhcclxuICAgICAgVklFV19UWVBFLFxyXG4gICAgICAobGVhZikgPT4gbmV3IE15VmlldyhsZWFmLCB0aGlzKVxyXG4gICAgKVxyXG5cclxuICAgIHRoaXMuYWRkUmliYm9uSWNvbignZGljZScsICdPcGVuIG15IHZpZXcnLCAoZXZ0KSA9PiB7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVWaWV3KClcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihFZGl0aW5nVmlld1BsdWdpbih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2FjdGl2ZS1sZWFmLWNoYW5nZScsIGFzeW5jIChsZWFmKSA9PiB7XHJcbiAgICAgIGxldCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRfbm90ZSA9IHZpZXdcclxuICAgICAgfVxyXG4gICAgfSkpXHJcblxyXG5cclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXHJcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbihcImVkaXRvci1tZW51XCIsIChtZW51LCBlZGl0b3IsIHZpZXcpID0+IHtcclxuICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcclxuICAgICAgICAgIGl0ZW1cclxuICAgICAgICAgICAgLnNldFRpdGxlKFwiXHU2M0QyXHU1MTY1XHU2Q0U4XHU5MUNBIFx1RDgzRFx1REM0OFwiKVxyXG4gICAgICAgICAgICAuc2V0SWNvbihcImRvY3VtZW50XCIpXHJcbiAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICBuZXcgRXhhbXBsZU1vZGFsKHRoaXMuYXBwLCAocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpXHJcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihgPHNwYW4gY2xhc3M9J2NvbW1lbnQtYm94Jz48c3Bhbj5cdUQ4M0RcdURDREQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJjb21tZW50XCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCIgIGlkPSdjb21tZW50LWlkLSR7aWR9Jz4ke3Jlc3VsdH08L3NwYW4+PC9zcGFuPmApO1xyXG4gICAgICAgICAgICAgIH0pLm9wZW4oKVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcblxyXG4gIG9udW5sb2FkKCkge1xyXG4gICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShWSUVXX1RZUEUpXHJcbiAgfVxyXG5cclxuXHJcbiAgYXN5bmMgYWN0aXZhdGVWaWV3KCkge1xyXG4gICAgaWYgKHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoVklFV19UWVBFKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSkuc2V0Vmlld1N0YXRlKHtcclxuICAgICAgICB0eXBlOiBWSUVXX1RZUEUsXHJcbiAgICAgICAgYWN0aXZlOiB0cnVlLFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxyXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlbMF1cclxuICAgIClcclxuICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nLCBUZXh0QXJlYUNvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBFeGFtcGxlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgcmVzdWx0OiBzdHJpbmc7XHJcbiAgb25TdWJtaXQ6IChyZXN1bHQ6IHN0cmluZykgPT4gdm9pZDtcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uU3VibWl0OiAocmVzdWx0OiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgIHN1cGVyKGFwcCk7XHJcbiAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XHJcbiAgfVxyXG5cclxuICBvbk9wZW4oKSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoNlwiLCB7IHRleHQ6IFwiXHU2MEE4XHU3Njg0XHU2MEYzXHU2Q0Q1XHU2NjJGXHVGRjFGXCIgfSk7XHJcblxyXG4gICAgY29uc3Qgc3R5bGluZ1RlbXBsYXRlU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcclxuXHJcbiAgICBjb25zdCBzdHlsaW5nVGVtcGxhdGVDb250ZW50ID0gbmV3IFRleHRBcmVhQ29tcG9uZW50KHN0eWxpbmdUZW1wbGF0ZVNldHRpbmcuY29udHJvbEVsKTtcclxuXHJcbiAgICBzdHlsaW5nVGVtcGxhdGVTZXR0aW5nLnNldHRpbmdFbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IGdyaWQ7IGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyO1wiKTtcclxuXHJcbiAgICBzdHlsaW5nVGVtcGxhdGVDb250ZW50LmlucHV0RWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDogMTAwJTsgIGhlaWdodDogMTh2aDsnKVxyXG5cclxuICAgIHN0eWxpbmdUZW1wbGF0ZUNvbnRlbnQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblxyXG5cclxuICAgICAgdGhpcy5yZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpOyAgLy8ucmVwbGFjZSgvLisvZywgXCI8ZGl2PiQmPC9kaXY+XCIpO1xyXG5cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXHJcbiAgICAgIC5hZGRCdXR0b24oKGJ0bikgPT5cclxuICAgICAgICBidG5cclxuICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiXHU3ODZFXHU1QjlBXCIpXHJcbiAgICAgICAgICAuc2V0Q3RhKClcclxuICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucmVzdWx0KTtcclxuICAgICAgICAgIH0pKTtcclxuICB9XHJcblxyXG4gIG9uQ2xvc2UoKSB7XHJcbiAgICBsZXQgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcbiAgICBjb250ZW50RWwuZW1wdHkoKTtcclxuICB9XHJcbn0iLCAiaW1wb3J0IHtcclxuICAgIFZpZXdVcGRhdGUsXHJcbiAgICBQbHVnaW5WYWx1ZSxcclxuICAgIEVkaXRvclZpZXcsXHJcbiAgICBWaWV3UGx1Z2luLFxyXG59IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XHJcbmltcG9ydCB7IEFwcCwgTWFya2Rvd25WaWV3LCBXb3Jrc3BhY2VMZWFmLCBzZXRJY29uIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwic3JjL21haW5cIjtcclxuXHJcblxyXG5jb25zdCBsYWJlbCA9IFwiVmlldyBub3Rlc1wiO1xyXG5cclxuY29uc3QgYWRkU3JjQnV0dG9uID0gKGFwcDogQXBwLHBsdWdpbjogTXlQbHVnaW4pID0+IHtcclxuICAgIGNvbnN0IGFwcGx5ID0gKCkgPT4gYXBwLndvcmtzcGFjZS5pdGVyYXRlQWxsTGVhdmVzKGFkZEJ1dHRvbihhcHAscGx1Z2luKSk7XHJcblxyXG4gICAgYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KGFwcGx5KTtcclxuICAgIGFwcC53b3Jrc3BhY2Uub24oXCJsYXlvdXQtY2hhbmdlXCIsIGFwcGx5KTtcclxufTtcclxuXHJcblxyXG5jb25zdCBhZGRCdXR0b24gPSAoYXBwOiBBcHAscGx1Z2luOiBNeVBsdWdpbikgPT4gKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IHtcclxuICAgIGlmIChcclxuICAgICAgICBsZWFmLnZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcgJiZcclxuICAgICAgICBsZWFmLnZpZXcuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihcclxuICAgICAgICAgICAgYGEudmlldy1hY3Rpb25bYXJpYS1sYWJlbD1cIiR7bGFiZWx9XCJdYCxcclxuICAgICAgICApID09PSBudWxsXHJcbiAgICApIHtcclxuICAgICAgICBsZXQgdmlldyA9IGxlYWYudmlldztcclxuICAgICAgICBsZXQgaXNXb3JrID0gZmFsc2VcclxuICAgICAgICBjb25zdCBidXR0b25FbGVtZW50ID0gdmlldy5hZGRBY3Rpb24oXCJwZGYtZmlsZVwiLCBsYWJlbCwgKGV2dCkgPT4ge1xyXG5cclxuXHJcbiAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBjb25zdCByaWdodEd1dHRlcnMgPSB2aWV3LmNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCcjcmlnaHQtZ3V0dGVycycpXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNXb3JrKSB7XHJcbiAgICAgICAgICAgICAgICBpc1dvcmsgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHRHdXR0ZXJzLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpibG9jaycpXHJcbiAgICAgICAgICAgICAgICByaWdodEd1dHRlcnMuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBiYWNrZ3JvdW5kLWNvbG9yOiR7cGx1Z2luLnNldHRpbmdzLmJhY2tncm91bmRDb2xvcn0haW1wb3J0YW50O3dpZHRoOiR7cGx1Z2luLnNldHRpbmdzLndpZHRofXB4O21hcmdpbi1yaWdodDogMzBweGApO1xyXG4gICAgICAgICAgICAgICAgc2V0SWNvbihidXR0b25FbGVtZW50LCAncGRmLWZpbGUnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlzV29yayA9IHRydWVcclxuICAgICAgICAgICAgICAgIHJpZ2h0R3V0dGVycy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZScpXHJcbiAgICAgICAgICAgICAgICBzZXRJY29uKGJ1dHRvbkVsZW1lbnQsICdhZGQtbm90ZS1nbHlwaCcpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICBcclxuXHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWRpdGluZ1ZpZXdQbHVnaW4oYXBwOiBBcHAscGx1Z2luOiBNeVBsdWdpbikge1xyXG4gICAgXHJcblxyXG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZnJvbUNsYXNzKFxyXG4gICAgICAgIGNsYXNzIEV4YW1wbGVQbHVnaW4gaW1wbGVtZW50cyBQbHVnaW5WYWx1ZSB7XHJcblxyXG5cclxuICAgICAgICAgICAgZG9tOiBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgZml4ZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgICAgIHByZXZWaWV3cG9ydDogeyBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IEVkaXRvclZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdmlldy52aWV3cG9ydDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSAnY20tZ3V0dGVycyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6JHtwbHVnaW4uc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yfSFpbXBvcnRhbnQ7d2lkdGg6JHtwbHVnaW4uc2V0dGluZ3Mud2lkdGh9cHg7bWFyZ2luLXJpZ2h0OiAzMHB4YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInJpZ2h0LWd1dHRlcnNcIilcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHZpZXcuY29udGVudEhlaWdodCArICdweCc7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRBZnRlcih0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NLm5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGFkZFNyY0J1dHRvbihhcHAscGx1Z2luKVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgc2V0Q29tbW5ldCh2aWV3OiBFZGl0b3JWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBfZ2V0X2d1dHRlciA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoJyNyaWdodC1ndXR0ZXJzJylcclxuICAgICAgICAgICAgICAgIGlmIChfZ2V0X2d1dHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIF9nZXRfZ3V0dGVyLmVtcHR5KClcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5kQ29tbWVudCA9IHZpZXcuY29udGVudERPTS5xdWVyeVNlbGVjdG9yQWxsKFwiLmNvbW1lbnRcIilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZENvbW1lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRTdHlsZSA9IHZpZXcuY29udGVudERPTS5xdWVyeVNlbGVjdG9yQWxsKFwiLmNtLWxpbmVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluZFN0eWxlLmZvckVhY2goJGVsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnZXRTdHlsZXMgPSAkZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0U3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFN0eWxlcy5lbmRzV2l0aCgndG9wOjBweCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmaW5kQ29tbWVudC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnN0eWxlLnRvcCA9IGVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQub2Zmc2V0VG9wICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuYWRkQ2xhc3MoJ3JpZ2h0Q29tbWVudHMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nZXRfZ3V0dGVyLmFwcGVuZChjb21tZW50cylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5vbmNsaWNrID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdwbGFpbnRleHQtb25seScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3R5bGUuY3Vyc29yID0gJ3RleHQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjMDBmJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLm9uYmx1ciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHZpZXcuY29udGVudERPTS5xdWVyeVNlbGVjdG9yKCcjJyArIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlubmVyVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2aWV3LnBvc0F0RE9NKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBFeHAgPSBSZWdFeHAoXCIoXCIgKyBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSArIFwiJz4pKFtcXFxcc1xcXFxTXSo/KSg8XFwvc3Bhbj4pXCIsIFwiZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBsaW5lLnRleHQucmVwbGFjZShFeHAsICckMScgKyBuZXdUZXh0ICsgJyQzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLnRvLCBpbnNlcnQ6IHRlc3QucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSwgfSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50cy5vZmZzZXRIZWlnaHQgKyA1ID49IGVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGhlaWdodDoke2NvbW1lbnRzLm9mZnNldEhlaWdodCArIDV9cHg7dG9wOjBweGApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSB1cGRhdGUudmlldy5jb250ZW50SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29tbW5ldCh1cGRhdGUudmlldylcclxuXHJcbiAgICAgICAgICAgICAgICBpZih1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKXtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIm5vdGVzLXVwZGF0ZVwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgKTtcclxufSIsICJpbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuXHJcblxyXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBFeGFtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG4gIHBsdWdpbjogTXlQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlx1NUJCRFx1NUVBNlwiKVxyXG4gICAgICAuc2V0RGVzYyhcIlx1N0IxNFx1OEJCMFx1NTMzQVx1NUJCRFx1NUVBNlwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCIyNTBcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy53aWR0aClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mud2lkdGggPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiXHU4MENDXHU2NjZGXHU4MjcyXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiXHU3QjE0XHU4QkIwXHU1MzNBXHU4MENDXHU2NjZGXHU4MjcyXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcInJnYigyNDYsIDI0OCwgMjUwKVwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJhY2tncm91bmRDb2xvcilcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuICB9XHJcbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IGNyZWF0ZUFwcCwgQXBwIGFzIFZ1ZUFwcCB9IGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJztcclxuaW1wb3J0IE15UGx1Z2luIGZyb20gJ3NyYy9tYWluJztcclxuXHJcbmV4cG9ydCBjb25zdCBWSUVXX1RZUEU6IHN0cmluZyA9ICdyaWdodC1ub3Rlcy12aWV3JztcclxuXHJcbmV4cG9ydCBjbGFzcyBNeVZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XHJcblxyXG4gICAgdnVlYXBwOiBWdWVBcHA7XHJcbiAgICBwbHVnaW4gOiBNeVBsdWdpblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYscGx1Z2luOk15UGx1Z2luKSB7XHJcbiAgICAgICAgc3VwZXIobGVhZik7XHJcblxyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXHJcbiAgICB9XHJcbiAgICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBWSUVXX1RZUEU7XHJcbiAgICB9XHJcbiAgICBnZXREaXNwbGF5VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBcIlZ1ZSBTdGF0ZXJcIjtcclxuICAgIH1cclxuICAgIGdldEljb24oKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCJkaWNlXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbk9wZW4oKSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcclxuICAgICAgICBjb250YWluZXIuZW1wdHkoKTtcclxuICAgICAgIGNvbnN0IG1vdW50UG9pbnQgPSAgY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcclxuICAgICAgICAgICAgY2xzOiBcIm15LXBsdWdpbi12aWV3XCJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZ1ZWFwcCA9IGNyZWF0ZUFwcChBcHApO1xyXG4gICAgICAgIHRoaXMudnVlYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLnBsdWdpbiA9IHRoaXMucGx1Z2luO1xyXG4gICAgICAgIHRoaXMudnVlYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLmNvbnRhaW5lciA9IG1vdW50UG9pbnQ7XHJcbiAgICAgICAgdGhpcy52dWVhcHAubW91bnQoJy5teS1wbHVnaW4tdmlldycpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25DbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnZ1ZWFwcC51bm1vdW50KCk7XHJcbiAgICB9XHJcblxyXG59IiwgImZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KFwiLFwiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6ICh2YWwpID0+ICEhbWFwW3ZhbF07XG59XG5cbmNvbnN0IEVNUFRZX09CSiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKHt9KSA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBvblJFID0gL15vblteYS16XS87XG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbn0pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG4pO1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgXG4pO1xuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm5zW2ldKGFyZyk7XG4gIH1cbn07XG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZVxuICB9KTtcbn07XG5jb25zdCBsb29zZVRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gIHJldHVybiBfZ2xvYmFsVGhpcyB8fCAoX2dsb2JhbFRoaXMgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbn07XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpID8gYF9fcHJvcHMuJHtuYW1lfWAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZVwiO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIGAke2xpbmV9JHtcIiBcIi5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiIFwiLnJlcGVhdChwYWQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSkgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKlteXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNzc1RleHQucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgXCJcIikuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICBsZXQgcmV0ID0gXCJcIjtcbiAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcylcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cbiAgaWYgKHN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5jb25zdCBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG5jb25zdCBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCI7XG5jb25zdCBWT0lEX1RBR1MgPSBcImFyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyXCI7XG5jb25zdCBpc0hUTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuY29uc3QgaXNTVkdUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5jb25zdCBpc1ZvaWRUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4saW5lcnQsbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYFxuKTtcbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIjtcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgfVxuICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgaWYgKGlzVW5zYWZlKSB7XG4gICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgaHRtbEZvcjogXCJmb3JcIixcbiAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxufTtcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbmVydCxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgXG4pO1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwscmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcix0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbix0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyx2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCx2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyx4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmBcbik7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKVxuICAgIHJldHVybiB0cnVlO1xuICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKGFIYXNLZXkgJiYgIWJIYXNLZXkgfHwgIWFIYXNLZXkgJiYgYkhhc0tleSB8fCAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbDJdKSA9PiB7XG4gICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsMjtcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICB9LCB7fSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaGFzT3duLCBpc1N5bWJvbCwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcnVuKGZuKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICB0cnkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvbigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvZmYoKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgfVxuICBzdG9wKGZyb21QYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIHJlY29yZEVmZmVjdFNjb3BlKGVmZmVjdCwgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZSkge1xuICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcbiAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVEZXAgPSAoZWZmZWN0cykgPT4ge1xuICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xuICBkZXAudyA9IDA7XG4gIGRlcC5uID0gMDtcbiAgcmV0dXJuIGRlcDtcbn07XG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IGluaXREZXBNYXJrZXJzID0gKHsgZGVwcyB9KSA9PiB7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwc1tpXS53IHw9IHRyYWNrT3BCaXQ7XG4gICAgfVxuICB9XG59O1xuY29uc3QgZmluYWxpemVEZXBNYXJrZXJzID0gKGVmZmVjdCkgPT4ge1xuICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgbGV0IHB0ciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZXAgPSBkZXBzW2ldO1xuICAgICAgaWYgKHdhc1RyYWNrZWQoZGVwKSAmJiAhbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xuICAgICAgfVxuICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XG4gICAgICBkZXAubiAmPSB+dHJhY2tPcEJpdDtcbiAgICB9XG4gICAgZGVwcy5sZW5ndGggPSBwdHI7XG4gIH1cbn07XG5cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xubGV0IHRyYWNrT3BCaXQgPSAxO1xuY29uc3QgbWF4TWFya2VyQml0cyA9IDMwO1xubGV0IGFjdGl2ZUVmZmVjdDtcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIml0ZXJhdGVcIiA6IFwiXCIpO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xuICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcbiAgICBsZXQgbGFzdFNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgICBhY3RpdmVFZmZlY3QgPSB0aGlzO1xuICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgKytlZmZlY3RUcmFja0RlcHRoO1xuICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XG4gICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xuICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAoYWN0aXZlRWZmZWN0ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xuICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZWZmZWN0Mikge1xuICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDI7XG4gIGlmIChkZXBzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0Mik7XG4gICAgfVxuICAgIGRlcHMubGVuZ3RoID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBfZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpXG4gICAgICByZWNvcmRFZmZlY3RTY29wZShfZWZmZWN0LCBvcHRpb25zLnNjb3BlKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xuICAgIF9lZmZlY3QucnVuKCk7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcbiAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gY3JlYXRlRGVwKCkpO1xuICAgIH1cbiAgICBjb25zdCBldmVudEluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfSA6IHZvaWQgMDtcbiAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xuICB9XG59XG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGxldCBzaG91bGRUcmFjazIgPSBmYWxzZTtcbiAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICBkZXAubiB8PSB0cmFja09wQml0O1xuICAgICAgc2hvdWxkVHJhY2syID0gIXdhc1RyYWNrZWQoZGVwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVHJhY2syID0gIWRlcC5oYXMoYWN0aXZlRWZmZWN0KTtcbiAgfVxuICBpZiAoc2hvdWxkVHJhY2syKSB7XG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVFZmZlY3Qub25UcmFjaykge1xuICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdnZXJFdmVudEV4dHJhSW5mb1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzID0gW107XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBpc0FycmF5KHRhcmdldCkpIHtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID49IG5ld0xlbmd0aCkge1xuICAgICAgICBkZXBzLnB1c2goZGVwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChrZXkpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGV2ZW50SW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9IDogdm9pZCAwO1xuICBpZiAoZGVwcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZGVwc1swXSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwc1swXSwgZXZlbnRJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlZmZlY3RzID0gW107XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuICAgICAgaWYgKGRlcCkge1xuICAgICAgICBlZmZlY3RzLnB1c2goLi4uZGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3RzKGNyZWF0ZURlcChlZmZlY3RzKSwgZXZlbnRJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICBjb25zdCBlZmZlY3RzID0gaXNBcnJheShkZXApID8gZGVwIDogWy4uLmRlcF07XG4gIGZvciAoY29uc3QgZWZmZWN0MiBvZiBlZmZlY3RzKSB7XG4gICAgaWYgKGVmZmVjdDIuY29tcHV0ZWQpIHtcbiAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0MiwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZWZmZWN0MiBvZiBlZmZlY3RzKSB7XG4gICAgaWYgKCFlZmZlY3QyLmNvbXB1dGVkKSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdDIsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdChlZmZlY3QyLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gIGlmIChlZmZlY3QyICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0Mi5hbGxvd1JlY3Vyc2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBlZmZlY3QyLm9uVHJpZ2dlcikge1xuICAgICAgZWZmZWN0Mi5vblRyaWdnZXIoZXh0ZW5kKHsgZWZmZWN0OiBlZmZlY3QyIH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdDIuc2NoZWR1bGVyKSB7XG4gICAgICBlZmZlY3QyLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QyLnJ1bigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHRhcmdldE1hcC5nZXQob2JqZWN0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5jb25zdCBnZXQkMSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcbiAgW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiwgaSArIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gYXJyW2tleV0oLi4uYXJncyk7XG4gICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwidW5zaGlmdFwiLCBcInNwbGljZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkyID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0Mih0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xuICAgICAgcmV0dXJuIHNoYWxsb3c7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiICYmIHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoc2hhbGxvdykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpID8gcmVzIDogcmVzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5jb25zdCBzZXQkMSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gc2V0Mih0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVhZG9ubHkob2xkVmFsdWUpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2hhbGxvdykge1xuICAgICAgaWYgKCFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzJDEodGFyZ2V0LCBrZXkpIHtcbiAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICBpZiAoIWlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiLCBpc0FycmF5KHRhcmdldCkgPyBcImxlbmd0aFwiIDogSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gIGdldDogZ2V0JDEsXG4gIHNldDogc2V0JDEsXG4gIGRlbGV0ZVByb3BlcnR5LFxuICBoYXM6IGhhcyQxLFxuICBvd25LZXlzXG59O1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgZ2V0OiByZWFkb25seUdldCxcbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgbXV0YWJsZUhhbmRsZXJzLFxuICB7XG4gICAgZ2V0OiBzaGFsbG93R2V0LFxuICAgIHNldDogc2hhbGxvd1NldFxuICB9XG4pO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKFxuICB7fSxcbiAgcmVhZG9ubHlIYW5kbGVycyxcbiAge1xuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XG4gIH1cbik7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmICghaXNSZWFkb25seSkge1xuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gIH1cbiAgY29uc3QgeyBoYXM6IGhhczIgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgfSBlbHNlIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICB9XG4gIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgeyBoYXM6IGhhczIsIGdldDogZ2V0MiB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQyIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDIgPyBnZXQyLmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gIGlmIChoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gIGlmIChoYWRJdGVtcykge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XG4gICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKFxuICAgICAgcmF3VGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyB2YWx1ZSwgZG9uZSB9IDoge1xuICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRvUmF3KHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XG4gIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzLFxuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICB9O1xuICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG4gIH07XG4gIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1wia2V5c1wiLCBcInZhbHVlc1wiLCBcImVudHJpZXNcIiwgU3ltYm9sLml0ZXJhdG9yXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QoXG4gICAgICBtZXRob2QsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIHRydWUsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChcbiAgICAgIG1ldGhvZCxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKFxuICAgICAgbWV0aG9kLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIsXG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMixcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczJcbiAgXTtcbn1cbmNvbnN0IFtcbiAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXG4gIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcbiAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXG4gIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcbl0gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3cgPyBpc1JlYWRvbmx5ID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seSA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgLyogSU5WQUxJRCAqLyA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcbiAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBtdXRhYmxlSGFuZGxlcnMsXG4gICAgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLFxuICAgIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHJlYWRvbmx5SGFuZGxlcnMsXG4gICAgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seTIsIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XG4gIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiB0cmFja1JlZlZhbHVlKHJlZjIpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgIHJlZjIgPSB0b1JhdyhyZWYyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdHJhY2tFZmZlY3RzKHJlZjIuZGVwIHx8IChyZWYyLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tFZmZlY3RzKHJlZjIuZGVwIHx8IChyZWYyLmRlcCA9IGNyZWF0ZURlcCgpKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmVmFsdWUocmVmMiwgbmV3VmFsKSB7XG4gIHJlZjIgPSB0b1JhdyhyZWYyKTtcbiAgY29uc3QgZGVwID0gcmVmMi5kZXA7XG4gIGlmIChkZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwLCB7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyRWZmZWN0cyhkZXApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNSZWYocikge1xuICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIF9fdl9pc1NoYWxsb3cpIHtcbiAgICB0aGlzLl9fdl9pc1NoYWxsb3cgPSBfX3ZfaXNTaGFsbG93O1xuICAgIHRoaXMuZGVwID0gdm9pZCAwO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzLl9fdl9pc1NoYWxsb3cgfHwgaXNTaGFsbG93KG5ld1ZhbCkgfHwgaXNSZWFkb25seShuZXdWYWwpO1xuICAgIG5ld1ZhbCA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICB0aGlzLl92YWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SZWFjdGl2ZShuZXdWYWwpO1xuICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgdHJpZ2dlclJlZlZhbHVlKHJlZjIsICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWYyLnZhbHVlIDogdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxuICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcykgPyBvYmplY3RXaXRoUmVmcyA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbn1cbmNsYXNzIEN1c3RvbVJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoXG4gICAgICAoKSA9PiB0cmFja1JlZlZhbHVlKHRoaXMpLFxuICAgICAgKCkgPT4gdHJpZ2dlclJlZlZhbHVlKHRoaXMpXG4gICAgKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHZhbCA9PT0gdm9pZCAwID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcbiAgfVxuICBnZXQgZGVwKCkge1xuICAgIHJldHVybiBnZXREZXBGcm9tUmVhY3RpdmUodG9SYXcodGhpcy5fb2JqZWN0KSwgdGhpcy5fa2V5KTtcbiAgfVxufVxuY2xhc3MgR2V0dGVyUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9nZXR0ZXIpIHtcbiAgICB0aGlzLl9nZXR0ZXIgPSBfZ2V0dGVyO1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB0aGlzLl9fdl9pc1JlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldHRlcigpO1xuICB9XG59XG5mdW5jdGlvbiB0b1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IEdldHRlclJlZkltcGwoc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlZihzb3VyY2UpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gIHJldHVybiBpc1JlZih2YWwpID8gdmFsIDogbmV3IE9iamVjdFJlZkltcGwoXG4gICAgc291cmNlLFxuICAgIGtleSxcbiAgICBkZWZhdWx0VmFsdWVcbiAgKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IGZhbHNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIHRoaXMuZWZmZWN0LmFjdGl2ZSA9IHRoaXMuX2NhY2hlYWJsZSA9ICFpc1NTUjtcbiAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSBpc1JlYWRvbmx5O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XG4gICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcbiAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xuICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgc2V0dGVyO1xuICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICBpZiAob25seUdldHRlcikge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICBzZXR0ZXIgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgfSA6IE5PT1A7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVidWdPcHRpb25zICYmICFpc1NTUikge1xuICAgIGNSZWYuZWZmZWN0Lm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIHJldHVybiBjUmVmO1xufVxuXG5jb25zdCB0aWNrID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBxdWV1ZWQgPSBmYWxzZTtcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xuICBxdWV1ZS5wdXNoKGZuKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIHRpY2sudGhlbihmbHVzaCk7XG4gIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldKCk7XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgcXVldWVkID0gZmFsc2U7XG59O1xuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihnZXR0ZXIpIHtcbiAgICB0aGlzLmRlcCA9IHZvaWQgMDtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IHRydWU7XG4gICAgbGV0IGNvbXBhcmVUYXJnZXQ7XG4gICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoY29tcHV0ZWRUcmlnZ2VyKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXApIHtcbiAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xuICAgICAgICAgIGNvbXBhcmVUYXJnZXQgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVUb0NvbXBhcmUgPSBoYXNDb21wYXJlVGFyZ2V0ID8gY29tcGFyZVRhcmdldCA6IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZmZlY3QuYWN0aXZlICYmIHRoaXMuX2dldCgpICE9PSB2YWx1ZVRvQ29tcGFyZSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICBpZiAoZS5jb21wdXRlZCBpbnN0YW5jZW9mIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKSB7XG4gICAgICAgICAgICBlLnNjaGVkdWxlcihcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAvKiBjb21wdXRlZFRyaWdnZXIgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICB9XG4gIF9nZXQoKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xuICByZXR1cm4gbmV3IERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKGdldHRlcik7XG59XG5cbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGRlZmVycmVkQ29tcHV0ZWQsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwgImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgZ2V0Q3VycmVudFNjb3BlLCBpc1NoYWxsb3cgYXMgaXNTaGFsbG93JDEsIGlzUmVhY3RpdmUsIFJlYWN0aXZlRWZmZWN0LCByZWYsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHByb3h5UmVmcywgbWFya1JhdywgRWZmZWN0U2NvcGUsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBFTVBUWV9PQkosIHRvSGFuZGxlcktleSwgbG9vc2VUb051bWJlciwgaHlwaGVuYXRlLCBjYW1lbGl6ZSwgaXNPYmplY3QsIGlzT24sIGhhc093biwgaXNNb2RlbExpc3RlbmVyLCB0b051bWJlciwgaGFzQ2hhbmdlZCwgcmVtb3ZlLCBpc1NldCwgaXNNYXAsIGlzUGxhaW5PYmplY3QsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaW52b2tlQXJyYXlGbnMsIGlzUmVnRXhwLCBjYXBpdGFsaXplLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIE5PLCBkZWYsIGlzUmVzZXJ2ZWRQcm9wLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gIHN0YWNrLnB1c2godm5vZGUpO1xufVxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XG4gIHN0YWNrLnBvcCgpO1xufVxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKVxuICAgIHJldHVybjtcbiAgcGF1c2VUcmFja2luZygpO1xuICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XG4gIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgYXBwV2FybkhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDExLFxuICAgICAgW1xuICAgICAgICBtc2cgKyBhcmdzLmpvaW4oXCJcIiksXG4gICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxuICAgICAgICB0cmFjZS5tYXAoXG4gICAgICAgICAgKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdHJhY2VcbiAgICAgIF1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcbiAgICBpZiAodHJhY2UubGVuZ3RoICYmIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXG4gICAgdHJ1ZSkge1xuICAgICAgd2FybkFyZ3MucHVzaChgXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICB9XG4gIHJlc2V0VHJhY2tpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICBjb25zdCBsb2dzID0gW107XG4gIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXG5gXSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgIHZub2RlLmNvbXBvbmVudCxcbiAgICB2bm9kZS50eXBlLFxuICAgIGlzUm9vdFxuICApfWA7XG4gIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgcmV0dXJuIHZub2RlLnByb3BzID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdIDogW29wZW4gKyBjbG9zZV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKVxuICAgIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICB3YXJuKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKGAke3R5cGV9IGlzIE5hTiAtIHRoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC5gKTtcbiAgfVxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xuICBbXCJzcFwiXTogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIFtcImJjXCJdOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXG4gIFtcImJtXCJdOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgW1wibVwiXTogXCJtb3VudGVkIGhvb2tcIixcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgW1widVwiXTogXCJ1cGRhdGVkXCIsXG4gIFtcImJ1bVwiXTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgW1wiYVwiXTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJkYVwiXTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBbXCJydGNcIl06IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIFtcInJ0Z1wiXTogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcbiAgWzFdOiBcInJlbmRlciBmdW5jdGlvblwiLFxuICBbMl06IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcbiAgWzRdOiBcIndhdGNoZXIgY2xlYW51cCBmdW5jdGlvblwiLFxuICBbNV06IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXG4gIFs3XTogXCJ2bm9kZSBob29rXCIsXG4gIFs4XTogXCJkaXJlY3RpdmUgaG9va1wiLFxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXG4gIFsxMF06IFwiYXBwIGVycm9ySGFuZGxlclwiLFxuICBbMTFdOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxuICBbMTNdOiBcImFzeW5jIGNvbXBvbmVudCBsb2FkZXJcIixcbiAgWzE0XTogXCJzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9jb3JlXCJcbn07XG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGxldCByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcbiAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGNvbnN0IGNvbnRleHRWTm9kZSA9IGluc3RhbmNlID8gaW5zdGFuY2Uudm5vZGUgOiBudWxsO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBsZXQgY3VyID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGVycm9ySW5mbyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcbiAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XG4gICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICAgIGFwcEVycm9ySGFuZGxlcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMTAsXG4gICAgICAgIFtlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvXVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XG4gICAgaWYgKGNvbnRleHRWTm9kZSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XG4gICAgfVxuICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XG5sZXQgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IDA7XG5jb25zdCBwZW5kaW5nUG9zdEZsdXNoQ2JzID0gW107XG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XG4gIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgbGV0IHN0YXJ0ID0gZmx1c2hJbmRleCArIDE7XG4gIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+PiAxO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XG4gICAgbWlkZGxlSm9iSWQgPCBpZCA/IHN0YXJ0ID0gbWlkZGxlICsgMSA6IGVuZCA9IG1pZGRsZTtcbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCFxdWV1ZS5sZW5ndGggfHwgIXF1ZXVlLmluY2x1ZGVzKFxuICAgIGpvYixcbiAgICBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXhcbiAgKSkge1xuICAgIGlmIChqb2IuaWQgPT0gbnVsbCkge1xuICAgICAgcXVldWUucHVzaChqb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XG4gICAgfVxuICAgIHF1ZXVlRmx1c2goKTtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xuICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcbiAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgaWYgKGkgPiBmbHVzaEluZGV4KSB7XG4gICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoIWFjdGl2ZVBvc3RGbHVzaENicyB8fCAhYWN0aXZlUG9zdEZsdXNoQ2JzLmluY2x1ZGVzKFxuICAgICAgY2IsXG4gICAgICBjYi5hbGxvd1JlY3Vyc2UgPyBwb3N0Rmx1c2hJbmRleCArIDEgOiBwb3N0Rmx1c2hJbmRleFxuICAgICkpIHtcbiAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaChjYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBpID0gaXNGbHVzaGluZyA/IGZsdXNoSW5kZXggKyAxIDogMCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgaWYgKGNiICYmIGNiLnByZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgIGktLTtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XG4gICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XG4gICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSgpO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xuY29uc3QgY29tcGFyYXRvciA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBnZXRJZChhKSAtIGdldElkKGIpO1xuICBpZiAoZGlmZiA9PT0gMCkge1xuICAgIGlmIChhLnByZSAmJiAhYi5wcmUpXG4gICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGIucHJlICYmICFhLnByZSlcbiAgICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBkaWZmO1xufTtcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XG4gIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gIGlzRmx1c2hpbmcgPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcXVldWUuc29ydChjb21wYXJhdG9yKTtcbiAgY29uc3QgY2hlY2sgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYikgOiBOT09QO1xuICB0cnkge1xuICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCk7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGZsdXNoSW5kZXggPSAwO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICBpZiAoIXNlZW4uaGFzKGZuKSkge1xuICAgIHNlZW4uc2V0KGZuLCAxKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcbiAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgICAgd2FybihcbiAgICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gICAgfVxuICB9XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKVxuICAgIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhvbGRDb21wKSkge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgfVxuICAgIGluc3RhbmNlLmFwcENvbnRleHQucHJvcHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKFxuICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scztcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gIGlmIChkZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgZGV2dG9vbHMgPSBob29rO1xuICBpZiAoZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcbiAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgYnVmZmVyID0gW107XG4gIH0gZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XG4gICAgd2luZG93LkhUTUxFbGVtZW50ICYmIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwianNkb21cIikpXG4gICkge1xuICAgIGNvbnN0IHJlcGxheSA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW107XG4gICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgIHNldERldnRvb2xzSG9vayhuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scykge1xuICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfSwgM2UzKTtcbiAgfSBlbHNlIHtcbiAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgYnVmZmVyID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pIHtcbiAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgRnJhZ21lbnQsXG4gICAgVGV4dCxcbiAgICBDb21tZW50LFxuICAgIFN0YXRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgZW1pdCQxKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFxuICBcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi9cbik7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gIGlmIChkZXZ0b29scyAmJiB0eXBlb2YgZGV2dG9vbHMuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcbiAgXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi9cbik7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXG4gIFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi9cbik7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbWl0c09wdGlvbnMsXG4gICAgICBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdXG4gICAgfSA9IGluc3RhbmNlO1xuICAgIGlmIChlbWl0c09wdGlvbnMpIHtcbiAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiYgdHJ1ZSkge1xuICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBhcmdzID0gcmF3QXJncztcbiAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aChcInVwZGF0ZTpcIik7XG4gIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xuICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcbiAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gXCJtb2RlbFZhbHVlXCIgPyBcIm1vZGVsXCIgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xuICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IEVNUFRZX09CSjtcbiAgICBpZiAodHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChsb29zZVRvTnVtYmVyKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbGV0IGhhbmRsZXJOYW1lO1xuICBsZXQgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KV0gfHwgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxuICBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpXTtcbiAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgIGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShoeXBoZW5hdGUoZXZlbnQpKV07XG4gIH1cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxuICBjb25zdCBvbmNlSGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lICsgYE9uY2VgXTtcbiAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XG4gICAgICBpbnN0YW5jZS5lbWl0dGVkID0ge307XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBvbmNlSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gIGlmIChjYWNoZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcyKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcyLCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xuICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcbiAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgIH1cbiAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xuICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgcmF3LmZvckVhY2goKGtleSkgPT4gbm9ybWFsaXplZFtrZXldID0gbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sIFwiXCIpO1xuICByZXR1cm4gaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fCBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8IGhhc093bihvcHRpb25zLCBrZXkpO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpXG4gICAgcmV0dXJuIGZuO1xuICBpZiAoZm4uX24pIHtcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHMsXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xuICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICBwcm94eVRvVXNlLFxuICAgICAgICAgIHByb3h5VG9Vc2UsXG4gICAgICAgICAgcmVuZGVyQ2FjaGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgc2V0dXBTdGF0ZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGN0eFxuICAgICAgICApXG4gICAgICApO1xuICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZW5kZXIyID0gQ29tcG9uZW50O1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXR0cnMgPT09IHByb3BzKSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShcbiAgICAgICAgcmVuZGVyMi5sZW5ndGggPiAxID8gcmVuZGVyMihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBlbWl0XG4gICAgICAgICAgfSA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH1cbiAgICAgICAgKSA6IHJlbmRlcjIoXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICAgIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzID8gYXR0cnMgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEpO1xuICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9XG4gIGxldCByb290ID0gcmVzdWx0O1xuICBsZXQgc2V0Um9vdCA9IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiYgcmVzdWx0LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICBbcm9vdCwgc2V0Um9vdF0gPSBnZXRDaGlsZFJvb3QocmVzdWx0KTtcbiAgfVxuICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIHwgNikpIHtcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMsXG4gICAgICAgICAgICBwcm9wc09wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QsIGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzICgke2V4dHJhQXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBFeHRyYW5lb3VzIG5vbi1lbWl0cyBldmVudCBsaXN0ZW5lcnMgKCR7ZXZlbnRBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCk7XG4gICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XG4gIH1cbiAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0Um9vdCkge1xuICAgIHNldFJvb3Qocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gcm9vdDtcbiAgfVxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XG4gIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcbiAgICAgIH0gZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50U3VzcGVuc2UoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hTdXNwZW5zZShcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxufTtcbmNvbnN0IFN1c3BlbnNlID0gU3VzcGVuc2VJbXBsIDtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgZXZlbnRMaXN0ZW5lcigpO1xuICB9XG59XG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgaXNTVkcsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkc1xuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25QZW5kaW5nXCIpO1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvbkZhbGxiYWNrXCIpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLnNzRmFsbGJhY2ssXG4gICAgICBjb250YWluZXIsXG4gICAgICBhbmNob3IsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgIGlzU1ZHLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmICFoYXNXYXJuZWQpIHtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICAgIGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbTogbW92ZSxcbiAgICB1bTogdW5tb3VudCxcbiAgICBuOiBuZXh0LFxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBsZXQgcGFyZW50U3VzcGVuc2VJZDtcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XG4gIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZUlkID0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkO1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcysrO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lb3V0ID0gdm5vZGUucHJvcHMgPyB0b051bWJlcih2bm9kZS5wcm9wcy50aW1lb3V0KSA6IHZvaWQgMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgfVxuICBjb25zdCBzdXNwZW5zZSA9IHtcbiAgICB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBpc1NWRyxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBkZXBzOiAwLFxuICAgIHBlbmRpbmdJZDogMCxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6IHRydWUsXG4gICAgaXNIeWRyYXRpbmcsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGVmZmVjdHM6IFtdLFxuICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UsIHN5bmMgPSBmYWxzZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IHZub2RlMixcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBwZW5kaW5nSWQsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXG4gICAgICB9ID0gc3VzcGVuc2U7XG4gICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gXCJvdXQtaW5cIjtcbiAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBhbmNob3I6IGFuY2hvcjIgfSA9IHN1c3BlbnNlO1xuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50Miwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yMiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIGlzU1ZHOiBpc1NWRzIgfSA9IHN1c3BlbnNlO1xuICAgICAgdHJpZ2dlckV2ZW50KHZub2RlMiwgXCJvbkZhbGxiYWNrXCIpO1xuICAgICAgY29uc3QgYW5jaG9yMiA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmFsbGJhY2tWTm9kZSxcbiAgICAgICAgICBjb250YWluZXIyLFxuICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgaXNTVkcyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIGlzU1ZHLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICAgIC8qIGh5ZHJhdGluZyAqL1xuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCkge1xuICAgICAgd2FybihgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBjb25zdCBlbCA9IHZub2RlLmVsID0gYnJhbmNoLmVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSB2bm9kZS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN1c3BlbnNpYmxlKSAhPSBudWxsICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwicG9zdFwiIH0pIDogeyBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gZG9XYXRjaChcbiAgICBlZmZlY3QsXG4gICAgbnVsbCxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGZsdXNoOiBcInN5bmNcIiB9KSA6IHsgZmx1c2g6IFwic3luY1wiIH1cbiAgKTtcbn1cbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuKFxuICAgICAgYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2gsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gRU1QVFlfT0JKKSB7XG4gIHZhciBfYTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWVwICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudFNjb3BlKCkgPT09ICgoX2EgPSBjdXJyZW50SW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY29wZSkgPyBjdXJyZW50SW5zdGFuY2UgOiBudWxsO1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xuICAgIGRlZXAgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyQxKHMpKTtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKChzKSA9PiB7XG4gICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAzLFxuICAgICAgICAgIFtvbkNsZWFudXBdXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgfVxuICBsZXQgY2xlYW51cDtcbiAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgIGNsZWFudXAgPSBlZmZlY3Qub25TdG9wID0gKCkgPT4ge1xuICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCk7XG4gICAgfTtcbiAgfTtcbiAgbGV0IHNzckNsZWFudXA7XG4gIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICBvbkNsZWFudXAgPSBOT09QO1xuICAgIGlmICghY2IpIHtcbiAgICAgIGdldHRlcigpO1xuICAgIH0gZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMsIFtcbiAgICAgICAgZ2V0dGVyKCksXG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHZvaWQgMCxcbiAgICAgICAgb25DbGVhbnVwXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE5PT1A7XG4gICAgfVxuICB9XG4gIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICBjb25zdCBqb2IgPSAoKSA9PiB7XG4gICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKFxuICAgICAgICAodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSlcbiAgICAgICkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8IGZhbHNlKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMywgW1xuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgIF0pO1xuICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcbiAgbGV0IHNjaGVkdWxlcjtcbiAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgIHNjaGVkdWxlciA9IGpvYjtcbiAgfSBlbHNlIGlmIChmbHVzaCA9PT0gXCJwb3N0XCIpIHtcbiAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gIH0gZWxzZSB7XG4gICAgam9iLnByZSA9IHRydWU7XG4gICAgaWYgKGluc3RhbmNlKVxuICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gIH1cbiAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICBqb2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgIGVmZmVjdC5ydW4uYmluZChlZmZlY3QpLFxuICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2VcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGVmZmVjdC5ydW4oKTtcbiAgfVxuICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnNjb3BlKSB7XG4gICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmIChzc3JDbGVhbnVwKVxuICAgIHNzckNsZWFudXAucHVzaCh1bndhdGNoKTtcbiAgcmV0dXJuIHVud2F0Y2g7XG59XG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSkgPyBzb3VyY2UuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gIGxldCBjYjtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgY2IgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XG4gICAgb3B0aW9ucyA9IHZhbHVlO1xuICB9XG4gIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICBjb25zdCByZXMgPSBkb1dhdGNoKGdldHRlciwgY2IuYmluZChwdWJsaWNUaGlzKSwgb3B0aW9ucyk7XG4gIGlmIChjdXIpIHtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcbiAgfSBlbHNlIHtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBjdXIgPSBjdHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4oXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0RXhwb3NlUHJveHkoaW50ZXJuYWxJbnN0YW5jZSkgfHwgaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgfSk7XG4gIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XG5jb25zdCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbW9kZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIHBlcnNpc3RlZDogQm9vbGVhbixcbiAgLy8gZW50ZXJcbiAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gbGVhdmVcbiAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgLy8gYXBwZWFyXG4gIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBsZXQgaGFzRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtb2RlICYmIG1vZGUgIT09IFwiaW4tb3V0XCIgJiYgbW9kZSAhPT0gXCJvdXQtaW5cIiAmJiBtb2RlICE9PSBcImRlZmF1bHRcIikge1xuICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XG4gICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgIGlubmVyQ2hpbGQsXG4gICAgICAgIHJhd1Byb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XG4gICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcbiAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcbiAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XG4gICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJiBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiYgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XG4gICAgICAgIGNvbnN0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIpIHtcbiAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UudXBkYXRlLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJpbi1vdXRcIiAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG9sZElubmVyQ2hpbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdm9pZCAwO1xuICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gIGNvbnN0IHsgbGVhdmluZ1ZOb2RlcyB9ID0gc3RhdGU7XG4gIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcbiAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBsZWF2aW5nVk5vZGVzQ2FjaGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKVxuICAgICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgICAgIGVsLl9sZWF2ZUNiKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcbiAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fZW50ZXJDYiA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBpZiAoaG9vaykge1xuICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgY29uc3Qga2V5MiA9IFN0cmluZyh2bm9kZS5rZXkpO1xuICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgICAgIGVsLl9lbnRlckNiKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkb25lID0gZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX2xlYXZlQ2IgPSB2b2lkIDA7XG4gICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5Ml0gPT09IHZub2RlKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9IHZub2RlO1xuICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lKHZub2RlMikge1xuICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUyLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKSA/IHZub2RlLmNoaWxkcmVuID8gdm5vZGUuY2hpbGRyZW5bMF0gOiB2b2lkIDAgOiB2bm9kZTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpXG4gICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucykge1xuICByZXR1cm4gaXNGdW5jdGlvbihvcHRpb25zKSA/IChcbiAgICAvLyAjODMyNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXh0ZW5kKHsgbmFtZTogb3B0aW9ucy5uYW1lIH0sIGV4dHJhT3B0aW9ucywgeyBzZXR1cDogb3B0aW9ucyB9KSkoKVxuICApIDogb3B0aW9ucztcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICB0aW1lb3V0LFxuICAgIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSxcbiAgICBvbkVycm9yOiB1c2VyT25FcnJvclxuICB9ID0gc291cmNlO1xuICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICBsZXQgcmVzb2x2ZWRDb21wO1xuICBsZXQgcmV0cmllcyA9IDA7XG4gIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgIHJldHJpZXMrKztcbiAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgcmV0dXJuIGxvYWQoKTtcbiAgfTtcbiAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0IHx8ICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KS50aGVuKChjb21wKSA9PiB7XG4gICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFjb21wKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICB9LFxuICAgIHNldHVwKCkge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGhhbmRsZUVycm9yKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhZXJyb3JDb21wb25lbnRcbiAgICAgICAgICAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgaWYgKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlIHx8IGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICByZXR1cm4gbG9hZCgpLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnQgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcbiAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgICBsb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xuICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICBjb25zdCB7IHJlZjogcmVmMiwgcHJvcHMsIGNoaWxkcmVuLCBjZSB9ID0gcGFyZW50LnZub2RlO1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gIHZub2RlLnJlZiA9IHJlZjI7XG4gIHZub2RlLmNlID0gY2U7XG4gIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxuICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gIF9faXNLZWVwQWxpdmU6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJlcjoge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgbTogbW92ZSxcbiAgICAgICAgdW06IF91bm1vdW50LFxuICAgICAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICAgICAgfVxuICAgIH0gPSBzaGFyZWRDb250ZXh0O1xuICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKCFjdXJyZW50IHx8ICFpc1NhbWVWTm9kZVR5cGUoY2FjaGVkLCBjdXJyZW50KSkge1xuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIGtleXMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIHdhdGNoKFxuICAgICAgKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLFxuICAgICAgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xuICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUoKG5hbWUpID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6IHRydWUgfVxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgaXNBc3luY1dyYXBwZXIodm5vZGUpID8gdm5vZGUudHlwZS5fX2FzeW5jUmVzb2x2ZWQgfHwge30gOiBjb21wXG4gICAgICApO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xuICAgICAgaWYgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSB8fCBleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkge1xuICAgICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAodm5vZGUuZWwpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBrZXk7XG4gICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcbiAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xuICAgICAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMjtcbiAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChtYXggJiYga2V5cy5zaXplID4gcGFyc2VJbnQobWF4LCAxMCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5cy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2O1xuICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdChcIixcIikuaW5jbHVkZXMobmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sIFwiXCIpKTtcbiAgICB3YXJuKFxuICAgICAgYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguIExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICsgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmAgKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUhvb2sgPSAobGlmZWN5Y2xlKSA9PiAoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiAoXG4gIC8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxuICAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikgJiYgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpXG4pO1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIik7XG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIik7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiKTtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIik7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXG4gIFwicnRnXCJcbik7XG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFxuICBcInJ0Y1wiXG4pO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBpbmplY3RIb29rKFwiZWNcIiwgaG9vaywgdGFyZ2V0KTtcbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9IFwiY29tcG9uZW50c1wiO1xuY29uc3QgRElSRUNUSVZFUyA9IFwiZGlyZWN0aXZlc1wiO1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChuYW1lLCBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sLmZvcihcInYtbmRjXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBjb21wb25lbnQsIGZhbHNlKSB8fCBjb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gQ09NUE9ORU5UUykge1xuICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGZhbHNlXG4gICAgICAgIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqL1xuICAgICAgKTtcbiAgICAgIGlmIChzZWxmTmFtZSAmJiAoc2VsZk5hbWUgPT09IG5hbWUgfHwgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8IHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fCAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXG4gICAgKTtcbiAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IGBgO1xuICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5ICYmIChyZWdpc3RyeVtuYW1lXSB8fCByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHwgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xuICBsZXQgcmV0O1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZSAmJiBjYWNoZVtpbmRleF07XG4gIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKVxuICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gOiBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIGZhbGxiYWNrLCBub1Nsb3R0ZWQpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSB7XG4gICAgaWYgKG5hbWUgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFwic2xvdFwiLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XG4gIH1cbiAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKFxuICAgIEZyYWdtZW50LFxuICAgIHtcbiAgICAgIGtleTogcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAgICAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gICAgICB2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5IHx8IGBfJHtuYW1lfWBcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkgPyB2bm9kZXMgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaiwgcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChvYmopKSB7XG4gICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSlcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXG4gICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkZW1pdDogKGkpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogKGkpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpKSA6IGkudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6IChpKSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgaWYgKGtleVswXSAhPT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgaWYgKG4gIT09IHZvaWQgMCkge1xuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgIGNhc2UgMiAvKiBEQVRBICovOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBTRVRVUCAqLztcbiAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgfSBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogT1RIRVIgKi87XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcbiAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiJGF0dHJzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4oYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gPT09IFwiJFwiICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyxcbiAge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKF8sIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcztcbiAgICB9XG4gIH1cbik7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXG4gICAgICAgIHNldDogTk9PUFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4oXG4gIGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gXG4pO1xuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUV4cG9zZWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVPcHRpb25zYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZmluZVNsb3RzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVNsb3RzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVNb2RlbCgpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKFwiZGVmaW5lTW9kZWxcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5mdW5jdGlvbiB1c2VNb2RlbChwcm9wcywgbmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpKSB7XG4gICAgd2FybihgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtuYW1lXSkge1xuICAgIHdhcm4oYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7bmFtZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubG9jYWwpIHtcbiAgICBjb25zdCBwcm94eSA9IHJlZihwcm9wc1tuYW1lXSk7XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBwcm9wc1tuYW1lXSxcbiAgICAgICh2KSA9PiBwcm94eS52YWx1ZSA9IHZcbiAgICApO1xuICAgIHdhdGNoKHByb3h5LCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gcHJvcHNbbmFtZV0pIHtcbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fdl9pc1JlZjogdHJ1ZSxcbiAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzW25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpLmVtaXQoYHVwZGF0ZToke25hbWV9YCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcbiAgICBpZiAob3B0KSB7XG4gICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKG9wdCAmJiBkZWZhdWx0c1tgX19za2lwXyR7a2V5fWBdKSB7XG4gICAgICBvcHQuc2tpcEZhY3RvcnkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZU1vZGVscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYilcbiAgICByZXR1cm4gYSB8fCBiO1xuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKVxuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybihcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgfVxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAodHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgfVxuICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XG4gIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgY2FsbEhvb2sob3B0aW9ucy5iZWZvcmVDcmVhdGUsIGluc3RhbmNlLCBcImJjXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsXG4gICAgbWV0aG9kcyxcbiAgICB3YXRjaDogd2F0Y2hPcHRpb25zLFxuICAgIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLFxuICAgIGluamVjdDogaW5qZWN0T3B0aW9ucyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLFxuICAgIGJlZm9yZU1vdW50LFxuICAgIG1vdW50ZWQsXG4gICAgYmVmb3JlVXBkYXRlLFxuICAgIHVwZGF0ZWQsXG4gICAgYWN0aXZhdGVkLFxuICAgIGRlYWN0aXZhdGVkLFxuICAgIGJlZm9yZURlc3Ryb3ksXG4gICAgYmVmb3JlVW5tb3VudCxcbiAgICBkZXN0cm95ZWQsXG4gICAgdW5tb3VudGVkLFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJUcmFja2VkLFxuICAgIHJlbmRlclRyaWdnZXJlZCxcbiAgICBlcnJvckNhcHR1cmVkLFxuICAgIHNlcnZlclByZWZldGNoLFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsXG4gICAgaW5oZXJpdEF0dHJzLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBmaWx0ZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XG4gIH1cbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xuICAgICAgaWYgKGlzRnVuY3Rpb24obWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmBcbiAgICAgICAgKTtcbiAgICAgIH0gOiBOT09QO1xuICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBjLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3ZpZGVzID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9ucykgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY3JlYXRlZCkge1xuICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGhvb2suZm9yRWFjaCgoX2hvb2spID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcbiAgICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICBpZiAoaXNBcnJheShleHBvc2UpKSB7XG4gICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xuICAgICAgZXhwb3NlLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XG4gICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgc2V0OiAodmFsKSA9PiBwdWJsaWNUaGlzW2tleV0gPSB2YWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cylcbiAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgaWYgKGRpcmVjdGl2ZXMpXG4gICAgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSkgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XG4gIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xuICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcbiAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XG4gIGNvbnN0IHtcbiAgICBtaXhpbnM6IGdsb2JhbE1peGlucyxcbiAgICBvcHRpb25zQ2FjaGU6IGNhY2hlLFxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxuICB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICBsZXQgcmVzb2x2ZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXNvbHZlZCA9IGNhY2hlZDtcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgIHtcbiAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWQgPSB7fTtcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xuICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2goXG4gICAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSlcbiAgICAgICk7XG4gICAgfVxuICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICB9XG4gIGlmIChtaXhpbnMpIHtcbiAgICBtaXhpbnMuZm9yRWFjaChcbiAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSlcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09IFwiZXhwb3NlXCIpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKVxuICAgIHJldHVybiBmcm9tO1xuICBpZiAoIWZyb20pXG4gICAgcmV0dXJuIHRvO1xuICBjb25zdCBtZXJnZWQgPSBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogTk8sXG4gICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgdWlkJDEgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcbiAgICAgIHJvb3RDb21wb25lbnQgPSBleHRlbmQoe30sIHJvb3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2Fybihgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICByb290UHJvcHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dC5jb25maWcsIFwidW53cmFwSW5qZWN0ZWRSZWZcIiwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYGFwcC5jb25maWcudW53cmFwSW5qZWN0ZWRSZWYgaGFzIGJlZW4gZGVwcmVjYXRlZC4gMy4zIG5vdyBhbGF3eXMgdW53cmFwcyBpbmplY3RlZCByZWZzIGluIE9wdGlvbnMgQVBJLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAmJiBpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoXG4gICAgICAgICAgICByb290Q29tcG9uZW50LFxuICAgICAgICAgICAgcm9vdFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihjbG9uZVZOb2RlKHZub2RlKSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY3VycmVudEFwcCA9IGFwcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50QXBwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcbn1cbmxldCBjdXJyZW50QXBwID0gbnVsbDtcblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XG4gIGlmICghY3VycmVudEluc3RhbmNlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGluc3RhbmNlIHx8IGN1cnJlbnRBcHApIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiBjdXJyZW50QXBwLl9jb250ZXh0LnByb3ZpZGVzO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSID0gZmFsc2UpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgYXR0cnMgPSB7fTtcbiAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3Qge1xuICAgIHByb3BzLFxuICAgIGF0dHJzLFxuICAgIHZub2RlOiB7IHBhdGNoRmxhZyB9XG4gIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiYgIShwYXRjaEZsYWcgJiAxNilcbiAgKSB7XG4gICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgICAgICAgIGNhbWVsaXplZEtleSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAvKiBpc0Fic2VudCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xuICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGtlYmFiS2V5O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgaWYgKCFyYXdQcm9wcyB8fCAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiYgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdm9pZCAwIHx8IC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdm9pZCAwKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIC8qIGlzQWJzZW50ICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmIHRydWUpIHtcbiAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcbiAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRhdHRyc1wiKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xuICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBsZXQgcmF3Q2FzdFZhbHVlcztcbiAgaWYgKHJhd1Byb3BzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCBjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSB7XG4gICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XG4gICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQ2FzdEtleXMpIHtcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICBrZXksXG4gICAgICAgIGNhc3RWYWx1ZXNba2V5XSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICFoYXNPd24oY2FzdFZhbHVlcywga2V5KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XG4gIGlmIChvcHQgIT0gbnVsbCkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XG4gICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmICFvcHQuc2tpcEZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xuICAgICAgaWYgKGlzQWJzZW50ICYmICFoYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdFsxIC8qIHNob3VsZENhc3RUcnVlICovXSAmJiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpXG4gICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID0gRU1QVFlfT0JKO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyYXcpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3QocmF3KSkge1xuICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xuICAgICAgICBjb25zdCBwcm9wID0gbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogZXh0ZW5kKHt9LCBvcHQpO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcbiAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xuICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gW25vcm1hbGl6ZWQsIG5lZWRDYXN0S2V5c107XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICBpZiAoa2V5WzBdICE9PSBcIiRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICBjb25zdCBtYXRjaCA9IGN0b3IgJiYgY3Rvci50b1N0cmluZygpLm1hdGNoKC9eXFxzKihmdW5jdGlvbnxjbGFzcykgKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzJdIDogY3RvciA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KCh0KSA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xuICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ID09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICB2YWxpZGF0ZVByb3AoXG4gICAgICBrZXksXG4gICAgICByZXNvbHZlZFZhbHVlc1trZXldLFxuICAgICAgb3B0LFxuICAgICAgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XG4gIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciwgc2tpcENoZWNrIH0gPSBwcm9wO1xuICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXJlcXVpcmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSAmJiAhc2tpcENoZWNrKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgXCJcIik7XG4gICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICB2YWxpZCA9IHZhbHVlID09PSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gIH0sIGN0eCk7XG4gIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xuICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuKFxuICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgaW5zdGFuY2Uuc2xvdHMuZGVmYXVsdCA9ICgpID0+IG5vcm1hbGl6ZWQ7XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB0b1JhdyhjaGlsZHJlbik7XG4gICAgICBkZWYoY2hpbGRyZW4sIFwiX1wiLCB0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbiAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xuICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5IDogdm5vZGUuZWw7XG4gIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xuICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW93bmVyKSB7XG4gICAgd2FybihcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcbiAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcbiAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIsIFt2YWx1ZSwgcmVmc10pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChyYXdSZWYuZikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gaGFzT3duKHNldHVwU3RhdGUsIHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSByZWZzW3JlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybihcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvU2V0LmlkID0gLTE7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuY29uc3QgaXNDb21tZW50ID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ09NTUVOVCAqLztcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gXG4gICAgICApO1xuICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKGhhc01pc21hdGNoICYmIHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xuICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgaW5zZXJ0KHZub2RlLmVsID0gY3JlYXRlVGV4dChcIlwiKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6XG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfVxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fCBkb21UeXBlID09PSAzIC8qIFRFWFQgKi8pIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVMRU1FTlQgKi8gPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0ID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpIDogbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzQ29tbWVudChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBlbmRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nIDogY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKFwiXCIpIDogY3JlYXRlVk5vZGUoXCJkaXZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICBoeWRyYXRlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHROb2RlO1xuICB9O1xuICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBjb25zdCBmb3JjZVBhdGNoVmFsdWUgPSB0eXBlID09PSBcImlucHV0XCIgJiYgZGlycyB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiY3JlYXRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8ICFvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnICYgKDE2IHwgMzIpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKFwidmFsdWVcIikgfHwgaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICBpZiAodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoZGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xuICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgdm5vZGVIb29rcyAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwibW91bnRlZFwiKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9Pjogc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XG4tIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cbi0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xuICB9O1xuICBjb25zdCBoeWRyYXRlQ2hpbGRyZW4gPSAobm9kZSwgcGFyZW50Vk5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRWTm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWQgPyBjaGlsZHJlbltpXSA6IGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gVGV4dCAmJiAhdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSBDbGllbnQgdm5vZGU6YCxcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBgXG4tIFNlcnZlciByZW5kZXJlZCBET006YCxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi8gPyBgKHRleHQpYCA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiID8gYChzdGFydCBvZiBmcmFnbWVudClgIDogYGBcbiAgICApO1xuICAgIHZub2RlLmVsID0gbnVsbDtcbiAgICBpZiAoaXNGcmFnbWVudCkge1xuICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dDIgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgaWYgKG5leHQyICYmIG5leHQyICE9PSBlbmQpIHtcbiAgICAgICAgICByZW1vdmUobmV4dDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIHJlbW92ZShub2RlKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5leHQsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHJldHVybiBuZXh0O1xuICB9O1xuICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBcIltcIilcbiAgICAgICAgICBtYXRjaCsrO1xuICAgICAgICBpZiAobm9kZS5kYXRhID09PSBcIl1cIikge1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XG59XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgIHBlcmYubWVhc3VyZShcbiAgICAgIGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLFxuICAgICAgc3RhcnRUYWcsXG4gICAgICBlbmRUYWdcbiAgICApO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2sodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIHRhcmdldCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGluc2VydDogaG9zdEluc2VydCxcbiAgICByZW1vdmU6IGhvc3RSZW1vdmUsXG4gICAgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LFxuICAgIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LFxuICAgIHNldFRleHQ6IGhvc3RTZXRUZXh0LFxuICAgIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsXG4gICAgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZyxcbiAgICBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpID0+IHtcbiAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgaXNTVkcsXG4gICAgICBuMi5lbCxcbiAgICAgIG4yLmFuY2hvclxuICAgICk7XG4gIH07XG4gIGNvbnN0IHBhdGNoU3RhdGljTm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgaXNTVkdcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBpc1NWRyA9IGlzU1ZHIHx8IG4yLnR5cGUgPT09IFwic3ZnXCI7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50RWxlbWVudChcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoRWxlbWVudChcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIGRpcnMgfSA9IHZub2RlO1xuICAgIGVsID0gdm5vZGUuZWwgPSBob3N0Q3JlYXRlRWxlbWVudChcbiAgICAgIHZub2RlLnR5cGUsXG4gICAgICBpc1NWRyxcbiAgICAgIHByb3BzICYmIHByb3BzLmlzLFxuICAgICAgcHJvcHNcbiAgICApO1xuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICB2bm9kZS5jaGlsZHJlbixcbiAgICAgICAgZWwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHICYmIHR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHByb3BzW2tleV0sXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIHByb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgbnVsbCwgcHJvcHMudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlSG9vayA9IHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkge1xuICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFwiX192bm9kZVwiLCB7XG4gICAgICAgIHZhbHVlOiB2bm9kZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHtcbiAgICAgICAgdmFsdWU6IHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZU1vdW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9ICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSkgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaEVsZW1lbnQgPSAobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGlmICh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG4gICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09IFwiZm9yZWlnbk9iamVjdFwiO1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGVsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBhcmVDaGlsZHJlblNWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICApO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgcGF0Y2hDaGlsZHJlbihcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgYXJlQ2hpbGRyZW5TVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAyKSB7XG4gICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJjbGFzc1wiLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCkge1xuICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwic3R5bGVcIiwgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgICAgICAgbjEuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEpIHtcbiAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICBwYXRjaFByb3BzKFxuICAgICAgICBlbCxcbiAgICAgICAgbjIsXG4gICAgICAgIG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcbiAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgb2xkVk5vZGUuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IHwgNjQpKSA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKSA6IChcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgZmFsbGJhY2tDb250YWluZXJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBvbGRWTm9kZSxcbiAgICAgICAgbmV3Vk5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICBob3N0UGF0Y2hQcm9wKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvbGRQcm9wc1trZXldLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcbiAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0ICE9PSBwcmV2ICYmIGtleSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcHJldixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwidmFsdWVcIiwgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gbjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoXCJcIik7XG4gICAgY29uc3QgZnJhZ21lbnRFbmRBbmNob3IgPSBuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgKGlzSG1yVXBkYXRpbmcgfHwgcGF0Y2hGbGFnICYgMjA0OCkpIHtcbiAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xuICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcykgOiBmcmFnbWVudFNsb3RTY29wZUlkcztcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgZnJhZ21lbnRFbmRBbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgJiYgZHluYW1pY0NoaWxkcmVuICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cbiAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICApKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xuICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcbiAgICAgIGluc3RhbmNlLmN0eC5yZW5kZXJlciA9IGludGVybmFscztcbiAgICB9XG4gICAge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgaWYgKCFpbml0aWFsVk5vZGUuZWwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgIGluc3RhbmNlLFxuICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBpc1NWRyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGludmFsaWRhdGVKb2IoaW5zdGFuY2UudXBkYXRlKTtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50VXBkYXRlRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBjb25zdCB7IGVsLCBwcm9wcyB9ID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xuICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcbiAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHlkcmF0ZU5vZGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxuICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXG4gICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxuICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cbiAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWR1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICBsZXQgb3JpZ2luTmV4dCA9IG5leHQ7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhidSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gbmV4dFRyZWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBwcmV2VHJlZSxcbiAgICAgICAgICBuZXh0VHJlZSxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XG4gICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWR1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlZmZlY3QgPSBpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoXG4gICAgICBjb21wb25lbnRVcGRhdGVGbixcbiAgICAgICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksXG4gICAgICBpbnN0YW5jZS5zY29wZVxuICAgICAgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSAoKSA9PiBlZmZlY3QucnVuKCk7XG4gICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgICAgdXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciA9IChpbnN0YW5jZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBuZXh0Vk5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgaW5zdGFuY2Uudm5vZGUgPSBuZXh0Vk5vZGU7XG4gICAgaW5zdGFuY2UubmV4dCA9IG51bGw7XG4gICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgIHVwZGF0ZVNsb3RzKGluc3RhbmNlLCBuZXh0Vk5vZGUuY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcbiAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcbiAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgaWYgKHBhdGNoRmxhZyAmIDEyOCkge1xuICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgYzEsXG4gICAgICAgICAgYzIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaXNTVkcsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgdW5tb3VudENoaWxkcmVuKFxuICAgICAgICBjMSxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgYzIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBpc1NWRyxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbZTJdID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGlzU1ZHLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxuICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uID0gbW92ZVR5cGUgIT09IDIgJiYgc2hhcGVGbGFnICYgMSAmJiB0cmFuc2l0aW9uO1xuICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xuICAgICAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcmVtb3ZlMiA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmUyKCk7XG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkaXJzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgJiYgZGlycztcbiAgICBjb25zdCBzaG91bGRJbnZva2VWbm9kZUhvb2sgPSAhaXNBc3luY1dyYXBwZXIodm5vZGUpO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZVVubW91bnQpKSB7XG4gICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImJlZm9yZVVubW91bnRcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRnJhZ21lbnQgJiYgcGF0Y2hGbGFnICYgKDEyOCB8IDI1NikgfHwgIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLnBhdGNoRmxhZyA+IDAgJiYgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGVuZCk7XG4gIH07XG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGJ1bSkge1xuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfVxuICAgIGlmICh1bSkge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgfVxuICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJiBpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJiBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gKHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gIH07XG4gIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcbiAgICB9XG4gICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICB9O1xuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcDogcGF0Y2gsXG4gICAgdW06IHVubW91bnQsXG4gICAgbTogbW92ZSxcbiAgICByOiByZW1vdmUsXG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIG1jOiBtb3VudENoaWxkcmVuLFxuICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgIG46IGdldE5leHRIb3N0Tm9kZSxcbiAgICBvOiBvcHRpb25zXG4gIH07XG4gIGxldCBoeWRyYXRlO1xuICBsZXQgaHlkcmF0ZU5vZGU7XG4gIGlmIChjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKFxuICAgICAgaW50ZXJuYWxzXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbmRlcixcbiAgICBoeWRyYXRlLFxuICAgIGNyZWF0ZUFwcDogY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIHVwZGF0ZSB9LCBhbGxvd2VkKSB7XG4gIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIpIHtcbiAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cpXG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgfVxuICAgICAgaWYgKGMyLnR5cGUgPT09IFRleHQpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGMyLnR5cGUgPT09IENvbW1lbnQgJiYgIWMyLmVsKSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xuICBjb25zdCByZXN1bHQgPSBbMF07XG4gIGxldCBpLCBqLCB1LCB2LCBjO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBhcnJJID0gYXJyW2ldO1xuICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgIHBbaV0gPSBqO1xuICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1ID0gMDtcbiAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICBjID0gdSArIHYgPj4gMTtcbiAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgIHUgPSBjICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xuICAgICAgICBpZiAodSA+IDApIHtcbiAgICAgICAgICBwW2ldID0gcmVzdWx0W3UgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1ID0gcmVzdWx0Lmxlbmd0aDtcbiAgdiA9IHJlc3VsdFt1IC0gMV07XG4gIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgcmVzdWx0W3VdID0gdjtcbiAgICB2ID0gcFt2XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09IFwiXCIpO1xuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldFNlbGVjdG9yICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICB9XG59O1xuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XG4gICAgfSA9IGludGVybmFscztcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBlbmRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3Rvcik7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xuICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgIHdhcm4oXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDpcIiwgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIyLCBhbmNob3IyKSA9PiB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgbW91bnQoY29udGFpbmVyLCBtYWluQW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xuICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY3VycmVudENvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50QW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpc1NWRyxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtYWluQW5jaG9yLFxuICAgICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgICAgICAgICBuMi5wcm9wcyxcbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XG4gICAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgICBuZXh0VGFyZ2V0LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTpcIixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBgKCR7dHlwZW9mIHRhcmdldH0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNzc1ZhcnMobjIpO1xuICB9LFxuICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcbiAgICB9XG4gICAgaWYgKGRvUmVtb3ZlIHx8ICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgdW5tb3VudChcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgISFjaGlsZC5keW5hbWljQ2hpbGRyZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH1cbn0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XG4gICAgICAgIHZub2RlLmFuY2hvciA9IGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnROb2RlKG5vZGUpLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiYgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4ICYmIHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB0YXJnZXQuX2xwYSA9IHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XG59XG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcbmZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcnModm5vZGUpIHtcbiAgY29uc3QgY3R4ID0gdm5vZGUuY3R4O1xuICBpZiAoY3R4ICYmIGN0eC51dCkge1xuICAgIGxldCBub2RlID0gdm5vZGUuY2hpbGRyZW5bMF0uZWw7XG4gICAgd2hpbGUgKG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sLmZvcihcInYtZmd0XCIpO1xuY29uc3QgVGV4dCA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSBTeW1ib2wuZm9yKFwidi1zdGNcIik7XG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICBibG9ja1N0YWNrLnB1c2goY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gIGJsb2NrU3RhY2sucG9wKCk7XG4gIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgICAgLyogaXNCbG9jayAqL1xuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqL1xuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG4yLnR5cGUpKSB7XG4gICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgbjIuc2hhcGVGbGFnICY9IH41MTI7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBuMS50eXBlID09PSBuMi50eXBlICYmIG4xLmtleSA9PT0gbjIua2V5O1xufVxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIF9jcmVhdGVWTm9kZShcbiAgICAuLi52bm9kZUFyZ3NUcmFuc2Zvcm1lciA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkgOiBhcmdzXG4gICk7XG59O1xuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7XG4gIHJlZixcbiAgcmVmX2tleSxcbiAgcmVmX2ZvclxufSkgPT4ge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlZiA9IFwiXCIgKyByZWY7XG4gIH1cbiAgcmV0dXJuIHJlZiAhPSBudWxsID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKSA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYsIGs6IHJlZl9rZXksIGY6ICEhcmVmX2ZvciB9IDogcmVmIDogbnVsbDtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEsIGlzQmxvY2tOb2RlID0gZmFsc2UsIG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uID0gZmFsc2UpIHtcbiAgY29uc3Qgdm5vZGUgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICBjaGlsZHJlbixcbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgc3VzcGVuc2U6IG51bGwsXG4gICAgc3NDb250ZW50OiBudWxsLFxuICAgIHNzRmFsbGJhY2s6IG51bGwsXG4gICAgZGlyczogbnVsbCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIGVsOiBudWxsLFxuICAgIGFuY2hvcjogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxuICAgIHN0YXRpY0NvdW50OiAwLFxuICAgIHNoYXBlRmxhZyxcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICBhcHBDb250ZXh0OiBudWxsLFxuICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gIH07XG4gIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIHZub2RlLnNoYXBlRmxhZyB8PSBpc1N0cmluZyhjaGlsZHJlbikgPyA4IDogMTY7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcbiAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XG4gIH1cbiAgaWYgKHByb3BzKSB7XG4gICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xuICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpID8gMSA6IGlzU3VzcGVuc2UodHlwZSkgPyAxMjggOiBpc1RlbGVwb3J0KHR5cGUpID8gNjQgOiBpc09iamVjdCh0eXBlKSA/IDQgOiBpc0Z1bmN0aW9uKHR5cGUpID8gMiA6IDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNoYXBlRmxhZyAmIDQgJiYgaXNQcm94eSh0eXBlKSkge1xuICAgIHR5cGUgPSB0b1Jhdyh0eXBlKTtcbiAgICB3YXJuKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLFxuICAgICAgYFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXG4gICAgICB0eXBlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBzaGFwZUZsYWcsXG4gICAgaXNCbG9ja05vZGUsXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wcyA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxuICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAvLyBub3RlOiBwcmVzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXG4gICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudCA/IHBhdGNoRmxhZyA9PT0gLTEgPyAxNiA6IHBhdGNoRmxhZyB8IDE2IDogcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wczogdm5vZGUuZHluYW1pY1Byb3BzLFxuICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgZGlyczogdm5vZGUuZGlycyxcbiAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxuICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgIC8vIHRoZXkgKnNob3VsZCogYmUgY29waWVkIGZvciBrZXB0LWFsaXZlIHZub2Rlcy4gU28gd2UganVzdCBhbHdheXMgY29weVxuICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgIGNvbXBvbmVudDogdm5vZGUuY29tcG9uZW50LFxuICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgc3NGYWxsYmFjazogdm5vZGUuc3NGYWxsYmFjayAmJiBjbG9uZVZOb2RlKHZub2RlLnNzRmFsbGJhY2spLFxuICAgIGVsOiB2bm9kZS5lbCxcbiAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICBjdHg6IHZub2RlLmN0eCxcbiAgICBjZTogdm5vZGUuY2VcbiAgfTtcbiAgcmV0dXJuIGNsb25lZDtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9IFwiIFwiLCBmbGFnID0gMCkge1xuICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgdGV4dCwgZmxhZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWTm9kZShjb250ZW50LCBudW1iZXJPZk5vZGVzKSB7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9IFwiXCIsIGFzQmxvY2sgPSBmYWxzZSkge1xuICByZXR1cm4gYXNCbG9jayA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xuICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXG4gICAgICBjaGlsZC5zbGljZSgpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICB9IGVsc2UgaWYgKHNsb3RGbGFnID09PSAzICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEpIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5fID0gMjtcbiAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XG4gICAgdHlwZSA9IDMyO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgIHR5cGUgPSAxNjtcbiAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gODtcbiAgICB9XG4gIH1cbiAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XG4gICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgZXhpc3RpbmcgIT09IGluY29taW5nICYmICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKSA6IGluY29taW5nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gXCJcIikge1xuICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDcsIFtcbiAgICB2bm9kZSxcbiAgICBwcmV2Vk5vZGVcbiAgXSk7XG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcbiAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHVpZDogdWlkKyssXG4gICAgdm5vZGUsXG4gICAgdHlwZSxcbiAgICBwYXJlbnQsXG4gICAgYXBwQ29udGV4dCxcbiAgICByb290OiBudWxsLFxuICAgIC8vIHRvIGJlIGltbWVkaWF0ZWx5IHNldFxuICAgIG5leHQ6IG51bGwsXG4gICAgc3ViVHJlZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgZWZmZWN0OiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCBzeW5jaHJvbm91c2x5IHJpZ2h0IGFmdGVyIGNyZWF0aW9uXG4gICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZShcbiAgICAgIHRydWVcbiAgICAgIC8qIGRldGFjaGVkICovXG4gICAgKSxcbiAgICByZW5kZXI6IG51bGwsXG4gICAgcHJveHk6IG51bGwsXG4gICAgZXhwb3NlZDogbnVsbCxcbiAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIGF0dHJzUHJveHk6IG51bGwsXG4gICAgc2xvdHNQcm94eTogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2UsXG4gICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgIGFzeW5jRGVwOiBudWxsLFxuICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXG4gICAgYmM6IG51bGwsXG4gICAgYzogbnVsbCxcbiAgICBibTogbnVsbCxcbiAgICBtOiBudWxsLFxuICAgIGJ1OiBudWxsLFxuICAgIHU6IG51bGwsXG4gICAgdW06IG51bGwsXG4gICAgYnVtOiBudWxsLFxuICAgIGRhOiBudWxsLFxuICAgIGE6IG51bGwsXG4gICAgcnRnOiBudWxsLFxuICAgIHJ0YzogbnVsbCxcbiAgICBlYzogbnVsbCxcbiAgICBzcDogbnVsbFxuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgfVxuICBpbnN0YW5jZS5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gIGlmICh2bm9kZS5jZSkge1xuICAgIHZub2RlLmNlKGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5sZXQgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2U7XG5sZXQgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycztcbmxldCBzZXR0ZXJzS2V5ID0gXCJfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19cIjtcbntcbiAgaWYgKCEoZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycyA9IGdldEdsb2JhbFRoaXMoKVtzZXR0ZXJzS2V5XSkpIHtcbiAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzID0gZ2V0R2xvYmFsVGhpcygpW3NldHRlcnNLZXldID0gW107XG4gIH1cbiAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycy5wdXNoKChpKSA9PiBjdXJyZW50SW5zdGFuY2UgPSBpKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVycy5sZW5ndGggPiAxKSB7XG4gICAgICBnbG9iYWxDdXJyZW50SW5zdGFuY2VTZXR0ZXJzLmZvckVhY2goKHMpID0+IHMoaW5zdGFuY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsQ3VycmVudEluc3RhbmNlU2V0dGVyc1swXShpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xufVxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UobnVsbCk7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJzbG90LGNvbXBvbmVudFwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb25maWcpIHtcbiAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcbiAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWwgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikgOiB2b2lkIDA7XG4gIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuICByZXR1cm4gc2V0dXBSZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xuICB2YXIgX2E7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dCA9IGluc3RhbmNlLnNldHVwQ29udGV4dCA9IHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbDtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgWyEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsIHNldHVwQ29udGV4dF1cbiAgICApO1xuICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpc1Byb21pc2Uoc2V0dXBSZXN1bHQpKSB7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIEEgY29tcG9uZW50IHdpdGggYXN5bmMgc2V0dXAoKSBtdXN0IGJlIG5lc3RlZCBpbiBhIDxTdXNwZW5zZT4gaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgfVxuICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXR1cFJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgd2FybihcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoXG4gICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgIGNvbXBvbmVudENvbXBpbGVyT3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UucmVuZGVyID0gQ29tcG9uZW50LnJlbmRlciB8fCBOT09QO1xuICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XG4gICAgICBpbnN0YWxsV2l0aFByb3h5KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgdHJ1ZSkge1xuICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgcGF1c2VUcmFja2luZygpO1xuICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICAgICAvKiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuYXR0cnNQcm94eSB8fCAoaW5zdGFuY2UuYXR0cnNQcm94eSA9IG5ldyBQcm94eShcbiAgICBpbnN0YW5jZS5hdHRycyxcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRhdHRyc1wiKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIFwiJGF0dHJzXCIpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICApKTtcbn1cbmZ1bmN0aW9uIGdldFNsb3RzUHJveHkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLnNsb3RzUHJveHkgfHwgKGluc3RhbmNlLnNsb3RzUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCBleHBvc2UgPSAoZXhwb3NlZCkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGV4cG9zZWRUeXBlID0gdHlwZW9mIGV4cG9zZWQ7XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVmKGV4cG9zZWQpKSB7XG4gICAgICAgICAgICBleHBvc2VkVHlwZSA9IFwicmVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvc2VkVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cnNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2xvdHNQcm94eShpbnN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyc1Byb3h5KGluc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csIFwiXCIpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGluY2x1ZGVJbmZlcnJlZCA9IHRydWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KSA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSA6IENvbXBvbmVudC5uYW1lIHx8IGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xuICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbmFtZSA9IGluZmVyRnJvbVJlZ2lzdHJ5KFxuICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyB8fCBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG59O1xuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChsID09PSAyKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobCA+IDMpIHtcbiAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB9IGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcbiAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oXG4gICAgICAgIGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMGIxYmM5XCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNiNjJlMjRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiM5ZDI4OGNcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgaGVhZGVyKG9iaikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXCJkaXZcIiwgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjMuNFwiO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGVcbn07XG5jb25zdCBzc3JVdGlscyA9IF9zc3JVdGlscyA7XG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmNvbnN0IGNvbXBhdFV0aWxzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VNb2RlbHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2VydmVyUHJlZmV0Y2gsIG9uVW5tb3VudGVkLCBvblVwZGF0ZWQsIG9wZW5CbG9jaywgcG9wU2NvcGVJZCwgcHJvdmlkZSwgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgc2V0QmxvY2tUcmFja2luZywgc2V0RGV2dG9vbHNIb29rLCBzZXRUcmFuc2l0aW9uSG9va3MsIHNzckNvbnRleHRLZXksIHNzclV0aWxzLCB0b0hhbmRsZXJzLCB0cmFuc2Zvcm1WTm9kZUFyZ3MsIHVzZUF0dHJzLCB1c2VNb2RlbCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCAiaW1wb3J0IHsgd2FybiwgY2FtZWxpemUsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCBjcmVhdGVWTm9kZSwgZ2V0Q3VycmVudEluc3RhbmNlLCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgYXNzZXJ0TnVtYmVyLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIHRvTnVtYmVyLCBleHRlbmQsIEVNUFRZX09CSiwgaXNPYmplY3QsIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qIEBfX1BVUkVfXyAqLyBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuY29uc3Qgbm9kZU9wcyA9IHtcbiAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6IChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0YWcsIGlzU1ZHLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IGlzU1ZHID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgaXMgPyB7IGlzIH0gOiB2b2lkIDApO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRywgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbihcIiBcIik7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgIGlmIChwcmV2ICYmICFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXJyZW50RGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKGlzQ3NzU3RyaW5nKSB7XG4gICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgICBpZiAoXCJfdm9kXCIgaW4gZWwpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKCh2KSA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzQm9vbGVhbiA/IFwiXCIgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcbiAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbFtrZXldID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcbiAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBtO1xuICAgIHdoaWxlIChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSBcIjpcIiA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gIHJldHVybiBbZXZlbnQsIG9wdGlvbnNdO1xufVxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4oKCkgPT4gY2FjaGVkTm93ID0gMCksIGNhY2hlZE5vdyA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xuICAgIGlmICghZS5fdnRzKSB7XG4gICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZS5fdnRzIDw9IGludm9rZXIuYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNSxcbiAgICAgIFtlXVxuICAgICk7XG4gIH07XG4gIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgcmV0dXJuIGludm9rZXI7XG59XG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWUubWFwKChmbikgPT4gKGUyKSA9PiAhZTIuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZTIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcbiAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleVswXSA9PT0gXCIuXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCB0cnVlKSA6IGtleVswXSA9PT0gXCJeXCIgPyAoa2V5ID0ga2V5LnNsaWNlKDEpLCBmYWxzZSkgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICBwYXRjaERPTVByb3AoXG4gICAgICBlbCxcbiAgICAgIGtleSxcbiAgICAgIG5leHRWYWx1ZSxcbiAgICAgIHByZXZDaGlsZHJlbixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgdW5tb3VudENoaWxkcmVuXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5ID09PSBcInRydWUtdmFsdWVcIikge1xuICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJmYWxzZS12YWx1ZVwiKSB7XG4gICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xuICBpZiAoaXNTVkcpIHtcbiAgICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInNwZWxsY2hlY2tcIiB8fCBrZXkgPT09IFwiZHJhZ2dhYmxlXCIgfHwga2V5ID09PSBcInRyYW5zbGF0ZVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZm9ybVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwibGlzdFwiICYmIGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUyKSB7XG4gIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgaHlkcmF0ZTIpO1xuICAgIH1cbiAgfVxuICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XG4gIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IChvcHRpb25zKSA9PiB7XG4gIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xufTtcbmNvbnN0IEJhc2VDbGFzcyA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIFZ1ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgaHlkcmF0ZTIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RlZiA9IF9kZWY7XG4gICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaHlkcmF0ZTIpIHtcbiAgICAgIGh5ZHJhdGUyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHModGhpcy5fZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICBhc3luY0RlZigpLnRoZW4oKGRlZikgPT4gcmVzb2x2ZShkZWYsIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfcmVzb2x2ZVByb3BzKGRlZikge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IE9iamVjdC5rZXlzKHByb3BzIHx8IHt9KTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgZGVjbGFyZWRQcm9wS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbGl6ZSQxKGtleSk7XG4gICAgaWYgKHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCB2YWwgKyBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gIH1cbiAgX2NyZWF0ZVZOb2RlKCkge1xuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoe30sIHRoaXMuX3Byb3BzKSk7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdm5vZGUuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSAobmV3U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQocykpO1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgICAgIGRldGFpbDogYXJnc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSB7XG4gICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgc3R5bGVzLmZvckVhY2goKGNzcykgPT4ge1xuICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzLnRleHRDb250ZW50ID0gY3NzO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSBcIiRzdHlsZVwiKSB7XG4gIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcbiAgICAgIHJldHVybiBFTVBUWV9PQko7XG4gICAgfVxuICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgaWYgKCFtb2QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICByZXR1cm4gbW9kO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSBpbnN0YW5jZS51dCA9ICh2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KSkgPT4ge1xuICAgIEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYClcbiAgICApLmZvckVhY2goKG5vZGUpID0+IHNldFZhcnNPbk5vZGUobm9kZSwgdmFycykpO1xuICB9O1xuICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgfTtcbiAgd2F0Y2hQb3N0RWZmZWN0KHNldFZhcnMpO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHZub2RlLmVsKSB7XG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuY29uc3QgQU5JTUFUSU9OID0gXCJhbmltYXRpb25cIjtcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBjc3M6IHtcbiAgICB0eXBlOiBCb29sZWFuLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSBUcmFuc2l0aW9uLnByb3BzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICB9LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xuICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgcmV0dXJuIFtuLCBuXTtcbiAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHJlcywgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIChlbC5fdnRjIHx8IChlbC5fdnRjID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkpLmFkZChjbHMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgY29uc3QgeyBfdnRjIH0gPSBlbDtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbC5fdnRjID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICB9XG4gIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArIFwiZW5kXCI7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG4gICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfUR1cmF0aW9uYCk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZSA/IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aCA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGggOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcbiAgbmFtZTogXCJUcmFuc2l0aW9uR3JvdXBcIixcbiAgcHJvcHM6IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9KSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICBsZXQgcHJldkNoaWxkcmVuO1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8IFwidlwifS1tb3ZlYDtcbiAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKFxuICAgICAgICBwcmV2Q2hpbGRyZW5bMF0uZWwsXG4gICAgICAgIGluc3RhbmNlLnZub2RlLmVsLFxuICAgICAgICBtb3ZlQ2xhc3NcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIlwiO1xuICAgICAgICBjb25zdCBjYiA9IGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcbiAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IHJlbW92ZU1vZGUgPSAocHJvcHMpID0+IGRlbGV0ZSBwcm9wcy5tb2RlO1xuLyogQF9fUFVSRV9fICovIHJlbW92ZU1vZGUoVHJhbnNpdGlvbkdyb3VwSW1wbC5wcm9wcyk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICBjb25zdCBlbCA9IGMuZWw7XG4gIGlmIChlbC5fbW92ZUNiKSB7XG4gICAgZWwuX21vdmVDYigpO1xuICB9XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcbiAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gXCIwc1wiO1xuICAgIHJldHVybiBjO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xuICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICBpZiAoZWwuX3Z0Yykge1xuICAgIGVsLl92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09IFwibnVtYmVyXCI7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgZG9tVmFsdWUgPSBlbC52YWx1ZTtcbiAgICAgIGlmICh0cmltKSB7XG4gICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICBkb21WYWx1ZSA9IGxvb3NlVG9OdW1iZXIoZG9tVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsYXp5KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25lbmRcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCAmJiBlbC50eXBlICE9PSBcInJhbmdlXCIpIHtcbiAgICAgIGlmIChsYXp5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgbG9vc2VUb051bWJlcihlbC52YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcbiAgICAgICAgKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobylcbiAgICAgICk7XG4gICAgICBlbC5fYXNzaWduKFxuICAgICAgICBlbC5tdWx0aXBsZSA/IGlzU2V0TW9kZWwgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKSA6IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xuICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gIH07XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgaWYgKG1vZGlmaWVycy5zb21lKChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fdm9kIDogXCJub25lXCI7XG59XG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XG4gIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb24gPyByZW5kZXJlciA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn07XG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmICghY29udGFpbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhcHA7XG59O1xuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzTmF0aXZlVGFnXCIsIHtcbiAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzQ3VzdG9tRWxlbWVudFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxuLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiY29tcGlsZXJPcHRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyLm1vZGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICB3YXJuKFxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gIH1cbn0gO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsICJpbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAge1xuICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgfVxufVxuXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlID0gKCkgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4oXG4gICAgICBgUnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgKyAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gIClcbiAgICAgIC8qIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgY29tcGlsZSB9O1xuIiwgImltcG9ydCB7IGRlZmluZUNvbXBvbmVudCBhcyBfZGVmaW5lQ29tcG9uZW50IH0gZnJvbSAndnVlJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICdzcmMvbWFpbic7XG5pbXBvcnQgeyBDb21wdXRlZFJlZiwgY29tcHV0ZWQsIGdldEN1cnJlbnRJbnN0YW5jZSwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgcmVhY3RpdmUsIHJlZiwgd2F0Y2gsIHdhdGNoRWZmZWN0IH0gZnJvbSAndnVlJztcbmltcG9ydCB7IE15VmlldyB9IGZyb20gJy4vdmlldyc7XG5pbXBvcnQgeyBNYXJrZG93blZpZXcsIGRlYm91bmNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuZXhwb3J0IGRlZmF1bHQgLyojX19QVVJFX18qL19kZWZpbmVDb21wb25lbnQoe1xuICBfX25hbWU6ICdBcHAnLFxuICBzZXR1cChfX3Byb3BzLCB7XG4gICAgZXhwb3NlOiBfX2V4cG9zZVxuICB9KSB7XG4gICAgX19leHBvc2UoKTtcbiAgICBsZXQgY29tcG9tZW50U2VsZiA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGxldCBwbHVnaW4gPSAoY29tcG9tZW50U2VsZi5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLnBsdWdpbiBhcyBNeVBsdWdpbik7XG4gICAgbGV0IGNvbnRhaW5lciA9IChjb21wb21lbnRTZWxmLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuY29udGFpbmVyIGFzIEhUTUxFbGVtZW50KTtcbiAgICAvLyBsZXQgZmluZENvbW1lbnQgOiBOb2RlTGlzdE9mPEVsZW1lbnQ+XG5cbiAgICBsZXQgZmluZENvbW1lbnQgPSByZWYoKTtcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGVzLXVwZGF0ZVwiLCByZXNldCk7XG5cbiAgICAgIC8vIHBsdWdpbi5hcHAud29ya3NwYWNlLm9uKFwiYWN0aXZlLWxlYWYtY2hhbmdlXCIsIHJlc2V0KTtcbiAgICB9KTtcblxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub3Rlcy11cGRhdGVcIiwgcmVzZXQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY29uc3QgdmlldyA9IHBsdWdpbi5jdXJyZW50X25vdGU7XG4gICAgICBjb25zdCBFeHAgPSBSZWdFeHAoXCIoaWQ9J2NvbW1lbnQtaWQtLionPikoW1xcXFxzXFxcXFNdKj8pKDwvc3Bhbj4pXCIsIFwiZ1wiKTtcbiAgICAgIGZpbmRDb21tZW50LnZhbHVlID0gdmlldy5nZXRWaWV3RGF0YSgpLm1hdGNoKEV4cCk7XG5cbiAgICAgIC8vIGNvbnN0IHRlc3QgPSB2aWV3LmdldFZpZXdEYXRhKCkubWF0Y2goRXhwKVxuXG4gICAgICAvLyB0ZXN0LmZvckVhY2goKGl0ZW0pPT57XG5cbiAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIml0ZW06XCIsaXRlbSk7XG4gICAgICAvLyB9KVxuICAgIH1cblxuICAgIGNvbnN0IF9fcmV0dXJuZWRfXyA9IHtcbiAgICAgIGdldCBjb21wb21lbnRTZWxmKCkge1xuICAgICAgICByZXR1cm4gY29tcG9tZW50U2VsZjtcbiAgICAgIH0sXG4gICAgICBzZXQgY29tcG9tZW50U2VsZih2KSB7XG4gICAgICAgIGNvbXBvbWVudFNlbGYgPSB2O1xuICAgICAgfSxcbiAgICAgIGdldCBwbHVnaW4oKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgICB9LFxuICAgICAgc2V0IHBsdWdpbih2KSB7XG4gICAgICAgIHBsdWdpbiA9IHY7XG4gICAgICB9LFxuICAgICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH0sXG4gICAgICBzZXQgY29udGFpbmVyKHYpIHtcbiAgICAgICAgY29udGFpbmVyID0gdjtcbiAgICAgIH0sXG4gICAgICBnZXQgZmluZENvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudDtcbiAgICAgIH0sXG4gICAgICBzZXQgZmluZENvbW1lbnQodikge1xuICAgICAgICBmaW5kQ29tbWVudCA9IHY7XG4gICAgICB9LFxuICAgICAgcmVzZXRcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3JldHVybmVkX18sICdfX2lzU2NyaXB0U2V0dXAnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIF9fcmV0dXJuZWRfXztcbiAgfVxufSk7IiwgImltcG9ydCB7IHJlbmRlckxpc3QgYXMgX3JlbmRlckxpc3QsIEZyYWdtZW50IGFzIF9GcmFnbWVudCwgb3BlbkJsb2NrIGFzIF9vcGVuQmxvY2ssIGNyZWF0ZUVsZW1lbnRCbG9jayBhcyBfY3JlYXRlRWxlbWVudEJsb2NrLCB0b0Rpc3BsYXlTdHJpbmcgYXMgX3RvRGlzcGxheVN0cmluZyB9IGZyb20gXCJ2dWVcIlxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKF9jdHgsIF9jYWNoZSwgJHByb3BzLCAkc2V0dXAsICRkYXRhLCAkb3B0aW9ucykge1xuICByZXR1cm4gKF9vcGVuQmxvY2sodHJ1ZSksIF9jcmVhdGVFbGVtZW50QmxvY2soX0ZyYWdtZW50LCBudWxsLCBfcmVuZGVyTGlzdCgkc2V0dXAuZmluZENvbW1lbnQsIChpdGVtKSA9PiB7XG4gICAgcmV0dXJuIChfb3BlbkJsb2NrKCksIF9jcmVhdGVFbGVtZW50QmxvY2soXCJkaXZcIiwgbnVsbCwgX3RvRGlzcGxheVN0cmluZyhpdGVtLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpKSwgMSAvKiBURVhUICovKSlcbiAgfSksIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSlcbn0iLCAiaW1wb3J0IHNjcmlwdCBmcm9tIFwiRTpcXFxcdGVzdFxcXFwub2JzaWRpYW5cXFxccGx1Z2luc1xcXFxvYnNpZGlhbi1jb2RlbWlycm9yLXRlc3RcXFxcc3JjXFxcXFZpZXdcXFxcQXBwLnZ1ZT90eXBlPXNjcmlwdFwiO2ltcG9ydCBcIkU6XFxcXHRlc3RcXFxcLm9ic2lkaWFuXFxcXHBsdWdpbnNcXFxcb2JzaWRpYW4tY29kZW1pcnJvci10ZXN0XFxcXHNyY1xcXFxWaWV3XFxcXEFwcC52dWU/dHlwZT1zdHlsZSZpbmRleD0wXCI7aW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIkU6XFxcXHRlc3RcXFxcLm9ic2lkaWFuXFxcXHBsdWdpbnNcXFxcb2JzaWRpYW4tY29kZW1pcnJvci10ZXN0XFxcXHNyY1xcXFxWaWV3XFxcXEFwcC52dWU/dHlwZT10ZW1wbGF0ZVwiOyBzY3JpcHQucmVuZGVyID0gcmVuZGVyO3NjcmlwdC5fX2ZpbGUgPSBcInNyY1xcXFxWaWV3XFxcXEFwcC52dWVcIjtzY3JpcHQuX19zY29wZUlkID0gXCJkYXRhLXYtMTFmZjU2MTJcIjtleHBvcnQgZGVmYXVsdCBzY3JpcHQ7Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBUU87OztBQ1JQLHNCQUF1RDtBQU1oRCxJQUFNLGVBQU4sY0FBMkIsc0JBQU07QUFBQSxFQUl0QyxZQUFZLEtBQVUsVUFBb0M7QUFDeEQsVUFBTSxHQUFHO0FBQ1QsU0FBSyxXQUFXO0FBQUEsRUFDbEI7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLEVBQUUsVUFBVSxJQUFJO0FBRXRCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSx1Q0FBUyxDQUFDO0FBRTNDLFVBQU0seUJBQXlCLElBQUksd0JBQVEsU0FBUztBQUVwRCxVQUFNLHlCQUF5QixJQUFJLGtDQUFrQix1QkFBdUIsU0FBUztBQUVyRiwyQkFBdUIsVUFBVSxhQUFhLFNBQVMsNENBQTRDO0FBRW5HLDJCQUF1QixRQUFRLGFBQWEsU0FBUyw2QkFBNkI7QUFFbEYsMkJBQXVCLFNBQVMsQ0FBTyxVQUFVO0FBRy9DLFdBQUssU0FBUyxNQUFNLFFBQVEsT0FBTyxNQUFNO0FBQUEsSUFHM0MsRUFBQztBQVFELFFBQUksd0JBQVEsU0FBUyxFQUNsQixVQUFVLENBQUMsUUFDVixJQUNHLGNBQWMsY0FBSSxFQUNsQixPQUFPLEVBQ1AsUUFBUSxNQUFNO0FBQ2IsV0FBSyxNQUFNO0FBQ1gsV0FBSyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzNCLENBQUMsQ0FBQztBQUFBLEVBQ1Y7QUFBQSxFQUVBLFVBQVU7QUFDUixRQUFJLEVBQUUsVUFBVSxJQUFJO0FBQ3BCLGNBQVUsTUFBTTtBQUFBLEVBQ2xCO0FBQ0Y7OztBQ3pEQSxrQkFLTztBQUNQLElBQUFDLG1CQUEwRDtBQUkxRCxJQUFNLFFBQVE7QUFFZCxJQUFNLGVBQWUsQ0FBQyxLQUFTLFdBQXFCO0FBQ2hELFFBQU0sUUFBUSxNQUFNLElBQUksVUFBVSxpQkFBaUIsVUFBVSxLQUFJLE1BQU0sQ0FBQztBQUV4RSxNQUFJLFVBQVUsY0FBYyxLQUFLO0FBQ2pDLE1BQUksVUFBVSxHQUFHLGlCQUFpQixLQUFLO0FBQzNDO0FBR0EsSUFBTSxZQUFZLENBQUMsS0FBUyxXQUFxQixDQUFDLFNBQXdCO0FBQ3RFLE1BQ0ksS0FBSyxnQkFBZ0IsaUNBQ3JCLEtBQUssS0FBSyxZQUFZO0FBQUEsSUFDbEIsNkJBQTZCO0FBQUEsRUFDakMsTUFBTSxNQUNSO0FBQ0UsUUFBSSxPQUFPLEtBQUs7QUFDaEIsUUFBSSxTQUFTO0FBQ2IsVUFBTSxnQkFBZ0IsS0FBSyxVQUFVLFlBQVksT0FBTyxDQUFDLFFBQVE7QUFLN0QsWUFBTSxlQUFlLEtBQUssVUFBVSxjQUFjLGdCQUFnQjtBQUVsRSxVQUFJLFFBQVE7QUFDUixpQkFBUztBQUNULHFCQUFhLGFBQWEsU0FBUyxlQUFlO0FBQ2xELHFCQUFhLGFBQWEsU0FBUyxvQkFBb0IsT0FBTyxTQUFTLG1DQUFtQyxPQUFPLFNBQVMsNEJBQTRCO0FBQ3RKLHNDQUFRLGVBQWUsVUFBVTtBQUFBLE1BQ3JDLE9BQU87QUFDSCxpQkFBUztBQUNULHFCQUFhLGFBQWEsU0FBUyxjQUFjO0FBQ2pELHNDQUFRLGVBQWUsZ0JBQWdCO0FBQUEsTUFFM0M7QUFBQSxJQU1KLENBQUM7QUFBQSxFQUNMO0FBQ0o7QUFFZSxTQUFSLGtCQUFtQyxLQUFTLFFBQWtCO0FBR2pFLFNBQU8sdUJBQVc7QUFBQSxJQUNkLE1BQU0sY0FBcUM7QUFBQSxNQU92QyxZQUFZLE1BQWtCO0FBQzFCLGFBQUssZUFBZSxLQUFLO0FBQ3pCLGFBQUssTUFBTSxTQUFTLGNBQWMsS0FBSztBQUN2QyxhQUFLLElBQUksWUFBWTtBQUNyQixhQUFLLElBQUksYUFBYSxTQUFTLG9CQUFvQixPQUFPLFNBQVMsbUNBQW1DLE9BQU8sU0FBUyw0QkFBNEI7QUFDbEosYUFBSyxJQUFJLGFBQWEsTUFBTSxlQUFlO0FBQzNDLGFBQUssSUFBSSxNQUFNLFlBQVksS0FBSyxnQkFBZ0I7QUFDaEQsYUFBSyxVQUFVLFlBQVksS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXO0FBQ2hFLHFCQUFhLEtBQUksTUFBTTtBQUFBLE1BQzNCO0FBQUEsTUFHQSxXQUFXLE1BQWtCO0FBQ3pCLGNBQU0sY0FBYyxLQUFLLElBQUksY0FBYyxnQkFBZ0I7QUFDM0QsWUFBSSxhQUFhO0FBQ2Isc0JBQVksTUFBTTtBQUNsQixnQkFBTSxjQUFjLEtBQUssV0FBVyxpQkFBaUIsVUFBVTtBQUMvRCxjQUFJLFlBQVksV0FBVyxHQUFHO0FBQzFCLGtCQUFNLFlBQVksS0FBSyxXQUFXLGlCQUFpQixVQUFVO0FBQzdELHNCQUFVLFFBQVEsU0FBTztBQUNyQixrQkFBSSxZQUFZLElBQUksYUFBYSxPQUFPO0FBQ3hDLGtCQUFJLFdBQVc7QUFDWCxvQkFBSSxVQUFVLFNBQVMsU0FBUyxHQUFHO0FBQy9CLHNCQUFJLGdCQUFnQixPQUFPO0FBQUEsZ0JBQy9CO0FBQUM7QUFBQSxjQUNMO0FBQUEsWUFDSixDQUFDO0FBQUEsVUFFTDtBQUdBLHNCQUFZLFFBQVEsYUFBVztBQUMzQixnQkFBSSxTQUFTO0FBRVQsb0JBQU0sV0FBVyxTQUFTLGNBQWMsS0FBSztBQUM3Qyx1QkFBUyxNQUFNLE1BQU0sUUFBUSxjQUFjLGNBQWMsY0FBYyxZQUFZO0FBQ25GLHVCQUFTLFNBQVMsZUFBZTtBQUNqQyx1QkFBUyxZQUFZLFFBQVE7QUFDN0IsMEJBQVksT0FBTyxRQUFRO0FBRTNCLHVCQUFTLFVBQVUsQ0FBQyxNQUFNO0FBQ3RCLHlCQUFTLGFBQWEsbUJBQW1CLGdCQUFnQjtBQUN6RCx5QkFBUyxNQUFNLFNBQVM7QUFDeEIseUJBQVMsTUFBTSxTQUFTO0FBQUEsY0FDNUI7QUFFQSx1QkFBUyxTQUFTLENBQUMsTUFBTTtBQUNyQixzQkFBTSxPQUFPLEtBQUssV0FBVyxjQUFjLE1BQU0sUUFBUSxhQUFhLElBQUksQ0FBQztBQUMzRSxzQkFBTSxVQUFXLEVBQUUsT0FBdUI7QUFDMUMsc0JBQU0sRUFBRSxNQUFNLElBQUk7QUFDbEIsc0JBQU0sV0FBVyxLQUFLLFNBQVMsSUFBSTtBQUNuQyxzQkFBTSxPQUFPLE1BQU0sSUFBSSxPQUFPLFFBQVE7QUFDdEMsc0JBQU0sTUFBTSxPQUFPLE1BQU0sUUFBUSxhQUFhLElBQUksSUFBSSw0QkFBNkIsR0FBRztBQUN0RixzQkFBTSxPQUFPLEtBQUssS0FBSyxRQUFRLEtBQUssT0FBTyxVQUFVLElBQUk7QUFDekQscUJBQUssU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEtBQUssTUFBTSxJQUFJLEtBQUssSUFBSSxRQUFRLEtBQUssUUFBUSxPQUFPLE1BQU0sRUFBRyxFQUFFLENBQUM7QUFBQSxjQUNyRztBQUVBLGtCQUFJLFNBQVMsZUFBZSxLQUFLLFFBQVEsY0FBYyxjQUFjLGNBQWMsY0FBYztBQUM3Rix3QkFBUSxjQUFjLGNBQWMsY0FBYyxhQUFhLFNBQVMsVUFBVSxTQUFTLGVBQWUsYUFBYTtBQUFBLGNBQzNILE9BQU87QUFDSCx3QkFBUSxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsT0FBTztBQUFBLGNBQzdFO0FBQUEsWUFHSjtBQUFBLFVBQ0osQ0FBQztBQUFBLFFBRUw7QUFBQSxNQUVKO0FBQUEsTUFFQSxPQUFPLFFBQW9CO0FBQ3ZCLGFBQUssSUFBSSxNQUFNLFlBQVksT0FBTyxLQUFLLGdCQUFnQjtBQUN2RCxhQUFLLFdBQVcsT0FBTyxJQUFJO0FBRTNCLFlBQUcsT0FBTyxpQkFBZ0I7QUFDdEIsd0JBQWMsSUFBSSxZQUFZLGNBQWMsQ0FBQztBQUFBLFFBQ2pEO0FBQUEsTUFLSjtBQUFBLE1BRUEsVUFBVTtBQUNOLGFBQUssSUFBSSxPQUFPO0FBQUEsTUFDcEI7QUFBQSxJQUNKO0FBQUEsRUFFSjtBQUNKOzs7QUMxSkEsSUFBQUMsbUJBQStDO0FBRXhDLElBQU0sb0JBQU4sY0FBZ0Msa0NBQWlCO0FBQUEsRUFHdEQsWUFBWSxLQUFVLFFBQWtCO0FBQ3RDLFVBQU0sS0FBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2hCO0FBQUEsRUFFQSxVQUFnQjtBQUNkLFFBQUksRUFBRSxZQUFZLElBQUk7QUFFdEIsZ0JBQVksTUFBTTtBQUVsQixRQUFJLHlCQUFRLFdBQVcsRUFDcEIsUUFBUSxjQUFJLEVBQ1osUUFBUSxnQ0FBTyxFQUNmO0FBQUEsTUFBUSxDQUFDLFNBQ1IsS0FDRyxlQUFlLEtBQUssRUFDcEIsU0FBUyxLQUFLLE9BQU8sU0FBUyxLQUFLLEVBQ25DLFNBQVMsQ0FBTyxVQUFVO0FBQ3pCLGFBQUssT0FBTyxTQUFTLFFBQVE7QUFDN0IsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLE1BQ2pDLEVBQUM7QUFBQSxJQUNMO0FBRUEsUUFBSSx5QkFBUSxXQUFXLEVBQ3RCLFFBQVEsb0JBQUssRUFDYixRQUFRLHNDQUFRLEVBQ2hCO0FBQUEsTUFBUSxDQUFDLFNBQ1IsS0FDRyxlQUFlLG9CQUFvQixFQUNuQyxTQUFTLEtBQUssT0FBTyxTQUFTLGVBQWUsRUFDN0MsU0FBUyxDQUFPLFVBQVU7QUFDekIsYUFBSyxPQUFPLFNBQVMsa0JBQWtCO0FBQ3ZDLGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNqQyxFQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDRjs7O0FDNUNBLElBQUFDLG1CQUF3Qzs7O0FDQXhDLFNBQVMsUUFBUSxLQUFLLGtCQUFrQjtBQUN0QyxRQUFNLE1BQXNCLHVCQUFPLE9BQU8sSUFBSTtBQUM5QyxRQUFNLE9BQU8sSUFBSSxNQUFNLEdBQUc7QUFDMUIsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxRQUFJLEtBQUssTUFBTTtBQUFBLEVBQ2pCO0FBQ0EsU0FBTyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksWUFBWSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSTtBQUMvRTtBQUVBLElBQU0sWUFBWSxRQUE0QyxPQUFPLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNuRixJQUFNLFlBQVksUUFBNEMsT0FBTyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDbkYsSUFBTSxPQUFPLE1BQU07QUFDbkI7QUFDQSxJQUFNLEtBQUssTUFBTTtBQUNqQixJQUFNLE9BQU87QUFDYixJQUFNLE9BQU8sQ0FBQyxRQUFRLEtBQUssS0FBSyxHQUFHO0FBQ25DLElBQU0sa0JBQWtCLENBQUMsUUFBUSxJQUFJLFdBQVcsV0FBVztBQUMzRCxJQUFNLFNBQVMsT0FBTztBQUN0QixJQUFNLFNBQVMsQ0FBQyxLQUFLLE9BQU87QUFDMUIsUUFBTSxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3hCLE1BQUksSUFBSSxJQUFJO0FBQ1YsUUFBSSxPQUFPLEdBQUcsQ0FBQztBQUFBLEVBQ2pCO0FBQ0Y7QUFDQSxJQUFNLGlCQUFpQixPQUFPLFVBQVU7QUFDeEMsSUFBTSxTQUFTLENBQUMsS0FBSyxRQUFRLGVBQWUsS0FBSyxLQUFLLEdBQUc7QUFDekQsSUFBTSxVQUFVLE1BQU07QUFDdEIsSUFBTSxRQUFRLENBQUMsUUFBUSxhQUFhLEdBQUcsTUFBTTtBQUM3QyxJQUFNLFFBQVEsQ0FBQyxRQUFRLGFBQWEsR0FBRyxNQUFNO0FBRzdDLElBQU0sYUFBYSxDQUFDLFFBQVEsT0FBTyxRQUFRO0FBQzNDLElBQU0sV0FBVyxDQUFDLFFBQVEsT0FBTyxRQUFRO0FBQ3pDLElBQU0sV0FBVyxDQUFDLFFBQVEsT0FBTyxRQUFRO0FBQ3pDLElBQU0sV0FBVyxDQUFDLFFBQVEsUUFBUSxRQUFRLE9BQU8sUUFBUTtBQUN6RCxJQUFNLFlBQVksQ0FBQyxRQUFRO0FBQ3pCLFNBQU8sU0FBUyxHQUFHLEtBQUssV0FBVyxJQUFJLElBQUksS0FBSyxXQUFXLElBQUksS0FBSztBQUN0RTtBQUNBLElBQU0saUJBQWlCLE9BQU8sVUFBVTtBQUN4QyxJQUFNLGVBQWUsQ0FBQyxVQUFVLGVBQWUsS0FBSyxLQUFLO0FBQ3pELElBQU0sWUFBWSxDQUFDLFVBQVU7QUFDM0IsU0FBTyxhQUFhLEtBQUssRUFBRSxNQUFNLEdBQUcsRUFBRTtBQUN4QztBQUNBLElBQU0sZ0JBQWdCLENBQUMsUUFBUSxhQUFhLEdBQUcsTUFBTTtBQUNyRCxJQUFNLGVBQWUsQ0FBQyxRQUFRLFNBQVMsR0FBRyxLQUFLLFFBQVEsU0FBUyxJQUFJLE9BQU8sT0FBTyxLQUFLLFNBQVMsS0FBSyxFQUFFLE1BQU07QUFDN0csSUFBTSxpQkFBaUM7QUFBQSxFQUVyQztBQUNGO0FBSUEsSUFBTSxzQkFBc0IsQ0FBQyxPQUFPO0FBQ2xDLFFBQU0sUUFBd0IsdUJBQU8sT0FBTyxJQUFJO0FBQ2hELFNBQU8sQ0FBQyxRQUFRO0FBQ2QsVUFBTSxNQUFNLE1BQU07QUFDbEIsV0FBTyxRQUFRLE1BQU0sT0FBTyxHQUFHLEdBQUc7QUFBQSxFQUNwQztBQUNGO0FBQ0EsSUFBTSxhQUFhO0FBQ25CLElBQU0sV0FBVyxvQkFBb0IsQ0FBQyxRQUFRO0FBQzVDLFNBQU8sSUFBSSxRQUFRLFlBQVksQ0FBQyxHQUFHLE1BQU0sSUFBSSxFQUFFLFlBQVksSUFBSSxFQUFFO0FBQ25FLENBQUM7QUFDRCxJQUFNLGNBQWM7QUFDcEIsSUFBTSxZQUFZO0FBQUEsRUFDaEIsQ0FBQyxRQUFRLElBQUksUUFBUSxhQUFhLEtBQUssRUFBRSxZQUFZO0FBQ3ZEO0FBQ0EsSUFBTSxhQUFhO0FBQUEsRUFDakIsQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDLEVBQUUsWUFBWSxJQUFJLElBQUksTUFBTSxDQUFDO0FBQ3BEO0FBQ0EsSUFBTSxlQUFlO0FBQUEsRUFDbkIsQ0FBQyxRQUFRLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTTtBQUMxQztBQUNBLElBQU0sYUFBYSxDQUFDLE9BQU8sYUFBYSxDQUFDLE9BQU8sR0FBRyxPQUFPLFFBQVE7QUFDbEUsSUFBTSxpQkFBaUIsQ0FBQyxLQUFLLFFBQVE7QUFDbkMsV0FBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxRQUFJLEdBQUcsR0FBRztBQUFBLEVBQ1o7QUFDRjtBQUNBLElBQU0sTUFBTSxDQUFDLEtBQUssS0FBSyxVQUFVO0FBQy9CLFNBQU8sZUFBZSxLQUFLLEtBQUs7QUFBQSxJQUM5QixjQUFjO0FBQUEsSUFDZCxZQUFZO0FBQUEsSUFDWjtBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBQ0EsSUFBTSxnQkFBZ0IsQ0FBQyxRQUFRO0FBQzdCLFFBQU0sSUFBSSxXQUFXLEdBQUc7QUFDeEIsU0FBTyxNQUFNLENBQUMsSUFBSSxNQUFNO0FBQzFCO0FBQ0EsSUFBTSxXQUFXLENBQUMsUUFBUTtBQUN4QixRQUFNLElBQUksU0FBUyxHQUFHLElBQUksT0FBTyxHQUFHLElBQUk7QUFDeEMsU0FBTyxNQUFNLENBQUMsSUFBSSxNQUFNO0FBQzFCO0FBQ0EsSUFBSTtBQUNKLElBQU0sZ0JBQWdCLE1BQU07QUFDMUIsU0FBTyxnQkFBZ0IsY0FBYyxPQUFPLGVBQWUsY0FBYyxhQUFhLE9BQU8sU0FBUyxjQUFjLE9BQU8sT0FBTyxXQUFXLGNBQWMsU0FBUyxPQUFPLFdBQVcsY0FBYyxTQUFTLENBQUM7QUFDaE47QUF3RUEsU0FBUyxlQUFlLE9BQU87QUFDN0IsTUFBSSxRQUFRLEtBQUssR0FBRztBQUNsQixVQUFNLE1BQU0sQ0FBQztBQUNiLGFBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsWUFBTSxPQUFPLE1BQU07QUFDbkIsWUFBTSxhQUFhLFNBQVMsSUFBSSxJQUFJLGlCQUFpQixJQUFJLElBQUksZUFBZSxJQUFJO0FBQ2hGLFVBQUksWUFBWTtBQUNkLG1CQUFXLE9BQU8sWUFBWTtBQUM1QixjQUFJLE9BQU8sV0FBVztBQUFBLFFBQ3hCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVCxXQUFXLFNBQVMsS0FBSyxHQUFHO0FBQzFCLFdBQU87QUFBQSxFQUNULFdBQVcsU0FBUyxLQUFLLEdBQUc7QUFDMUIsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUNBLElBQU0sa0JBQWtCO0FBQ3hCLElBQU0sc0JBQXNCO0FBQzVCLElBQU0saUJBQWlCO0FBQ3ZCLFNBQVMsaUJBQWlCLFNBQVM7QUFDakMsUUFBTSxNQUFNLENBQUM7QUFDYixVQUFRLFFBQVEsZ0JBQWdCLEVBQUUsRUFBRSxNQUFNLGVBQWUsRUFBRSxRQUFRLENBQUMsU0FBUztBQUMzRSxRQUFJLE1BQU07QUFDUixZQUFNLE1BQU0sS0FBSyxNQUFNLG1CQUFtQjtBQUMxQyxVQUFJLFNBQVMsTUFBTSxJQUFJLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxHQUFHLEtBQUs7QUFBQSxJQUN0RDtBQUFBLEVBQ0YsQ0FBQztBQUNELFNBQU87QUFDVDtBQWVBLFNBQVMsZUFBZSxPQUFPO0FBQzdCLE1BQUksTUFBTTtBQUNWLE1BQUksU0FBUyxLQUFLLEdBQUc7QUFDbkIsVUFBTTtBQUFBLEVBQ1IsV0FBVyxRQUFRLEtBQUssR0FBRztBQUN6QixhQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ3JDLFlBQU0sYUFBYSxlQUFlLE1BQU0sRUFBRTtBQUMxQyxVQUFJLFlBQVk7QUFDZCxlQUFPLGFBQWE7QUFBQSxNQUN0QjtBQUFBLElBQ0Y7QUFBQSxFQUNGLFdBQVcsU0FBUyxLQUFLLEdBQUc7QUFDMUIsZUFBVyxRQUFRLE9BQU87QUFDeEIsVUFBSSxNQUFNLE9BQU87QUFDZixlQUFPLE9BQU87QUFBQSxNQUNoQjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTyxJQUFJLEtBQUs7QUFDbEI7QUFxQkEsSUFBTSxzQkFBc0I7QUFDNUIsSUFBTSx1QkFBdUMsd0JBQVEsbUJBQW1CO0FBQ3hFLElBQU0sZ0JBQWdDO0FBQUEsRUFDcEMsc0JBQXNCO0FBQ3hCO0FBQ0EsU0FBUyxtQkFBbUIsT0FBTztBQUNqQyxTQUFPLENBQUMsQ0FBQyxTQUFTLFVBQVU7QUFDOUI7QUEwSEEsSUFBTSxrQkFBa0IsQ0FBQyxRQUFRO0FBQy9CLFNBQU8sU0FBUyxHQUFHLElBQUksTUFBTSxPQUFPLE9BQU8sS0FBSyxRQUFRLEdBQUcsS0FBSyxTQUFTLEdBQUcsTUFBTSxJQUFJLGFBQWEsa0JBQWtCLENBQUMsV0FBVyxJQUFJLFFBQVEsS0FBSyxLQUFLLFVBQVUsS0FBSyxVQUFVLENBQUMsSUFBSSxPQUFPLEdBQUc7QUFDak07QUFDQSxJQUFNLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDOUIsTUFBSSxPQUFPLElBQUksV0FBVztBQUN4QixXQUFPLFNBQVMsTUFBTSxJQUFJLEtBQUs7QUFBQSxFQUNqQyxXQUFXLE1BQU0sR0FBRyxHQUFHO0FBQ3JCLFdBQU87QUFBQSxNQUNMLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHLElBQUksUUFBUSxDQUFDLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLElBQUksTUFBTTtBQUN4RSxnQkFBUSxHQUFHLFlBQVk7QUFDdkIsZUFBTztBQUFBLE1BQ1QsR0FBRyxDQUFDLENBQUM7QUFBQSxJQUNQO0FBQUEsRUFDRixXQUFXLE1BQU0sR0FBRyxHQUFHO0FBQ3JCLFdBQU87QUFBQSxNQUNMLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDO0FBQUEsSUFDeEM7QUFBQSxFQUNGLFdBQVcsU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLGNBQWMsR0FBRyxHQUFHO0FBQ2hFLFdBQU8sT0FBTyxHQUFHO0FBQUEsRUFDbkI7QUFDQSxTQUFPO0FBQ1Q7OztBQy9ZQSxJQUFJO0FBQ0osSUFBTSxjQUFOLE1BQWtCO0FBQUEsRUFDaEIsWUFBWSxXQUFXLE9BQU87QUFDNUIsU0FBSyxXQUFXO0FBSWhCLFNBQUssVUFBVTtBQUlmLFNBQUssVUFBVSxDQUFDO0FBSWhCLFNBQUssV0FBVyxDQUFDO0FBQ2pCLFNBQUssU0FBUztBQUNkLFFBQUksQ0FBQyxZQUFZLG1CQUFtQjtBQUNsQyxXQUFLLFNBQVMsa0JBQWtCLFdBQVcsa0JBQWtCLFNBQVMsQ0FBQyxJQUFJO0FBQUEsUUFDekU7QUFBQSxNQUNGLElBQUk7QUFBQSxJQUNOO0FBQUEsRUFDRjtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1gsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBQ0EsSUFBSSxJQUFJO0FBQ04sUUFBSSxLQUFLLFNBQVM7QUFDaEIsWUFBTSxxQkFBcUI7QUFDM0IsVUFBSTtBQUNGLDRCQUFvQjtBQUNwQixlQUFPLEdBQUc7QUFBQSxNQUNaLFVBQUU7QUFDQSw0QkFBb0I7QUFBQSxNQUN0QjtBQUFBLElBQ0YsV0FBVyxPQUEyQztBQUNwRCxXQUFLLHNDQUFzQztBQUFBLElBQzdDO0FBQUEsRUFDRjtBQUFBLEVBS0EsS0FBSztBQUNILHdCQUFvQjtBQUFBLEVBQ3RCO0FBQUEsRUFLQSxNQUFNO0FBQ0osd0JBQW9CLEtBQUs7QUFBQSxFQUMzQjtBQUFBLEVBQ0EsS0FBSyxZQUFZO0FBQ2YsUUFBSSxLQUFLLFNBQVM7QUFDaEIsVUFBSSxHQUFHO0FBQ1AsV0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUMvQyxhQUFLLFFBQVEsR0FBRyxLQUFLO0FBQUEsTUFDdkI7QUFDQSxXQUFLLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxRQUFRLElBQUksR0FBRyxLQUFLO0FBQ2hELGFBQUssU0FBUyxHQUFHO0FBQUEsTUFDbkI7QUFDQSxVQUFJLEtBQUssUUFBUTtBQUNmLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDOUMsZUFBSyxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBQUEsUUFDMUI7QUFBQSxNQUNGO0FBQ0EsVUFBSSxDQUFDLEtBQUssWUFBWSxLQUFLLFVBQVUsQ0FBQyxZQUFZO0FBQ2hELGNBQU0sT0FBTyxLQUFLLE9BQU8sT0FBTyxJQUFJO0FBQ3BDLFlBQUksUUFBUSxTQUFTLE1BQU07QUFDekIsZUFBSyxPQUFPLE9BQU8sS0FBSyxTQUFTO0FBQ2pDLGVBQUssUUFBUSxLQUFLO0FBQUEsUUFDcEI7QUFBQSxNQUNGO0FBQ0EsV0FBSyxTQUFTO0FBQ2QsV0FBSyxVQUFVO0FBQUEsSUFDakI7QUFBQSxFQUNGO0FBQ0Y7QUFJQSxTQUFTLGtCQUFrQkMsU0FBUSxRQUFRLG1CQUFtQjtBQUM1RCxNQUFJLFNBQVMsTUFBTSxRQUFRO0FBQ3pCLFVBQU0sUUFBUSxLQUFLQSxPQUFNO0FBQUEsRUFDM0I7QUFDRjtBQUNBLFNBQVMsa0JBQWtCO0FBQ3pCLFNBQU87QUFDVDtBQVdBLElBQU0sWUFBWSxDQUFDLFlBQVk7QUFDN0IsUUFBTSxNQUFNLElBQUksSUFBSSxPQUFPO0FBQzNCLE1BQUksSUFBSTtBQUNSLE1BQUksSUFBSTtBQUNSLFNBQU87QUFDVDtBQUNBLElBQU0sYUFBYSxDQUFDLFNBQVMsSUFBSSxJQUFJLGNBQWM7QUFDbkQsSUFBTSxhQUFhLENBQUMsU0FBUyxJQUFJLElBQUksY0FBYztBQUNuRCxJQUFNLGlCQUFpQixDQUFDLEVBQUUsS0FBSyxNQUFNO0FBQ25DLE1BQUksS0FBSyxRQUFRO0FBQ2YsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxXQUFLLEdBQUcsS0FBSztBQUFBLElBQ2Y7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLHFCQUFxQixDQUFDQyxZQUFXO0FBQ3JDLFFBQU0sRUFBRSxLQUFLLElBQUlBO0FBQ2pCLE1BQUksS0FBSyxRQUFRO0FBQ2YsUUFBSSxNQUFNO0FBQ1YsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNwQyxZQUFNLE1BQU0sS0FBSztBQUNqQixVQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxHQUFHLEdBQUc7QUFDdkMsWUFBSSxPQUFPQSxPQUFNO0FBQUEsTUFDbkIsT0FBTztBQUNMLGFBQUssU0FBUztBQUFBLE1BQ2hCO0FBQ0EsVUFBSSxLQUFLLENBQUM7QUFDVixVQUFJLEtBQUssQ0FBQztBQUFBLElBQ1o7QUFDQSxTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUNGO0FBRUEsSUFBTSxZQUE0QixvQkFBSSxRQUFRO0FBQzlDLElBQUksbUJBQW1CO0FBQ3ZCLElBQUksYUFBYTtBQUNqQixJQUFNLGdCQUFnQjtBQUN0QixJQUFJO0FBQ0osSUFBTSxjQUFjLE9BQU8sUUFBNEMsWUFBWSxFQUFFO0FBQ3JGLElBQU0sc0JBQXNCLE9BQU8sUUFBNEMsb0JBQW9CLEVBQUU7QUFDckcsSUFBTSxpQkFBTixNQUFxQjtBQUFBLEVBQ25CLFlBQVksSUFBSSxZQUFZLE1BQU0sT0FBTztBQUN2QyxTQUFLLEtBQUs7QUFDVixTQUFLLFlBQVk7QUFDakIsU0FBSyxTQUFTO0FBQ2QsU0FBSyxPQUFPLENBQUM7QUFDYixTQUFLLFNBQVM7QUFDZCxzQkFBa0IsTUFBTSxLQUFLO0FBQUEsRUFDL0I7QUFBQSxFQUNBLE1BQU07QUFDSixRQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2hCLGFBQU8sS0FBSyxHQUFHO0FBQUEsSUFDakI7QUFDQSxRQUFJLFNBQVM7QUFDYixRQUFJLGtCQUFrQjtBQUN0QixXQUFPLFFBQVE7QUFDYixVQUFJLFdBQVcsTUFBTTtBQUNuQjtBQUFBLE1BQ0Y7QUFDQSxlQUFTLE9BQU87QUFBQSxJQUNsQjtBQUNBLFFBQUk7QUFDRixXQUFLLFNBQVM7QUFDZCxxQkFBZTtBQUNmLG9CQUFjO0FBQ2QsbUJBQWEsS0FBSyxFQUFFO0FBQ3BCLFVBQUksb0JBQW9CLGVBQWU7QUFDckMsdUJBQWUsSUFBSTtBQUFBLE1BQ3JCLE9BQU87QUFDTCxzQkFBYyxJQUFJO0FBQUEsTUFDcEI7QUFDQSxhQUFPLEtBQUssR0FBRztBQUFBLElBQ2pCLFVBQUU7QUFDQSxVQUFJLG9CQUFvQixlQUFlO0FBQ3JDLDJCQUFtQixJQUFJO0FBQUEsTUFDekI7QUFDQSxtQkFBYSxLQUFLLEVBQUU7QUFDcEIscUJBQWUsS0FBSztBQUNwQixvQkFBYztBQUNkLFdBQUssU0FBUztBQUNkLFVBQUksS0FBSyxXQUFXO0FBQ2xCLGFBQUssS0FBSztBQUFBLE1BQ1o7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBQ0EsT0FBTztBQUNMLFFBQUksaUJBQWlCLE1BQU07QUFDekIsV0FBSyxZQUFZO0FBQUEsSUFDbkIsV0FBVyxLQUFLLFFBQVE7QUFDdEIsb0JBQWMsSUFBSTtBQUNsQixVQUFJLEtBQUssUUFBUTtBQUNmLGFBQUssT0FBTztBQUFBLE1BQ2Q7QUFDQSxXQUFLLFNBQVM7QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLFNBQVMsY0FBYyxTQUFTO0FBQzlCLFFBQU0sRUFBRSxLQUFLLElBQUk7QUFDakIsTUFBSSxLQUFLLFFBQVE7QUFDZixhQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLFdBQUssR0FBRyxPQUFPLE9BQU87QUFBQSxJQUN4QjtBQUNBLFNBQUssU0FBUztBQUFBLEVBQ2hCO0FBQ0Y7QUFxQkEsSUFBSSxjQUFjO0FBQ2xCLElBQU0sYUFBYSxDQUFDO0FBQ3BCLFNBQVMsZ0JBQWdCO0FBQ3ZCLGFBQVcsS0FBSyxXQUFXO0FBQzNCLGdCQUFjO0FBQ2hCO0FBS0EsU0FBUyxnQkFBZ0I7QUFDdkIsUUFBTSxPQUFPLFdBQVcsSUFBSTtBQUM1QixnQkFBYyxTQUFTLFNBQVMsT0FBTztBQUN6QztBQUNBLFNBQVMsTUFBTSxRQUFRLE1BQU0sS0FBSztBQUNoQyxNQUFJLGVBQWUsY0FBYztBQUMvQixRQUFJLFVBQVUsVUFBVSxJQUFJLE1BQU07QUFDbEMsUUFBSSxDQUFDLFNBQVM7QUFDWixnQkFBVSxJQUFJLFFBQVEsVUFBMEIsb0JBQUksSUFBSSxDQUFDO0FBQUEsSUFDM0Q7QUFDQSxRQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDekIsUUFBSSxDQUFDLEtBQUs7QUFDUixjQUFRLElBQUksS0FBSyxNQUFNLFVBQVUsQ0FBQztBQUFBLElBQ3BDO0FBQ0EsVUFBTSxZQUFZLFFBQTRDLEVBQUUsUUFBUSxjQUFjLFFBQVEsTUFBTSxJQUFJLElBQUk7QUFDNUcsaUJBQWEsS0FBSyxTQUFTO0FBQUEsRUFDN0I7QUFDRjtBQUNBLFNBQVMsYUFBYSxLQUFLLHdCQUF3QjtBQUNqRCxNQUFJLGVBQWU7QUFDbkIsTUFBSSxvQkFBb0IsZUFBZTtBQUNyQyxRQUFJLENBQUMsV0FBVyxHQUFHLEdBQUc7QUFDcEIsVUFBSSxLQUFLO0FBQ1QscUJBQWUsQ0FBQyxXQUFXLEdBQUc7QUFBQSxJQUNoQztBQUFBLEVBQ0YsT0FBTztBQUNMLG1CQUFlLENBQUMsSUFBSSxJQUFJLFlBQVk7QUFBQSxFQUN0QztBQUNBLE1BQUksY0FBYztBQUNoQixRQUFJLElBQUksWUFBWTtBQUNwQixpQkFBYSxLQUFLLEtBQUssR0FBRztBQUMxQixRQUFJLE9BQW1FO0FBQ3JFLG1CQUFhO0FBQUEsUUFDWDtBQUFBLFVBQ0U7QUFBQSxZQUNFLFFBQVE7QUFBQSxVQUNWO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLFNBQVMsUUFBUSxRQUFRLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVztBQUNqRSxRQUFNLFVBQVUsVUFBVSxJQUFJLE1BQU07QUFDcEMsTUFBSSxDQUFDLFNBQVM7QUFDWjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLE9BQU8sQ0FBQztBQUNaLE1BQUksU0FBUyxTQUFTO0FBQ3BCLFdBQU8sQ0FBQyxHQUFHLFFBQVEsT0FBTyxDQUFDO0FBQUEsRUFDN0IsV0FBVyxRQUFRLFlBQVksUUFBUSxNQUFNLEdBQUc7QUFDOUMsVUFBTSxZQUFZLE9BQU8sUUFBUTtBQUNqQyxZQUFRLFFBQVEsQ0FBQyxLQUFLLFNBQVM7QUFDN0IsVUFBSSxTQUFTLFlBQVksUUFBUSxXQUFXO0FBQzFDLGFBQUssS0FBSyxHQUFHO0FBQUEsTUFDZjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0gsT0FBTztBQUNMLFFBQUksUUFBUSxRQUFRO0FBQ2xCLFdBQUssS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDO0FBQUEsSUFDNUI7QUFDQSxZQUFRO0FBQUEsV0FDRDtBQUNILFlBQUksQ0FBQyxRQUFRLE1BQU0sR0FBRztBQUNwQixlQUFLLEtBQUssUUFBUSxJQUFJLFdBQVcsQ0FBQztBQUNsQyxjQUFJLE1BQU0sTUFBTSxHQUFHO0FBQ2pCLGlCQUFLLEtBQUssUUFBUSxJQUFJLG1CQUFtQixDQUFDO0FBQUEsVUFDNUM7QUFBQSxRQUNGLFdBQVcsYUFBYSxHQUFHLEdBQUc7QUFDNUIsZUFBSyxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUM7QUFBQSxRQUNqQztBQUNBO0FBQUEsV0FDRztBQUNILFlBQUksQ0FBQyxRQUFRLE1BQU0sR0FBRztBQUNwQixlQUFLLEtBQUssUUFBUSxJQUFJLFdBQVcsQ0FBQztBQUNsQyxjQUFJLE1BQU0sTUFBTSxHQUFHO0FBQ2pCLGlCQUFLLEtBQUssUUFBUSxJQUFJLG1CQUFtQixDQUFDO0FBQUEsVUFDNUM7QUFBQSxRQUNGO0FBQ0E7QUFBQSxXQUNHO0FBQ0gsWUFBSSxNQUFNLE1BQU0sR0FBRztBQUNqQixlQUFLLEtBQUssUUFBUSxJQUFJLFdBQVcsQ0FBQztBQUFBLFFBQ3BDO0FBQ0E7QUFBQTtBQUFBLEVBRU47QUFDQSxRQUFNLFlBQVksUUFBNEMsRUFBRSxRQUFRLE1BQU0sS0FBSyxVQUFVLFVBQVUsVUFBVSxJQUFJO0FBQ3JILE1BQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsUUFBSSxLQUFLLElBQUk7QUFDWCxVQUFJLE9BQTJDO0FBQzdDLHVCQUFlLEtBQUssSUFBSSxTQUFTO0FBQUEsTUFDbkMsT0FBTztBQUNMLHVCQUFlLEtBQUssRUFBRTtBQUFBLE1BQ3hCO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLFVBQU0sVUFBVSxDQUFDO0FBQ2pCLGVBQVcsT0FBTyxNQUFNO0FBQ3RCLFVBQUksS0FBSztBQUNQLGdCQUFRLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDckI7QUFBQSxJQUNGO0FBQ0EsUUFBSSxPQUEyQztBQUM3QyxxQkFBZSxVQUFVLE9BQU8sR0FBRyxTQUFTO0FBQUEsSUFDOUMsT0FBTztBQUNMLHFCQUFlLFVBQVUsT0FBTyxDQUFDO0FBQUEsSUFDbkM7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLGVBQWUsS0FBSyx3QkFBd0I7QUFDbkQsUUFBTSxVQUFVLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUc7QUFDNUMsYUFBVyxXQUFXLFNBQVM7QUFDN0IsUUFBSSxRQUFRLFVBQVU7QUFDcEIsb0JBQWMsU0FBUyxzQkFBc0I7QUFBQSxJQUMvQztBQUFBLEVBQ0Y7QUFDQSxhQUFXLFdBQVcsU0FBUztBQUM3QixRQUFJLENBQUMsUUFBUSxVQUFVO0FBQ3JCLG9CQUFjLFNBQVMsc0JBQXNCO0FBQUEsSUFDL0M7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLGNBQWMsU0FBUyx3QkFBd0I7QUFDdEQsTUFBSSxZQUFZLGdCQUFnQixRQUFRLGNBQWM7QUFDcEQsUUFBSSxPQUFnRTtBQUNsRSxjQUFRLFVBQVUsT0FBTyxFQUFFLFFBQVEsUUFBUSxHQUFHLHNCQUFzQixDQUFDO0FBQUEsSUFDdkU7QUFDQSxRQUFJLFFBQVEsV0FBVztBQUNyQixjQUFRLFVBQVU7QUFBQSxJQUNwQixPQUFPO0FBQ0wsY0FBUSxJQUFJO0FBQUEsSUFDZDtBQUFBLEVBQ0Y7QUFDRjtBQU1BLElBQU0scUJBQXFDLHdCQUFRLDZCQUE2QjtBQUNoRixJQUFNLGlCQUFpQixJQUFJO0FBQUEsRUFDVCx1QkFBTyxvQkFBb0IsTUFBTSxFQUFFLE9BQU8sQ0FBQyxRQUFRLFFBQVEsZUFBZSxRQUFRLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxPQUFPLElBQUksRUFBRSxPQUFPLFFBQVE7QUFDdko7QUFDQSxJQUFNLFFBQXdCLDZCQUFhO0FBQzNDLElBQU0sYUFBNkIsNkJBQWEsT0FBTyxJQUFJO0FBQzNELElBQU0sY0FBOEIsNkJBQWEsSUFBSTtBQUVyRCxJQUFNLHdCQUF3Qyw0Q0FBNEI7QUFDMUUsU0FBUyw4QkFBOEI7QUFDckMsUUFBTSxtQkFBbUIsQ0FBQztBQUMxQixHQUFDLFlBQVksV0FBVyxhQUFhLEVBQUUsUUFBUSxDQUFDLFFBQVE7QUFDdEQscUJBQWlCLE9BQU8sWUFBWSxNQUFNO0FBQ3hDLFlBQU0sTUFBTSxNQUFNLElBQUk7QUFDdEIsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDM0MsY0FBTSxLQUFLLE9BQU8sSUFBSSxFQUFFO0FBQUEsTUFDMUI7QUFDQSxZQUFNLE1BQU0sSUFBSSxLQUFLLEdBQUcsSUFBSTtBQUM1QixVQUFJLFFBQVEsTUFBTSxRQUFRLE9BQU87QUFDL0IsZUFBTyxJQUFJLEtBQUssR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDO0FBQUEsTUFDcEMsT0FBTztBQUNMLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNELEdBQUMsUUFBUSxPQUFPLFNBQVMsV0FBVyxRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVE7QUFDN0QscUJBQWlCLE9BQU8sWUFBWSxNQUFNO0FBQ3hDLG9CQUFjO0FBQ2QsWUFBTSxNQUFNLE1BQU0sSUFBSSxFQUFFLEtBQUssTUFBTSxNQUFNLElBQUk7QUFDN0Msb0JBQWM7QUFDZCxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0YsQ0FBQztBQUNELFNBQU87QUFDVDtBQUNBLFNBQVNDLGdCQUFlLEtBQUs7QUFDM0IsUUFBTSxNQUFNLE1BQU0sSUFBSTtBQUN0QixRQUFNLEtBQUssT0FBTyxHQUFHO0FBQ3JCLFNBQU8sSUFBSSxlQUFlLEdBQUc7QUFDL0I7QUFDQSxTQUFTLGFBQWEsY0FBYyxPQUFPLFVBQVUsT0FBTztBQUMxRCxTQUFPLFNBQVMsS0FBSyxRQUFRLEtBQUssVUFBVTtBQUMxQyxRQUFJLFFBQVEsa0JBQWtCO0FBQzVCLGFBQU8sQ0FBQztBQUFBLElBQ1YsV0FBVyxRQUFRLGtCQUFrQjtBQUNuQyxhQUFPO0FBQUEsSUFDVCxXQUFXLFFBQVEsaUJBQWlCO0FBQ2xDLGFBQU87QUFBQSxJQUNULFdBQVcsUUFBUSxhQUFhLGNBQWMsY0FBYyxVQUFVLHFCQUFxQixjQUFjLFVBQVUscUJBQXFCLGFBQWEsSUFBSSxNQUFNLEdBQUc7QUFDaEssYUFBTztBQUFBLElBQ1Q7QUFDQSxVQUFNLGdCQUFnQixRQUFRLE1BQU07QUFDcEMsUUFBSSxDQUFDLGFBQWE7QUFDaEIsVUFBSSxpQkFBaUIsT0FBTyx1QkFBdUIsR0FBRyxHQUFHO0FBQ3ZELGVBQU8sUUFBUSxJQUFJLHVCQUF1QixLQUFLLFFBQVE7QUFBQSxNQUN6RDtBQUNBLFVBQUksUUFBUSxrQkFBa0I7QUFDNUIsZUFBT0E7QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUNBLFVBQU0sTUFBTSxRQUFRLElBQUksUUFBUSxLQUFLLFFBQVE7QUFDN0MsUUFBSSxTQUFTLEdBQUcsSUFBSSxlQUFlLElBQUksR0FBRyxJQUFJLG1CQUFtQixHQUFHLEdBQUc7QUFDckUsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLENBQUMsYUFBYTtBQUNoQixZQUFNLFFBQVEsT0FBTyxHQUFHO0FBQUEsSUFDMUI7QUFDQSxRQUFJLFNBQVM7QUFDWCxhQUFPO0FBQUEsSUFDVDtBQUNBLFFBQUksTUFBTSxHQUFHLEdBQUc7QUFDZCxhQUFPLGlCQUFpQixhQUFhLEdBQUcsSUFBSSxNQUFNLElBQUk7QUFBQSxJQUN4RDtBQUNBLFFBQUksU0FBUyxHQUFHLEdBQUc7QUFDakIsYUFBTyxjQUFjLFNBQVMsR0FBRyxJQUFJLFNBQVMsR0FBRztBQUFBLElBQ25EO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUNBLElBQU0sUUFBd0IsNkJBQWE7QUFDM0MsSUFBTSxhQUE2Qiw2QkFBYSxJQUFJO0FBQ3BELFNBQVMsYUFBYSxVQUFVLE9BQU87QUFDckMsU0FBTyxTQUFTLEtBQUssUUFBUSxLQUFLLE9BQU8sVUFBVTtBQUNqRCxRQUFJLFdBQVcsT0FBTztBQUN0QixRQUFJLFdBQVcsUUFBUSxLQUFLLE1BQU0sUUFBUSxLQUFLLENBQUMsTUFBTSxLQUFLLEdBQUc7QUFDNUQsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLENBQUMsU0FBUztBQUNaLFVBQUksQ0FBQyxVQUFVLEtBQUssS0FBSyxDQUFDLFdBQVcsS0FBSyxHQUFHO0FBQzNDLG1CQUFXLE1BQU0sUUFBUTtBQUN6QixnQkFBUSxNQUFNLEtBQUs7QUFBQSxNQUNyQjtBQUNBLFVBQUksQ0FBQyxRQUFRLE1BQU0sS0FBSyxNQUFNLFFBQVEsS0FBSyxDQUFDLE1BQU0sS0FBSyxHQUFHO0FBQ3hELGlCQUFTLFFBQVE7QUFDakIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQ0EsVUFBTSxTQUFTLFFBQVEsTUFBTSxLQUFLLGFBQWEsR0FBRyxJQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sU0FBUyxPQUFPLFFBQVEsR0FBRztBQUN0RyxVQUFNLFNBQVMsUUFBUSxJQUFJLFFBQVEsS0FBSyxPQUFPLFFBQVE7QUFDdkQsUUFBSSxXQUFXLE1BQU0sUUFBUSxHQUFHO0FBQzlCLFVBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQVEsUUFBUSxPQUFPLEtBQUssS0FBSztBQUFBLE1BQ25DLFdBQVcsV0FBVyxPQUFPLFFBQVEsR0FBRztBQUN0QyxnQkFBUSxRQUFRLE9BQU8sS0FBSyxPQUFPLFFBQVE7QUFBQSxNQUM3QztBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBQ0EsU0FBUyxlQUFlLFFBQVEsS0FBSztBQUNuQyxRQUFNLFNBQVMsT0FBTyxRQUFRLEdBQUc7QUFDakMsUUFBTSxXQUFXLE9BQU87QUFDeEIsUUFBTSxTQUFTLFFBQVEsZUFBZSxRQUFRLEdBQUc7QUFDakQsTUFBSSxVQUFVLFFBQVE7QUFDcEIsWUFBUSxRQUFRLFVBQVUsS0FBSyxRQUFRLFFBQVE7QUFBQSxFQUNqRDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsTUFBTSxRQUFRLEtBQUs7QUFDMUIsUUFBTSxTQUFTLFFBQVEsSUFBSSxRQUFRLEdBQUc7QUFDdEMsTUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsZUFBZSxJQUFJLEdBQUcsR0FBRztBQUM5QyxVQUFNLFFBQVEsT0FBTyxHQUFHO0FBQUEsRUFDMUI7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLFFBQVEsUUFBUTtBQUN2QixRQUFNLFFBQVEsV0FBVyxRQUFRLE1BQU0sSUFBSSxXQUFXLFdBQVc7QUFDakUsU0FBTyxRQUFRLFFBQVEsTUFBTTtBQUMvQjtBQUNBLElBQU0sa0JBQWtCO0FBQUEsRUFDdEIsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0w7QUFBQSxFQUNBLEtBQUs7QUFBQSxFQUNMO0FBQ0Y7QUFDQSxJQUFNLG1CQUFtQjtBQUFBLEVBQ3ZCLEtBQUs7QUFBQSxFQUNMLElBQUksUUFBUSxLQUFLO0FBQ2YsUUFBSSxPQUEyQztBQUM3QztBQUFBLFFBQ0UseUJBQXlCLE9BQU8sR0FBRztBQUFBLFFBQ25DO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsZUFBZSxRQUFRLEtBQUs7QUFDMUIsUUFBSSxPQUEyQztBQUM3QztBQUFBLFFBQ0UsNEJBQTRCLE9BQU8sR0FBRztBQUFBLFFBQ3RDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBQ0EsSUFBTSwwQkFBMEM7QUFBQSxFQUM5QyxDQUFDO0FBQUEsRUFDRDtBQUFBLEVBQ0E7QUFBQSxJQUNFLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxFQUNQO0FBQ0Y7QUFTQSxJQUFNLFlBQVksQ0FBQyxVQUFVO0FBQzdCLElBQU0sV0FBVyxDQUFDLE1BQU0sUUFBUSxlQUFlLENBQUM7QUFDaEQsU0FBUyxJQUFJLFFBQVEsS0FBS0MsY0FBYSxPQUFPQyxhQUFZLE9BQU87QUFDL0QsV0FBUyxPQUFPO0FBQ2hCLFFBQU0sWUFBWSxNQUFNLE1BQU07QUFDOUIsUUFBTSxTQUFTLE1BQU0sR0FBRztBQUN4QixNQUFJLENBQUNELGFBQVk7QUFDZixRQUFJLFFBQVEsUUFBUTtBQUNsQixZQUFNLFdBQVcsT0FBTyxHQUFHO0FBQUEsSUFDN0I7QUFDQSxVQUFNLFdBQVcsT0FBTyxNQUFNO0FBQUEsRUFDaEM7QUFDQSxRQUFNLEVBQUUsS0FBSyxLQUFLLElBQUksU0FBUyxTQUFTO0FBQ3hDLFFBQU0sT0FBT0MsYUFBWSxZQUFZRCxjQUFhLGFBQWE7QUFDL0QsTUFBSSxLQUFLLEtBQUssV0FBVyxHQUFHLEdBQUc7QUFDN0IsV0FBTyxLQUFLLE9BQU8sSUFBSSxHQUFHLENBQUM7QUFBQSxFQUM3QixXQUFXLEtBQUssS0FBSyxXQUFXLE1BQU0sR0FBRztBQUN2QyxXQUFPLEtBQUssT0FBTyxJQUFJLE1BQU0sQ0FBQztBQUFBLEVBQ2hDLFdBQVcsV0FBVyxXQUFXO0FBQy9CLFdBQU8sSUFBSSxHQUFHO0FBQUEsRUFDaEI7QUFDRjtBQUNBLFNBQVMsSUFBSSxLQUFLQSxjQUFhLE9BQU87QUFDcEMsUUFBTSxTQUFTLEtBQUs7QUFDcEIsUUFBTSxZQUFZLE1BQU0sTUFBTTtBQUM5QixRQUFNLFNBQVMsTUFBTSxHQUFHO0FBQ3hCLE1BQUksQ0FBQ0EsYUFBWTtBQUNmLFFBQUksUUFBUSxRQUFRO0FBQ2xCLFlBQU0sV0FBVyxPQUFPLEdBQUc7QUFBQSxJQUM3QjtBQUNBLFVBQU0sV0FBVyxPQUFPLE1BQU07QUFBQSxFQUNoQztBQUNBLFNBQU8sUUFBUSxTQUFTLE9BQU8sSUFBSSxHQUFHLElBQUksT0FBTyxJQUFJLEdBQUcsS0FBSyxPQUFPLElBQUksTUFBTTtBQUNoRjtBQUNBLFNBQVMsS0FBSyxRQUFRQSxjQUFhLE9BQU87QUFDeEMsV0FBUyxPQUFPO0FBQ2hCLEdBQUNBLGVBQWMsTUFBTSxNQUFNLE1BQU0sR0FBRyxXQUFXLFdBQVc7QUFDMUQsU0FBTyxRQUFRLElBQUksUUFBUSxRQUFRLE1BQU07QUFDM0M7QUFDQSxTQUFTLElBQUksT0FBTztBQUNsQixVQUFRLE1BQU0sS0FBSztBQUNuQixRQUFNLFNBQVMsTUFBTSxJQUFJO0FBQ3pCLFFBQU0sUUFBUSxTQUFTLE1BQU07QUFDN0IsUUFBTSxTQUFTLE1BQU0sSUFBSSxLQUFLLFFBQVEsS0FBSztBQUMzQyxNQUFJLENBQUMsUUFBUTtBQUNYLFdBQU8sSUFBSSxLQUFLO0FBQ2hCLFlBQVEsUUFBUSxPQUFPLE9BQU8sS0FBSztBQUFBLEVBQ3JDO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxJQUFJLEtBQUssT0FBTztBQUN2QixVQUFRLE1BQU0sS0FBSztBQUNuQixRQUFNLFNBQVMsTUFBTSxJQUFJO0FBQ3pCLFFBQU0sRUFBRSxLQUFLLE1BQU0sS0FBSyxLQUFLLElBQUksU0FBUyxNQUFNO0FBQ2hELE1BQUksU0FBUyxLQUFLLEtBQUssUUFBUSxHQUFHO0FBQ2xDLE1BQUksQ0FBQyxRQUFRO0FBQ1gsVUFBTSxNQUFNLEdBQUc7QUFDZixhQUFTLEtBQUssS0FBSyxRQUFRLEdBQUc7QUFBQSxFQUNoQyxXQUFXLE9BQTJDO0FBQ3BELHNCQUFrQixRQUFRLE1BQU0sR0FBRztBQUFBLEVBQ3JDO0FBQ0EsUUFBTSxXQUFXLEtBQUssS0FBSyxRQUFRLEdBQUc7QUFDdEMsU0FBTyxJQUFJLEtBQUssS0FBSztBQUNyQixNQUFJLENBQUMsUUFBUTtBQUNYLFlBQVEsUUFBUSxPQUFPLEtBQUssS0FBSztBQUFBLEVBQ25DLFdBQVcsV0FBVyxPQUFPLFFBQVEsR0FBRztBQUN0QyxZQUFRLFFBQVEsT0FBTyxLQUFLLE9BQU8sUUFBUTtBQUFBLEVBQzdDO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxZQUFZLEtBQUs7QUFDeEIsUUFBTSxTQUFTLE1BQU0sSUFBSTtBQUN6QixRQUFNLEVBQUUsS0FBSyxNQUFNLEtBQUssS0FBSyxJQUFJLFNBQVMsTUFBTTtBQUNoRCxNQUFJLFNBQVMsS0FBSyxLQUFLLFFBQVEsR0FBRztBQUNsQyxNQUFJLENBQUMsUUFBUTtBQUNYLFVBQU0sTUFBTSxHQUFHO0FBQ2YsYUFBUyxLQUFLLEtBQUssUUFBUSxHQUFHO0FBQUEsRUFDaEMsV0FBVyxPQUEyQztBQUNwRCxzQkFBa0IsUUFBUSxNQUFNLEdBQUc7QUFBQSxFQUNyQztBQUNBLFFBQU0sV0FBVyxPQUFPLEtBQUssS0FBSyxRQUFRLEdBQUcsSUFBSTtBQUNqRCxRQUFNLFNBQVMsT0FBTyxPQUFPLEdBQUc7QUFDaEMsTUFBSSxRQUFRO0FBQ1YsWUFBUSxRQUFRLFVBQVUsS0FBSyxRQUFRLFFBQVE7QUFBQSxFQUNqRDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsUUFBUTtBQUNmLFFBQU0sU0FBUyxNQUFNLElBQUk7QUFDekIsUUFBTSxXQUFXLE9BQU8sU0FBUztBQUNqQyxRQUFNLFlBQVksUUFBNEMsTUFBTSxNQUFNLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJO0FBQ2xILFFBQU0sU0FBUyxPQUFPLE1BQU07QUFDNUIsTUFBSSxVQUFVO0FBQ1osWUFBUSxRQUFRLFNBQVMsUUFBUSxRQUFRLFNBQVM7QUFBQSxFQUNwRDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsY0FBY0EsYUFBWUMsWUFBVztBQUM1QyxTQUFPLFNBQVMsUUFBUSxVQUFVLFNBQVM7QUFDekMsVUFBTSxXQUFXO0FBQ2pCLFVBQU0sU0FBUyxTQUFTO0FBQ3hCLFVBQU0sWUFBWSxNQUFNLE1BQU07QUFDOUIsVUFBTSxPQUFPQSxhQUFZLFlBQVlELGNBQWEsYUFBYTtBQUMvRCxLQUFDQSxlQUFjLE1BQU0sV0FBVyxXQUFXLFdBQVc7QUFDdEQsV0FBTyxPQUFPLFFBQVEsQ0FBQyxPQUFPLFFBQVE7QUFDcEMsYUFBTyxTQUFTLEtBQUssU0FBUyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsR0FBRyxRQUFRO0FBQUEsSUFDaEUsQ0FBQztBQUFBLEVBQ0g7QUFDRjtBQUNBLFNBQVMscUJBQXFCLFFBQVFBLGFBQVlDLFlBQVc7QUFDM0QsU0FBTyxZQUFZLE1BQU07QUFDdkIsVUFBTSxTQUFTLEtBQUs7QUFDcEIsVUFBTSxZQUFZLE1BQU0sTUFBTTtBQUM5QixVQUFNLGNBQWMsTUFBTSxTQUFTO0FBQ25DLFVBQU0sU0FBUyxXQUFXLGFBQWEsV0FBVyxPQUFPLFlBQVk7QUFDckUsVUFBTSxZQUFZLFdBQVcsVUFBVTtBQUN2QyxVQUFNLGdCQUFnQixPQUFPLFFBQVEsR0FBRyxJQUFJO0FBQzVDLFVBQU0sT0FBT0EsYUFBWSxZQUFZRCxjQUFhLGFBQWE7QUFDL0QsS0FBQ0EsZUFBYztBQUFBLE1BQ2I7QUFBQSxNQUNBO0FBQUEsTUFDQSxZQUFZLHNCQUFzQjtBQUFBLElBQ3BDO0FBQ0EsV0FBTztBQUFBLE1BRUwsT0FBTztBQUNMLGNBQU0sRUFBRSxPQUFPLEtBQUssSUFBSSxjQUFjLEtBQUs7QUFDM0MsZUFBTyxPQUFPLEVBQUUsT0FBTyxLQUFLLElBQUk7QUFBQSxVQUM5QixPQUFPLFNBQVMsQ0FBQyxLQUFLLE1BQU0sRUFBRSxHQUFHLEtBQUssTUFBTSxFQUFFLENBQUMsSUFBSSxLQUFLLEtBQUs7QUFBQSxVQUM3RDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsTUFFQSxDQUFDLE9BQU8sWUFBWTtBQUNsQixlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLHFCQUFxQixNQUFNO0FBQ2xDLFNBQU8sWUFBWSxNQUFNO0FBQ3ZCLFFBQUksT0FBMkM7QUFDN0MsWUFBTSxNQUFNLEtBQUssS0FBSyxXQUFXLEtBQUssU0FBUztBQUMvQyxjQUFRO0FBQUEsUUFDTixHQUFHLFdBQVcsSUFBSSxlQUFlO0FBQUEsUUFDakMsTUFBTSxJQUFJO0FBQUEsTUFDWjtBQUFBLElBQ0Y7QUFDQSxXQUFPLFNBQVMsV0FBVyxRQUFRO0FBQUEsRUFDckM7QUFDRjtBQUNBLFNBQVMseUJBQXlCO0FBQ2hDLFFBQU0sMkJBQTJCO0FBQUEsSUFDL0IsSUFBSSxLQUFLO0FBQ1AsYUFBTyxJQUFJLE1BQU0sR0FBRztBQUFBLElBQ3RCO0FBQUEsSUFDQSxJQUFJLE9BQU87QUFDVCxhQUFPLEtBQUssSUFBSTtBQUFBLElBQ2xCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxRQUFRO0FBQUEsSUFDUjtBQUFBLElBQ0EsU0FBUyxjQUFjLE9BQU8sS0FBSztBQUFBLEVBQ3JDO0FBQ0EsUUFBTSwyQkFBMkI7QUFBQSxJQUMvQixJQUFJLEtBQUs7QUFDUCxhQUFPLElBQUksTUFBTSxLQUFLLE9BQU8sSUFBSTtBQUFBLElBQ25DO0FBQUEsSUFDQSxJQUFJLE9BQU87QUFDVCxhQUFPLEtBQUssSUFBSTtBQUFBLElBQ2xCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxRQUFRO0FBQUEsSUFDUjtBQUFBLElBQ0EsU0FBUyxjQUFjLE9BQU8sSUFBSTtBQUFBLEVBQ3BDO0FBQ0EsUUFBTSw0QkFBNEI7QUFBQSxJQUNoQyxJQUFJLEtBQUs7QUFDUCxhQUFPLElBQUksTUFBTSxLQUFLLElBQUk7QUFBQSxJQUM1QjtBQUFBLElBQ0EsSUFBSSxPQUFPO0FBQ1QsYUFBTyxLQUFLLE1BQU0sSUFBSTtBQUFBLElBQ3hCO0FBQUEsSUFDQSxJQUFJLEtBQUs7QUFDUCxhQUFPLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSTtBQUFBLElBQ2pDO0FBQUEsSUFDQSxLQUFLLHFCQUFxQixLQUFLO0FBQUEsSUFDL0IsS0FBSyxxQkFBcUIsS0FBSztBQUFBLElBQy9CLFFBQVEscUJBQXFCLFFBQVE7QUFBQSxJQUNyQyxPQUFPLHFCQUFxQixPQUFPO0FBQUEsSUFDbkMsU0FBUyxjQUFjLE1BQU0sS0FBSztBQUFBLEVBQ3BDO0FBQ0EsUUFBTSxtQ0FBbUM7QUFBQSxJQUN2QyxJQUFJLEtBQUs7QUFDUCxhQUFPLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSTtBQUFBLElBQ2xDO0FBQUEsSUFDQSxJQUFJLE9BQU87QUFDVCxhQUFPLEtBQUssTUFBTSxJQUFJO0FBQUEsSUFDeEI7QUFBQSxJQUNBLElBQUksS0FBSztBQUNQLGFBQU8sSUFBSSxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQUEsSUFDakM7QUFBQSxJQUNBLEtBQUsscUJBQXFCLEtBQUs7QUFBQSxJQUMvQixLQUFLLHFCQUFxQixLQUFLO0FBQUEsSUFDL0IsUUFBUSxxQkFBcUIsUUFBUTtBQUFBLElBQ3JDLE9BQU8scUJBQXFCLE9BQU87QUFBQSxJQUNuQyxTQUFTLGNBQWMsTUFBTSxJQUFJO0FBQUEsRUFDbkM7QUFDQSxRQUFNLGtCQUFrQixDQUFDLFFBQVEsVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUNyRSxrQkFBZ0IsUUFBUSxDQUFDLFdBQVc7QUFDbEMsNkJBQXlCLFVBQVU7QUFBQSxNQUNqQztBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLDhCQUEwQixVQUFVO0FBQUEsTUFDbEM7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFDQSw2QkFBeUIsVUFBVTtBQUFBLE1BQ2pDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EscUNBQWlDLFVBQVU7QUFBQSxNQUN6QztBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNELFNBQU87QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTTtBQUFBLEVBQ0o7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRixJQUFvQix1Q0FBdUI7QUFDM0MsU0FBUyw0QkFBNEJBLGFBQVksU0FBUztBQUN4RCxRQUFNLG1CQUFtQixVQUFVQSxjQUFhLGtDQUFrQywwQkFBMEJBLGNBQWEsMkJBQTJCO0FBQ3BKLFNBQU8sQ0FBQyxRQUFRLEtBQUssYUFBYTtBQUNoQyxRQUFJLFFBQVEsa0JBQWtCO0FBQzVCLGFBQU8sQ0FBQ0E7QUFBQSxJQUNWLFdBQVcsUUFBUSxrQkFBa0I7QUFDbkMsYUFBT0E7QUFBQSxJQUNULFdBQVcsUUFBUSxXQUFXO0FBQzVCLGFBQU87QUFBQSxJQUNUO0FBQ0EsV0FBTyxRQUFRO0FBQUEsTUFDYixPQUFPLGtCQUFrQixHQUFHLEtBQUssT0FBTyxTQUFTLG1CQUFtQjtBQUFBLE1BQ3BFO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLDRCQUE0QjtBQUFBLEVBQ2hDLEtBQXFCLDRDQUE0QixPQUFPLEtBQUs7QUFDL0Q7QUFDQSxJQUFNLDRCQUE0QjtBQUFBLEVBQ2hDLEtBQXFCLDRDQUE0QixPQUFPLElBQUk7QUFDOUQ7QUFDQSxJQUFNLDZCQUE2QjtBQUFBLEVBQ2pDLEtBQXFCLDRDQUE0QixNQUFNLEtBQUs7QUFDOUQ7QUFjQSxJQUFNLGNBQThCLG9CQUFJLFFBQVE7QUFDaEQsSUFBTSxxQkFBcUMsb0JBQUksUUFBUTtBQUN2RCxJQUFNLGNBQThCLG9CQUFJLFFBQVE7QUFDaEQsSUFBTSxxQkFBcUMsb0JBQUksUUFBUTtBQUN2RCxTQUFTLGNBQWMsU0FBUztBQUM5QixVQUFRO0FBQUEsU0FDRDtBQUFBLFNBQ0E7QUFDSCxhQUFPO0FBQUEsU0FDSjtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUNILGFBQU87QUFBQTtBQUVQLGFBQU87QUFBQTtBQUViO0FBQ0EsU0FBUyxjQUFjLE9BQU87QUFDNUIsU0FBTyxNQUFNLGVBQWUsQ0FBQyxPQUFPLGFBQWEsS0FBSyxJQUFJLElBQWtCLGNBQWMsVUFBVSxLQUFLLENBQUM7QUFDNUc7QUFDQSxTQUFTLFNBQVMsUUFBUTtBQUN4QixNQUFJLFdBQVcsTUFBTSxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxnQkFBZ0IsUUFBUTtBQUMvQixTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFNBQVMsUUFBUTtBQUN4QixTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUFVQSxTQUFTLHFCQUFxQixRQUFRLGFBQWEsY0FBYyxvQkFBb0IsVUFBVTtBQUM3RixNQUFJLENBQUMsU0FBUyxNQUFNLEdBQUc7QUFDckIsUUFBSSxPQUEyQztBQUM3QyxjQUFRLEtBQUssa0NBQWtDLE9BQU8sTUFBTSxHQUFHO0FBQUEsSUFDakU7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksT0FBTyxjQUFjLEVBQUUsZUFBZSxPQUFPLG9CQUFvQjtBQUNuRSxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sZ0JBQWdCLFNBQVMsSUFBSSxNQUFNO0FBQ3pDLE1BQUksZUFBZTtBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sYUFBYSxjQUFjLE1BQU07QUFDdkMsTUFBSSxlQUFlLEdBQWlCO0FBQ2xDLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxRQUFRLElBQUk7QUFBQSxJQUNoQjtBQUFBLElBQ0EsZUFBZSxJQUFxQixxQkFBcUI7QUFBQSxFQUMzRDtBQUNBLFdBQVMsSUFBSSxRQUFRLEtBQUs7QUFDMUIsU0FBTztBQUNUO0FBQ0EsU0FBUyxXQUFXLE9BQU87QUFDekIsTUFBSSxXQUFXLEtBQUssR0FBRztBQUNyQixXQUFPLFdBQVcsTUFBTSxVQUFVO0FBQUEsRUFDcEM7QUFDQSxTQUFPLENBQUMsRUFBRSxTQUFTLE1BQU07QUFDM0I7QUFDQSxTQUFTLFdBQVcsT0FBTztBQUN6QixTQUFPLENBQUMsRUFBRSxTQUFTLE1BQU07QUFDM0I7QUFDQSxTQUFTLFVBQVUsT0FBTztBQUN4QixTQUFPLENBQUMsRUFBRSxTQUFTLE1BQU07QUFDM0I7QUFDQSxTQUFTLFFBQVEsT0FBTztBQUN0QixTQUFPLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSztBQUM5QztBQUNBLFNBQVMsTUFBTSxVQUFVO0FBQ3ZCLFFBQU0sTUFBTSxZQUFZLFNBQVM7QUFDakMsU0FBTyxNQUFNLE1BQU0sR0FBRyxJQUFJO0FBQzVCO0FBQ0EsU0FBUyxRQUFRLE9BQU87QUFDdEIsTUFBSSxPQUFPLFlBQVksSUFBSTtBQUMzQixTQUFPO0FBQ1Q7QUFDQSxJQUFNLGFBQWEsQ0FBQyxVQUFVLFNBQVMsS0FBSyxJQUFJLFNBQVMsS0FBSyxJQUFJO0FBQ2xFLElBQU0sYUFBYSxDQUFDLFVBQVUsU0FBUyxLQUFLLElBQUksU0FBUyxLQUFLLElBQUk7QUFFbEUsU0FBUyxjQUFjLE1BQU07QUFDM0IsTUFBSSxlQUFlLGNBQWM7QUFDL0IsV0FBTyxNQUFNLElBQUk7QUFDakIsUUFBSSxPQUEyQztBQUM3QyxtQkFBYSxLQUFLLFFBQVEsS0FBSyxNQUFNLFVBQVUsSUFBSTtBQUFBLFFBQ2pELFFBQVE7QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQSxNQUNQLENBQUM7QUFBQSxJQUNILE9BQU87QUFDTCxtQkFBYSxLQUFLLFFBQVEsS0FBSyxNQUFNLFVBQVUsRUFBRTtBQUFBLElBQ25EO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxnQkFBZ0IsTUFBTSxRQUFRO0FBQ3JDLFNBQU8sTUFBTSxJQUFJO0FBQ2pCLFFBQU0sTUFBTSxLQUFLO0FBQ2pCLE1BQUksS0FBSztBQUNQLFFBQUksT0FBMkM7QUFDN0MscUJBQWUsS0FBSztBQUFBLFFBQ2xCLFFBQVE7QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQSxRQUNMLFVBQVU7QUFBQSxNQUNaLENBQUM7QUFBQSxJQUNILE9BQU87QUFDTCxxQkFBZSxHQUFHO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLE1BQU0sR0FBRztBQUNoQixTQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsY0FBYztBQUNqQztBQUNBLFNBQVMsSUFBSSxPQUFPO0FBQ2xCLFNBQU8sVUFBVSxPQUFPLEtBQUs7QUFDL0I7QUFJQSxTQUFTLFVBQVUsVUFBVSxTQUFTO0FBQ3BDLE1BQUksTUFBTSxRQUFRLEdBQUc7QUFDbkIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPLElBQUksUUFBUSxVQUFVLE9BQU87QUFDdEM7QUFDQSxJQUFNLFVBQU4sTUFBYztBQUFBLEVBQ1osWUFBWSxPQUFPLGVBQWU7QUFDaEMsU0FBSyxnQkFBZ0I7QUFDckIsU0FBSyxNQUFNO0FBQ1gsU0FBSyxZQUFZO0FBQ2pCLFNBQUssWUFBWSxnQkFBZ0IsUUFBUSxNQUFNLEtBQUs7QUFDcEQsU0FBSyxTQUFTLGdCQUFnQixRQUFRLFdBQVcsS0FBSztBQUFBLEVBQ3hEO0FBQUEsRUFDQSxJQUFJLFFBQVE7QUFDVixrQkFBYyxJQUFJO0FBQ2xCLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFBQSxFQUNBLElBQUksTUFBTSxRQUFRO0FBQ2hCLFVBQU0saUJBQWlCLEtBQUssaUJBQWlCLFVBQVUsTUFBTSxLQUFLLFdBQVcsTUFBTTtBQUNuRixhQUFTLGlCQUFpQixTQUFTLE1BQU0sTUFBTTtBQUMvQyxRQUFJLFdBQVcsUUFBUSxLQUFLLFNBQVMsR0FBRztBQUN0QyxXQUFLLFlBQVk7QUFDakIsV0FBSyxTQUFTLGlCQUFpQixTQUFTLFdBQVcsTUFBTTtBQUN6RCxzQkFBZ0IsTUFBTSxNQUFNO0FBQUEsSUFDOUI7QUFBQSxFQUNGO0FBQ0Y7QUFJQSxTQUFTLE1BQU0sTUFBTTtBQUNuQixTQUFPLE1BQU0sSUFBSSxJQUFJLEtBQUssUUFBUTtBQUNwQztBQUlBLElBQU0sd0JBQXdCO0FBQUEsRUFDNUIsS0FBSyxDQUFDLFFBQVEsS0FBSyxhQUFhLE1BQU0sUUFBUSxJQUFJLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4RSxLQUFLLENBQUMsUUFBUSxLQUFLLE9BQU8sYUFBYTtBQUNyQyxVQUFNLFdBQVcsT0FBTztBQUN4QixRQUFJLE1BQU0sUUFBUSxLQUFLLENBQUMsTUFBTSxLQUFLLEdBQUc7QUFDcEMsZUFBUyxRQUFRO0FBQ2pCLGFBQU87QUFBQSxJQUNULE9BQU87QUFDTCxhQUFPLFFBQVEsSUFBSSxRQUFRLEtBQUssT0FBTyxRQUFRO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFVBQVUsZ0JBQWdCO0FBQ2pDLFNBQU8sV0FBVyxjQUFjLElBQUksaUJBQWlCLElBQUksTUFBTSxnQkFBZ0IscUJBQXFCO0FBQ3RHO0FBZ0ZBLElBQU0sa0JBQU4sTUFBc0I7QUFBQSxFQUNwQixZQUFZLFFBQVEsU0FBU0UsYUFBWSxPQUFPO0FBQzlDLFNBQUssVUFBVTtBQUNmLFNBQUssTUFBTTtBQUNYLFNBQUssWUFBWTtBQUNqQixTQUFLLG9CQUFvQjtBQUN6QixTQUFLLFNBQVM7QUFDZCxTQUFLLFNBQVMsSUFBSSxlQUFlLFFBQVEsTUFBTTtBQUM3QyxVQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2hCLGFBQUssU0FBUztBQUNkLHdCQUFnQixJQUFJO0FBQUEsTUFDdEI7QUFBQSxJQUNGLENBQUM7QUFDRCxTQUFLLE9BQU8sV0FBVztBQUN2QixTQUFLLE9BQU8sU0FBUyxLQUFLLGFBQWEsQ0FBQztBQUN4QyxTQUFLLG9CQUFvQkE7QUFBQSxFQUMzQjtBQUFBLEVBQ0EsSUFBSSxRQUFRO0FBQ1YsVUFBTUMsUUFBTyxNQUFNLElBQUk7QUFDdkIsa0JBQWNBLEtBQUk7QUFDbEIsUUFBSUEsTUFBSyxVQUFVLENBQUNBLE1BQUssWUFBWTtBQUNuQyxNQUFBQSxNQUFLLFNBQVM7QUFDZCxNQUFBQSxNQUFLLFNBQVNBLE1BQUssT0FBTyxJQUFJO0FBQUEsSUFDaEM7QUFDQSxXQUFPQSxNQUFLO0FBQUEsRUFDZDtBQUFBLEVBQ0EsSUFBSSxNQUFNLFVBQVU7QUFDbEIsU0FBSyxRQUFRLFFBQVE7QUFBQSxFQUN2QjtBQUNGO0FBQ0EsU0FBUyxTQUFTLGlCQUFpQixjQUFjLFFBQVEsT0FBTztBQUM5RCxNQUFJO0FBQ0osTUFBSTtBQUNKLFFBQU0sYUFBYSxXQUFXLGVBQWU7QUFDN0MsTUFBSSxZQUFZO0FBQ2QsYUFBUztBQUNULGFBQVMsUUFBNEMsTUFBTTtBQUN6RCxjQUFRLEtBQUssb0RBQW9EO0FBQUEsSUFDbkUsSUFBSTtBQUFBLEVBQ04sT0FBTztBQUNMLGFBQVMsZ0JBQWdCO0FBQ3pCLGFBQVMsZ0JBQWdCO0FBQUEsRUFDM0I7QUFDQSxRQUFNLE9BQU8sSUFBSSxnQkFBZ0IsUUFBUSxRQUFRLGNBQWMsQ0FBQyxRQUFRLEtBQUs7QUFDN0UsTUFBSSxPQUFxRTtBQUN2RSxTQUFLLE9BQU8sVUFBVSxhQUFhO0FBQ25DLFNBQUssT0FBTyxZQUFZLGFBQWE7QUFBQSxFQUN2QztBQUNBLFNBQU87QUFDVDs7O0FDaHBDQSxJQUFNLFFBQVEsQ0FBQztBQU9mLFNBQVMsS0FBSyxRQUFRLE1BQU07QUFDMUIsTUFBSTtBQUNGO0FBQ0YsZ0JBQWM7QUFDZCxRQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU0sTUFBTSxTQUFTLEdBQUcsWUFBWTtBQUNwRSxRQUFNLGlCQUFpQixZQUFZLFNBQVMsV0FBVyxPQUFPO0FBQzlELFFBQU0sUUFBUSxrQkFBa0I7QUFDaEMsTUFBSSxnQkFBZ0I7QUFDbEI7QUFBQSxNQUNFO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsUUFDRSxNQUFNLEtBQUssS0FBSyxFQUFFO0FBQUEsUUFDbEIsWUFBWSxTQUFTO0FBQUEsUUFDckIsTUFBTTtBQUFBLFVBQ0osQ0FBQyxFQUFFLE1BQU0sTUFBTSxPQUFPLG9CQUFvQixVQUFVLE1BQU0sSUFBSTtBQUFBLFFBQ2hFLEVBQUUsS0FBSyxJQUFJO0FBQUEsUUFDWDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBQ0wsVUFBTSxXQUFXLENBQUMsZUFBZSxPQUFPLEdBQUcsSUFBSTtBQUMvQyxRQUFJLE1BQU0sVUFDVixNQUFNO0FBQ0osZUFBUyxLQUFLO0FBQUEsR0FDakIsR0FBRyxZQUFZLEtBQUssQ0FBQztBQUFBLElBQ3BCO0FBQ0EsWUFBUSxLQUFLLEdBQUcsUUFBUTtBQUFBLEVBQzFCO0FBQ0EsZ0JBQWM7QUFDaEI7QUFDQSxTQUFTLG9CQUFvQjtBQUMzQixNQUFJLGVBQWUsTUFBTSxNQUFNLFNBQVM7QUFDeEMsTUFBSSxDQUFDLGNBQWM7QUFDakIsV0FBTyxDQUFDO0FBQUEsRUFDVjtBQUNBLFFBQU0sa0JBQWtCLENBQUM7QUFDekIsU0FBTyxjQUFjO0FBQ25CLFVBQU0sT0FBTyxnQkFBZ0I7QUFDN0IsUUFBSSxRQUFRLEtBQUssVUFBVSxjQUFjO0FBQ3ZDLFdBQUs7QUFBQSxJQUNQLE9BQU87QUFDTCxzQkFBZ0IsS0FBSztBQUFBLFFBQ25CLE9BQU87QUFBQSxRQUNQLGNBQWM7QUFBQSxNQUNoQixDQUFDO0FBQUEsSUFDSDtBQUNBLFVBQU0saUJBQWlCLGFBQWEsYUFBYSxhQUFhLFVBQVU7QUFDeEUsbUJBQWUsa0JBQWtCLGVBQWU7QUFBQSxFQUNsRDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsWUFBWSxPQUFPO0FBQzFCLFFBQU0sT0FBTyxDQUFDO0FBQ2QsUUFBTSxRQUFRLENBQUMsT0FBTyxNQUFNO0FBQzFCLFNBQUssS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLENBQ2hDLEdBQUcsR0FBRyxpQkFBaUIsS0FBSyxDQUFDO0FBQUEsRUFDNUIsQ0FBQztBQUNELFNBQU87QUFDVDtBQUNBLFNBQVMsaUJBQWlCLEVBQUUsT0FBTyxhQUFhLEdBQUc7QUFDakQsUUFBTSxVQUFVLGVBQWUsSUFBSSxRQUFRLGtDQUFrQztBQUM3RSxRQUFNLFNBQVMsTUFBTSxZQUFZLE1BQU0sVUFBVSxVQUFVLE9BQU87QUFDbEUsUUFBTSxPQUFPLFFBQVE7QUFBQSxJQUNuQixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLFFBQVEsTUFBTTtBQUNwQixTQUFPLE1BQU0sUUFBUSxDQUFDLE1BQU0sR0FBRyxZQUFZLE1BQU0sS0FBSyxHQUFHLEtBQUssSUFBSSxDQUFDLE9BQU8sS0FBSztBQUNqRjtBQUNBLFNBQVMsWUFBWSxPQUFPO0FBQzFCLFFBQU0sTUFBTSxDQUFDO0FBQ2IsUUFBTSxPQUFPLE9BQU8sS0FBSyxLQUFLO0FBQzlCLE9BQUssTUFBTSxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsUUFBUTtBQUNoQyxRQUFJLEtBQUssR0FBRyxXQUFXLEtBQUssTUFBTSxJQUFJLENBQUM7QUFBQSxFQUN6QyxDQUFDO0FBQ0QsTUFBSSxLQUFLLFNBQVMsR0FBRztBQUNuQixRQUFJLEtBQUssTUFBTTtBQUFBLEVBQ2pCO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxXQUFXLEtBQUssT0FBTyxLQUFLO0FBQ25DLE1BQUksU0FBUyxLQUFLLEdBQUc7QUFDbkIsWUFBUSxLQUFLLFVBQVUsS0FBSztBQUM1QixXQUFPLE1BQU0sUUFBUSxDQUFDLEdBQUcsT0FBTyxPQUFPO0FBQUEsRUFDekMsV0FBVyxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVUsYUFBYSxTQUFTLE1BQU07QUFDbkYsV0FBTyxNQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU8sT0FBTztBQUFBLEVBQ3pDLFdBQVcsTUFBTSxLQUFLLEdBQUc7QUFDdkIsWUFBUSxXQUFXLEtBQUssTUFBTSxNQUFNLEtBQUssR0FBRyxJQUFJO0FBQ2hELFdBQU8sTUFBTSxRQUFRLENBQUMsR0FBRyxZQUFZLE9BQU8sR0FBRztBQUFBLEVBQ2pELFdBQVcsV0FBVyxLQUFLLEdBQUc7QUFDNUIsV0FBTyxDQUFDLEdBQUcsU0FBUyxNQUFNLE9BQU8sSUFBSSxNQUFNLFVBQVUsSUFBSTtBQUFBLEVBQzNELE9BQU87QUFDTCxZQUFRLE1BQU0sS0FBSztBQUNuQixXQUFPLE1BQU0sUUFBUSxDQUFDLEdBQUcsUUFBUSxLQUFLO0FBQUEsRUFDeEM7QUFDRjtBQTRDQSxTQUFTLHNCQUFzQixJQUFJLFVBQVUsTUFBTSxNQUFNO0FBQ3ZELE1BQUk7QUFDSixNQUFJO0FBQ0YsVUFBTSxPQUFPLEdBQUcsR0FBRyxJQUFJLElBQUksR0FBRztBQUFBLEVBQ2hDLFNBQVMsS0FBUDtBQUNBLGdCQUFZLEtBQUssVUFBVSxJQUFJO0FBQUEsRUFDakM7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLDJCQUEyQixJQUFJLFVBQVUsTUFBTSxNQUFNO0FBQzVELE1BQUksV0FBVyxFQUFFLEdBQUc7QUFDbEIsVUFBTSxNQUFNLHNCQUFzQixJQUFJLFVBQVUsTUFBTSxJQUFJO0FBQzFELFFBQUksT0FBTyxVQUFVLEdBQUcsR0FBRztBQUN6QixVQUFJLE1BQU0sQ0FBQyxRQUFRO0FBQ2pCLG9CQUFZLEtBQUssVUFBVSxJQUFJO0FBQUEsTUFDakMsQ0FBQztBQUFBLElBQ0g7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sU0FBUyxDQUFDO0FBQ2hCLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxRQUFRLEtBQUs7QUFDbEMsV0FBTyxLQUFLLDJCQUEyQixHQUFHLElBQUksVUFBVSxNQUFNLElBQUksQ0FBQztBQUFBLEVBQ3JFO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxZQUFZLEtBQUssVUFBVSxNQUFNLGFBQWEsTUFBTTtBQUMzRCxRQUFNLGVBQWUsV0FBVyxTQUFTLFFBQVE7QUFDakQsTUFBSSxVQUFVO0FBQ1osUUFBSSxNQUFNLFNBQVM7QUFDbkIsVUFBTSxrQkFBa0IsU0FBUztBQUNqQyxVQUFNLFlBQVksUUFBNEMsaUJBQWlCLFFBQVE7QUFDdkYsV0FBTyxLQUFLO0FBQ1YsWUFBTSxxQkFBcUIsSUFBSTtBQUMvQixVQUFJLG9CQUFvQjtBQUN0QixpQkFBUyxJQUFJLEdBQUcsSUFBSSxtQkFBbUIsUUFBUSxLQUFLO0FBQ2xELGNBQUksbUJBQW1CLEdBQUcsS0FBSyxpQkFBaUIsU0FBUyxNQUFNLE9BQU87QUFDcEU7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxZQUFNLElBQUk7QUFBQSxJQUNaO0FBQ0EsVUFBTSxrQkFBa0IsU0FBUyxXQUFXLE9BQU87QUFDbkQsUUFBSSxpQkFBaUI7QUFDbkI7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLENBQUMsS0FBSyxpQkFBaUIsU0FBUztBQUFBLE1BQ2xDO0FBQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFdBQVMsS0FBSyxNQUFNLGNBQWMsVUFBVTtBQUM5QztBQUNBLFNBQVMsU0FBUyxLQUFLLE1BQU0sY0FBYyxhQUFhLE1BQU07QUFDNUQsTUFBSSxPQUEyQztBQUM3QyxVQUFNLE9BQU8saUJBQWlCO0FBQzlCLFFBQUksY0FBYztBQUNoQix5QkFBbUIsWUFBWTtBQUFBLElBQ2pDO0FBQ0EsU0FBSyxrQkFBa0IsT0FBTyx3QkFBd0IsU0FBUyxJQUFJO0FBQ25FLFFBQUksY0FBYztBQUNoQix3QkFBa0I7QUFBQSxJQUNwQjtBQUNBLFFBQUksWUFBWTtBQUNkLFlBQU07QUFBQSxJQUNSLE9BQU87QUFDTCxjQUFRLE1BQU0sR0FBRztBQUFBLElBQ25CO0FBQUEsRUFDRixPQUFPO0FBQ0wsWUFBUSxNQUFNLEdBQUc7QUFBQSxFQUNuQjtBQUNGO0FBRUEsSUFBSSxhQUFhO0FBQ2pCLElBQUksaUJBQWlCO0FBQ3JCLElBQU0sUUFBUSxDQUFDO0FBQ2YsSUFBSSxhQUFhO0FBQ2pCLElBQU0sc0JBQXNCLENBQUM7QUFDN0IsSUFBSSxxQkFBcUI7QUFDekIsSUFBSSxpQkFBaUI7QUFDckIsSUFBTSxrQkFBa0Msd0JBQVEsUUFBUTtBQUN4RCxJQUFJLHNCQUFzQjtBQUUxQixTQUFTLFNBQVMsSUFBSTtBQUNwQixRQUFNQyxLQUFJLHVCQUF1QjtBQUNqQyxTQUFPLEtBQUtBLEdBQUUsS0FBSyxPQUFPLEdBQUcsS0FBSyxJQUFJLElBQUksRUFBRSxJQUFJQTtBQUNsRDtBQUNBLFNBQVMsbUJBQW1CLElBQUk7QUFDOUIsTUFBSSxRQUFRLGFBQWE7QUFDekIsTUFBSSxNQUFNLE1BQU07QUFDaEIsU0FBTyxRQUFRLEtBQUs7QUFDbEIsVUFBTSxTQUFTLFFBQVEsUUFBUTtBQUMvQixVQUFNLGNBQWMsTUFBTSxNQUFNLE9BQU87QUFDdkMsa0JBQWMsS0FBSyxRQUFRLFNBQVMsSUFBSSxNQUFNO0FBQUEsRUFDaEQ7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLFNBQVMsS0FBSztBQUNyQixNQUFJLENBQUMsTUFBTSxVQUFVLENBQUMsTUFBTTtBQUFBLElBQzFCO0FBQUEsSUFDQSxjQUFjLElBQUksZUFBZSxhQUFhLElBQUk7QUFBQSxFQUNwRCxHQUFHO0FBQ0QsUUFBSSxJQUFJLE1BQU0sTUFBTTtBQUNsQixZQUFNLEtBQUssR0FBRztBQUFBLElBQ2hCLE9BQU87QUFDTCxZQUFNLE9BQU8sbUJBQW1CLElBQUksRUFBRSxHQUFHLEdBQUcsR0FBRztBQUFBLElBQ2pEO0FBQ0EsZUFBVztBQUFBLEVBQ2I7QUFDRjtBQUNBLFNBQVMsYUFBYTtBQUNwQixNQUFJLENBQUMsY0FBYyxDQUFDLGdCQUFnQjtBQUNsQyxxQkFBaUI7QUFDakIsMEJBQXNCLGdCQUFnQixLQUFLLFNBQVM7QUFBQSxFQUN0RDtBQUNGO0FBQ0EsU0FBUyxjQUFjLEtBQUs7QUFDMUIsUUFBTSxJQUFJLE1BQU0sUUFBUSxHQUFHO0FBQzNCLE1BQUksSUFBSSxZQUFZO0FBQ2xCLFVBQU0sT0FBTyxHQUFHLENBQUM7QUFBQSxFQUNuQjtBQUNGO0FBQ0EsU0FBUyxpQkFBaUIsSUFBSTtBQUM1QixNQUFJLENBQUMsUUFBUSxFQUFFLEdBQUc7QUFDaEIsUUFBSSxDQUFDLHNCQUFzQixDQUFDLG1CQUFtQjtBQUFBLE1BQzdDO0FBQUEsTUFDQSxHQUFHLGVBQWUsaUJBQWlCLElBQUk7QUFBQSxJQUN6QyxHQUFHO0FBQ0QsMEJBQW9CLEtBQUssRUFBRTtBQUFBLElBQzdCO0FBQUEsRUFDRixPQUFPO0FBQ0wsd0JBQW9CLEtBQUssR0FBRyxFQUFFO0FBQUEsRUFDaEM7QUFDQSxhQUFXO0FBQ2I7QUFDQSxTQUFTLGlCQUFpQixNQUFNLElBQUksYUFBYSxhQUFhLElBQUksR0FBRztBQUNuRSxNQUFJLE9BQTJDO0FBQzdDLFdBQU8sUUFBd0Isb0JBQUksSUFBSTtBQUFBLEVBQ3pDO0FBQ0EsU0FBTyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQzVCLFVBQU0sS0FBSyxNQUFNO0FBQ2pCLFFBQUksTUFBTSxHQUFHLEtBQUs7QUFDaEIsVUFBSSxPQUE4RTtBQUNoRjtBQUFBLE1BQ0Y7QUFDQSxZQUFNLE9BQU8sR0FBRyxDQUFDO0FBQ2pCO0FBQ0EsU0FBRztBQUFBLElBQ0w7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLGtCQUFrQixNQUFNO0FBQy9CLE1BQUksb0JBQW9CLFFBQVE7QUFDOUIsVUFBTSxVQUFVLENBQUMsR0FBRyxJQUFJLElBQUksbUJBQW1CLENBQUM7QUFDaEQsd0JBQW9CLFNBQVM7QUFDN0IsUUFBSSxvQkFBb0I7QUFDdEIseUJBQW1CLEtBQUssR0FBRyxPQUFPO0FBQ2xDO0FBQUEsSUFDRjtBQUNBLHlCQUFxQjtBQUNyQixRQUFJLE9BQTJDO0FBQzdDLGFBQU8sUUFBd0Isb0JBQUksSUFBSTtBQUFBLElBQ3pDO0FBQ0EsdUJBQW1CLEtBQUssQ0FBQyxHQUFHLE1BQU0sTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUM7QUFDckQsU0FBSyxpQkFBaUIsR0FBRyxpQkFBaUIsbUJBQW1CLFFBQVEsa0JBQWtCO0FBQ3JGLFVBQUksT0FBOEc7QUFDaEg7QUFBQSxNQUNGO0FBQ0EseUJBQW1CLGdCQUFnQjtBQUFBLElBQ3JDO0FBQ0EseUJBQXFCO0FBQ3JCLHFCQUFpQjtBQUFBLEVBQ25CO0FBQ0Y7QUFDQSxJQUFNLFFBQVEsQ0FBQyxRQUFRLElBQUksTUFBTSxPQUFPLFdBQVcsSUFBSTtBQUN2RCxJQUFNLGFBQWEsQ0FBQyxHQUFHLE1BQU07QUFDM0IsUUFBTSxPQUFPLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUMvQixNQUFJLFNBQVMsR0FBRztBQUNkLFFBQUksRUFBRSxPQUFPLENBQUMsRUFBRTtBQUNkLGFBQU87QUFDVCxRQUFJLEVBQUUsT0FBTyxDQUFDLEVBQUU7QUFDZCxhQUFPO0FBQUEsRUFDWDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsVUFBVSxNQUFNO0FBQ3ZCLG1CQUFpQjtBQUNqQixlQUFhO0FBQ2IsTUFBSSxPQUEyQztBQUM3QyxXQUFPLFFBQXdCLG9CQUFJLElBQUk7QUFBQSxFQUN6QztBQUNBLFFBQU0sS0FBSyxVQUFVO0FBQ3JCLFFBQU0sUUFBUSxRQUE0QyxDQUFDLFFBQVEsc0JBQXNCLE1BQU0sR0FBRyxJQUFJO0FBQ3RHLE1BQUk7QUFDRixTQUFLLGFBQWEsR0FBRyxhQUFhLE1BQU0sUUFBUSxjQUFjO0FBQzVELFlBQU0sTUFBTSxNQUFNO0FBQ2xCLFVBQUksT0FBTyxJQUFJLFdBQVcsT0FBTztBQUMvQixZQUFJLE9BQXlEO0FBQzNEO0FBQUEsUUFDRjtBQUNBLDhCQUFzQixLQUFLLE1BQU0sRUFBRTtBQUFBLE1BQ3JDO0FBQUEsSUFDRjtBQUFBLEVBQ0YsVUFBRTtBQUNBLGlCQUFhO0FBQ2IsVUFBTSxTQUFTO0FBQ2Ysc0JBQWtCLElBQUk7QUFDdEIsaUJBQWE7QUFDYiwwQkFBc0I7QUFDdEIsUUFBSSxNQUFNLFVBQVUsb0JBQW9CLFFBQVE7QUFDOUMsZ0JBQVUsSUFBSTtBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUNGO0FBcUJBLElBQUksT0FBMkM7QUFDN0MsZ0JBQWMsRUFBRSxzQkFBc0I7QUFBQSxJQUNwQyxjQUFjLFFBQVEsWUFBWTtBQUFBLElBQ2xDLFVBQVUsUUFBUSxRQUFRO0FBQUEsSUFDMUIsUUFBUSxRQUFRLE1BQU07QUFBQSxFQUN4QjtBQUNGO0FBNE1BLFNBQVMsS0FBSyxVQUFVLFVBQVUsU0FBUztBQUN6QyxNQUFJLFNBQVM7QUFDWDtBQUNGLFFBQU0sUUFBUSxTQUFTLE1BQU0sU0FBUztBQUN0QyxNQUFJLE9BQTJDO0FBQzdDLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQSxjQUFjLENBQUMsWUFBWTtBQUFBLElBQzdCLElBQUk7QUFDSixRQUFJLGNBQWM7QUFDaEIsVUFBSSxFQUFFLFNBQVMsaUJBQWlCLE1BQU07QUFDcEMsWUFBSSxDQUFDLGdCQUFnQixFQUFFLGFBQWEsS0FBSyxLQUFLLGVBQWU7QUFDM0Q7QUFBQSxZQUNFLDRCQUE0QixvRUFBb0UsYUFBYSxLQUFLO0FBQUEsVUFDcEg7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0wsY0FBTSxZQUFZLGFBQWE7QUFDL0IsWUFBSSxXQUFXLFNBQVMsR0FBRztBQUN6QixnQkFBTSxVQUFVLFVBQVUsR0FBRyxPQUFPO0FBQ3BDLGNBQUksQ0FBQyxTQUFTO0FBQ1o7QUFBQSxjQUNFLCtEQUErRDtBQUFBLFlBQ2pFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLE9BQU87QUFDWCxRQUFNQyxtQkFBa0IsTUFBTSxXQUFXLFNBQVM7QUFDbEQsUUFBTSxXQUFXQSxvQkFBbUIsTUFBTSxNQUFNLENBQUM7QUFDakQsTUFBSSxZQUFZLFlBQVksT0FBTztBQUNqQyxVQUFNLGVBQWUsR0FBRyxhQUFhLGVBQWUsVUFBVTtBQUM5RCxVQUFNLEVBQUUsUUFBUSxLQUFLLElBQUksTUFBTSxpQkFBaUI7QUFDaEQsUUFBSSxNQUFNO0FBQ1IsYUFBTyxRQUFRLElBQUksQ0FBQyxNQUFNLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUM7QUFBQSxJQUN0RDtBQUNBLFFBQUksUUFBUTtBQUNWLGFBQU8sUUFBUSxJQUFJLGFBQWE7QUFBQSxJQUNsQztBQUFBLEVBQ0Y7QUFDQSxNQUFpRCxPQUF1QjtBQUN0RSwwQkFBc0IsVUFBVSxPQUFPLElBQUk7QUFBQSxFQUM3QztBQUNBLE1BQUksT0FBMkM7QUFDN0MsVUFBTSxpQkFBaUIsTUFBTSxZQUFZO0FBQ3pDLFFBQUksbUJBQW1CLFNBQVMsTUFBTSxhQUFhLGNBQWMsSUFBSTtBQUNuRTtBQUFBLFFBQ0UsVUFBVSwyQ0FBMkM7QUFBQSxVQUNuRDtBQUFBLFVBQ0EsU0FBUztBQUFBLFFBQ1gsd0NBQXdDLHNLQUFzSyxVQUFVLEtBQUssa0JBQWtCO0FBQUEsTUFDalA7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDSixNQUFJLFVBQVUsTUFBTSxjQUFjLGFBQWEsS0FBSyxNQUNwRCxNQUFNLGNBQWMsYUFBYSxTQUFTLEtBQUssQ0FBQztBQUNoRCxNQUFJLENBQUMsV0FBV0Esa0JBQWlCO0FBQy9CLGNBQVUsTUFBTSxjQUFjLGFBQWEsVUFBVSxLQUFLLENBQUM7QUFBQSxFQUM3RDtBQUNBLE1BQUksU0FBUztBQUNYO0FBQUEsTUFDRTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxjQUFjLE1BQU0sY0FBYztBQUN4QyxNQUFJLGFBQWE7QUFDZixRQUFJLENBQUMsU0FBUyxTQUFTO0FBQ3JCLGVBQVMsVUFBVSxDQUFDO0FBQUEsSUFDdEIsV0FBVyxTQUFTLFFBQVEsY0FBYztBQUN4QztBQUFBLElBQ0Y7QUFDQSxhQUFTLFFBQVEsZUFBZTtBQUNoQztBQUFBLE1BQ0U7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxzQkFBc0IsTUFBTSxZQUFZLFVBQVUsT0FBTztBQUNoRSxRQUFNLFFBQVEsV0FBVztBQUN6QixRQUFNLFNBQVMsTUFBTSxJQUFJLElBQUk7QUFDN0IsTUFBSSxXQUFXLFFBQVE7QUFDckIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLE1BQU0sS0FBSztBQUNqQixNQUFJLGFBQWEsQ0FBQztBQUNsQixNQUFJLGFBQWE7QUFDakIsTUFBMkIsQ0FBQyxXQUFXLElBQUksR0FBRztBQUM1QyxVQUFNLGNBQWMsQ0FBQyxTQUFTO0FBQzVCLFlBQU0sdUJBQXVCLHNCQUFzQixNQUFNLFlBQVksSUFBSTtBQUN6RSxVQUFJLHNCQUFzQjtBQUN4QixxQkFBYTtBQUNiLGVBQU8sWUFBWSxvQkFBb0I7QUFBQSxNQUN6QztBQUFBLElBQ0Y7QUFDQSxRQUFJLENBQUMsV0FBVyxXQUFXLE9BQU8sUUFBUTtBQUN4QyxpQkFBVyxPQUFPLFFBQVEsV0FBVztBQUFBLElBQ3ZDO0FBQ0EsUUFBSSxLQUFLLFNBQVM7QUFDaEIsa0JBQVksS0FBSyxPQUFPO0FBQUEsSUFDMUI7QUFDQSxRQUFJLEtBQUssUUFBUTtBQUNmLFdBQUssT0FBTyxRQUFRLFdBQVc7QUFBQSxJQUNqQztBQUFBLEVBQ0Y7QUFDQSxNQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7QUFDdkIsUUFBSSxTQUFTLElBQUksR0FBRztBQUNsQixZQUFNLElBQUksTUFBTSxJQUFJO0FBQUEsSUFDdEI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksUUFBUSxHQUFHLEdBQUc7QUFDaEIsUUFBSSxRQUFRLENBQUMsUUFBUSxXQUFXLE9BQU8sSUFBSTtBQUFBLEVBQzdDLE9BQU87QUFDTCxXQUFPLFlBQVksR0FBRztBQUFBLEVBQ3hCO0FBQ0EsTUFBSSxTQUFTLElBQUksR0FBRztBQUNsQixVQUFNLElBQUksTUFBTSxVQUFVO0FBQUEsRUFDNUI7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLGVBQWUsU0FBUyxLQUFLO0FBQ3BDLE1BQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFHLEdBQUc7QUFDMUIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLElBQUksTUFBTSxDQUFDLEVBQUUsUUFBUSxTQUFTLEVBQUU7QUFDdEMsU0FBTyxPQUFPLFNBQVMsSUFBSSxHQUFHLFlBQVksSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEtBQUssT0FBTyxTQUFTLFVBQVUsR0FBRyxDQUFDLEtBQUssT0FBTyxTQUFTLEdBQUc7QUFDdkg7QUFFQSxJQUFJLDJCQUEyQjtBQUMvQixJQUFJLGlCQUFpQjtBQUNyQixTQUFTLDRCQUE0QixVQUFVO0FBQzdDLFFBQU0sT0FBTztBQUNiLDZCQUEyQjtBQUMzQixtQkFBaUIsWUFBWSxTQUFTLEtBQUssYUFBYTtBQUN4RCxTQUFPO0FBQ1Q7QUFRQSxTQUFTLFFBQVEsSUFBSSxNQUFNLDBCQUEwQixpQkFBaUI7QUFDcEUsTUFBSSxDQUFDO0FBQ0gsV0FBTztBQUNULE1BQUksR0FBRyxJQUFJO0FBQ1QsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLHNCQUFzQixJQUFJLFNBQVM7QUFDdkMsUUFBSSxvQkFBb0IsSUFBSTtBQUMxQix1QkFBaUIsRUFBRTtBQUFBLElBQ3JCO0FBQ0EsVUFBTSxlQUFlLDRCQUE0QixHQUFHO0FBQ3BELFFBQUk7QUFDSixRQUFJO0FBQ0YsWUFBTSxHQUFHLEdBQUcsSUFBSTtBQUFBLElBQ2xCLFVBQUU7QUFDQSxrQ0FBNEIsWUFBWTtBQUN4QyxVQUFJLG9CQUFvQixJQUFJO0FBQzFCLHlCQUFpQixDQUFDO0FBQUEsTUFDcEI7QUFBQSxJQUNGO0FBQ0EsUUFBaUQsT0FBdUI7QUFDdEUsK0JBQXlCLEdBQUc7QUFBQSxJQUM5QjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0Esc0JBQW9CLEtBQUs7QUFDekIsc0JBQW9CLEtBQUs7QUFDekIsc0JBQW9CLEtBQUs7QUFDekIsU0FBTztBQUNUO0FBTUEsU0FBUyxvQkFBb0IsVUFBVTtBQUNyQyxRQUFNO0FBQUEsSUFDSixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsY0FBYyxDQUFDLFlBQVk7QUFBQSxJQUMzQjtBQUFBLElBQ0E7QUFBQSxJQUNBLE1BQUFDO0FBQUEsSUFDQSxRQUFBQztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixJQUFJO0FBQ0osTUFBSTtBQUNKLE1BQUk7QUFDSixRQUFNLE9BQU8sNEJBQTRCLFFBQVE7QUFDakQsTUFBSSxPQUEyQztBQUM3QyxvQkFBZ0I7QUFBQSxFQUNsQjtBQUNBLE1BQUk7QUFDRixRQUFJLE1BQU0sWUFBWSxHQUFHO0FBQ3ZCLFlBQU0sYUFBYSxhQUFhO0FBQ2hDLGVBQVM7QUFBQSxRQUNQQSxRQUFPO0FBQUEsVUFDTDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EseUJBQW1CO0FBQUEsSUFDckIsT0FBTztBQUNMLFlBQU1DLFdBQVU7QUFDaEIsVUFBSSxPQUE4RDtBQUNoRSwwQkFBa0I7QUFBQSxNQUNwQjtBQUNBLGVBQVM7QUFBQSxRQUNQQSxTQUFRLFNBQVMsSUFBSUE7QUFBQSxVQUNuQjtBQUFBLFVBQ0EsUUFBNEM7QUFBQSxZQUMxQyxJQUFJLFFBQVE7QUFDVixnQ0FBa0I7QUFDbEIscUJBQU87QUFBQSxZQUNUO0FBQUEsWUFDQTtBQUFBLFlBQ0EsTUFBQUY7QUFBQSxVQUNGLElBQUksRUFBRSxPQUFPLE9BQU8sTUFBQUEsTUFBSztBQUFBLFFBQzNCLElBQUlFO0FBQUEsVUFDRjtBQUFBLFVBQ0E7QUFBQSxRQUVGO0FBQUEsTUFDRjtBQUNBLHlCQUFtQixVQUFVLFFBQVEsUUFBUSx5QkFBeUIsS0FBSztBQUFBLElBQzdFO0FBQUEsRUFDRixTQUFTLEtBQVA7QUFDQSxlQUFXLFNBQVM7QUFDcEIsZ0JBQVksS0FBSyxVQUFVLENBQUM7QUFDNUIsYUFBUyxZQUFZLE9BQU87QUFBQSxFQUM5QjtBQUNBLE1BQUksT0FBTztBQUNYLE1BQUksVUFBVTtBQUNkLE1BQUksT0FBOEY7QUFDaEcsS0FBQyxNQUFNLE9BQU8sSUFBSSxhQUFhLE1BQU07QUFBQSxFQUN2QztBQUNBLE1BQUksb0JBQW9CLGlCQUFpQixPQUFPO0FBQzlDLFVBQU0sT0FBTyxPQUFPLEtBQUssZ0JBQWdCO0FBQ3pDLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsUUFBSSxLQUFLLFFBQVE7QUFDZixVQUFJLGFBQWEsSUFBSSxJQUFJO0FBQ3ZCLFlBQUksZ0JBQWdCLEtBQUssS0FBSyxlQUFlLEdBQUc7QUFDOUMsNkJBQW1CO0FBQUEsWUFDakI7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxlQUFPLFdBQVcsTUFBTSxnQkFBZ0I7QUFBQSxNQUMxQyxXQUFXLE9BQXNGO0FBQy9GLGNBQU0sV0FBVyxPQUFPLEtBQUssS0FBSztBQUNsQyxjQUFNLGFBQWEsQ0FBQztBQUNwQixjQUFNLGFBQWEsQ0FBQztBQUNwQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDL0MsZ0JBQU0sTUFBTSxTQUFTO0FBQ3JCLGNBQUksS0FBSyxHQUFHLEdBQUc7QUFDYixnQkFBSSxDQUFDLGdCQUFnQixHQUFHLEdBQUc7QUFDekIseUJBQVcsS0FBSyxJQUFJLEdBQUcsWUFBWSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUM7QUFBQSxZQUNyRDtBQUFBLFVBQ0YsT0FBTztBQUNMLHVCQUFXLEtBQUssR0FBRztBQUFBLFVBQ3JCO0FBQUEsUUFDRjtBQUNBLFlBQUksV0FBVyxRQUFRO0FBQ3JCO0FBQUEsWUFDRSxvQ0FBb0MsV0FBVyxLQUFLLElBQUk7QUFBQSxVQUMxRDtBQUFBLFFBQ0Y7QUFDQSxZQUFJLFdBQVcsUUFBUTtBQUNyQjtBQUFBLFlBQ0UseUNBQXlDLFdBQVcsS0FBSyxJQUFJO0FBQUEsVUFDL0Q7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxNQUFNLE1BQU07QUFDZCxRQUFJLE9BQW1FO0FBQ3JFO0FBQUEsUUFDRTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsV0FBTyxXQUFXLElBQUk7QUFDdEIsU0FBSyxPQUFPLEtBQUssT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLElBQUksSUFBSSxNQUFNO0FBQUEsRUFDL0Q7QUFDQSxNQUFJLE1BQU0sWUFBWTtBQUNwQixRQUFJLE9BQW1FO0FBQ3JFO0FBQUEsUUFDRTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsU0FBSyxhQUFhLE1BQU07QUFBQSxFQUMxQjtBQUNBLE1BQUksT0FBc0Q7QUFDeEQsWUFBUSxJQUFJO0FBQUEsRUFDZCxPQUFPO0FBQ0wsYUFBUztBQUFBLEVBQ1g7QUFDQSw4QkFBNEIsSUFBSTtBQUNoQyxTQUFPO0FBQ1Q7QUF3Q0EsSUFBTSwyQkFBMkIsQ0FBQyxVQUFVO0FBQzFDLE1BQUk7QUFDSixhQUFXLE9BQU8sT0FBTztBQUN2QixRQUFJLFFBQVEsV0FBVyxRQUFRLFdBQVcsS0FBSyxHQUFHLEdBQUc7QUFDbkQsT0FBQyxRQUFRLE1BQU0sQ0FBQyxJQUFJLE9BQU8sTUFBTTtBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLElBQU0sdUJBQXVCLENBQUMsT0FBTyxVQUFVO0FBQzdDLFFBQU0sTUFBTSxDQUFDO0FBQ2IsYUFBVyxPQUFPLE9BQU87QUFDdkIsUUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssRUFBRSxJQUFJLE1BQU0sQ0FBQyxLQUFLLFFBQVE7QUFDckQsVUFBSSxPQUFPLE1BQU07QUFBQSxJQUNuQjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFJQSxTQUFTLHNCQUFzQixXQUFXLFdBQVcsV0FBVztBQUM5RCxRQUFNLEVBQUUsT0FBTyxXQUFXLFVBQVUsY0FBYyxVQUFVLElBQUk7QUFDaEUsUUFBTSxFQUFFLE9BQU8sV0FBVyxVQUFVLGNBQWMsVUFBVSxJQUFJO0FBQ2hFLFFBQU0sUUFBUSxVQUFVO0FBQ3hCLE1BQUksT0FBOEY7QUFDaEcsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLFVBQVUsUUFBUSxVQUFVLFlBQVk7QUFDMUMsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLGFBQWEsYUFBYSxHQUFHO0FBQy9CLFFBQUksWUFBWSxNQUFNO0FBQ3BCLGFBQU87QUFBQSxJQUNUO0FBQ0EsUUFBSSxZQUFZLElBQUk7QUFDbEIsVUFBSSxDQUFDLFdBQVc7QUFDZCxlQUFPLENBQUMsQ0FBQztBQUFBLE1BQ1g7QUFDQSxhQUFPLGdCQUFnQixXQUFXLFdBQVcsS0FBSztBQUFBLElBQ3BELFdBQVcsWUFBWSxHQUFHO0FBQ3hCLFlBQU0sZUFBZSxVQUFVO0FBQy9CLGVBQVMsSUFBSSxHQUFHLElBQUksYUFBYSxRQUFRLEtBQUs7QUFDNUMsY0FBTSxNQUFNLGFBQWE7QUFDekIsWUFBSSxVQUFVLFNBQVMsVUFBVSxRQUFRLENBQUMsZUFBZSxPQUFPLEdBQUcsR0FBRztBQUNwRSxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLFFBQUksZ0JBQWdCLGNBQWM7QUFDaEMsVUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsU0FBUztBQUMxQyxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFDQSxRQUFJLGNBQWMsV0FBVztBQUMzQixhQUFPO0FBQUEsSUFDVDtBQUNBLFFBQUksQ0FBQyxXQUFXO0FBQ2QsYUFBTyxDQUFDLENBQUM7QUFBQSxJQUNYO0FBQ0EsUUFBSSxDQUFDLFdBQVc7QUFDZCxhQUFPO0FBQUEsSUFDVDtBQUNBLFdBQU8sZ0JBQWdCLFdBQVcsV0FBVyxLQUFLO0FBQUEsRUFDcEQ7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLGdCQUFnQixXQUFXLFdBQVcsY0FBYztBQUMzRCxRQUFNLFdBQVcsT0FBTyxLQUFLLFNBQVM7QUFDdEMsTUFBSSxTQUFTLFdBQVcsT0FBTyxLQUFLLFNBQVMsRUFBRSxRQUFRO0FBQ3JELFdBQU87QUFBQSxFQUNUO0FBQ0EsV0FBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUN4QyxVQUFNLE1BQU0sU0FBUztBQUNyQixRQUFJLFVBQVUsU0FBUyxVQUFVLFFBQVEsQ0FBQyxlQUFlLGNBQWMsR0FBRyxHQUFHO0FBQzNFLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsZ0JBQWdCLEVBQUUsT0FBTyxPQUFPLEdBQUcsSUFBSTtBQUM5QyxTQUFPLFVBQVUsT0FBTyxZQUFZLE9BQU87QUFDekMsS0FBQyxRQUFRLE9BQU8sT0FBTyxLQUFLO0FBQzVCLGFBQVMsT0FBTztBQUFBLEVBQ2xCO0FBQ0Y7QUFFQSxJQUFNLGFBQWEsQ0FBQyxTQUFTLEtBQUs7QUEraEJsQyxTQUFTLHdCQUF3QixJQUFJLFVBQVU7QUFDN0MsTUFBSSxZQUFZLFNBQVMsZUFBZTtBQUN0QyxRQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ2YsZUFBUyxRQUFRLEtBQUssR0FBRyxFQUFFO0FBQUEsSUFDN0IsT0FBTztBQUNMLGVBQVMsUUFBUSxLQUFLLEVBQUU7QUFBQSxJQUMxQjtBQUFBLEVBQ0YsT0FBTztBQUNMLHFCQUFpQixFQUFFO0FBQUEsRUFDckI7QUFDRjtBQWdDQSxJQUFNLHdCQUF3QixDQUFDO0FBQy9CLFNBQVMsTUFBTSxRQUFRLElBQUksU0FBUztBQUNsQyxNQUFJLE9BQThEO0FBQ2hFO0FBQUEsTUFDRTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTyxRQUFRLFFBQVEsSUFBSSxPQUFPO0FBQ3BDO0FBQ0EsU0FBUyxRQUFRLFFBQVEsSUFBSSxFQUFFLFdBQVcsTUFBTSxPQUFPLFNBQVMsVUFBVSxJQUFJLFdBQVc7QUFDdkYsTUFBSTtBQUNKLE1BQUksT0FBa0Q7QUFDcEQsUUFBSSxjQUFjLFFBQVE7QUFDeEI7QUFBQSxRQUNFO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxRQUFJLFNBQVMsUUFBUTtBQUNuQjtBQUFBLFFBQ0U7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLG9CQUFvQixDQUFDLE1BQU07QUFDL0I7QUFBQSxNQUNFO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFFBQU0sV0FBVyxnQkFBZ0IsUUFBUSxLQUFLLG9CQUFvQixPQUFPLFNBQVMsR0FBRyxTQUFTLGtCQUFrQjtBQUNoSCxNQUFJO0FBQ0osTUFBSSxlQUFlO0FBQ25CLE1BQUksZ0JBQWdCO0FBQ3BCLE1BQUksTUFBTSxNQUFNLEdBQUc7QUFDakIsYUFBUyxNQUFNLE9BQU87QUFDdEIsbUJBQWUsVUFBWSxNQUFNO0FBQUEsRUFDbkMsV0FBVyxXQUFXLE1BQU0sR0FBRztBQUM3QixhQUFTLE1BQU07QUFDZixXQUFPO0FBQUEsRUFDVCxXQUFXLFFBQVEsTUFBTSxHQUFHO0FBQzFCLG9CQUFnQjtBQUNoQixtQkFBZSxPQUFPLEtBQUssQ0FBQyxNQUFNLFdBQVcsQ0FBQyxLQUFLLFVBQVksQ0FBQyxDQUFDO0FBQ2pFLGFBQVMsTUFBTSxPQUFPLElBQUksQ0FBQyxNQUFNO0FBQy9CLFVBQUksTUFBTSxDQUFDLEdBQUc7QUFDWixlQUFPLEVBQUU7QUFBQSxNQUNYLFdBQVcsV0FBVyxDQUFDLEdBQUc7QUFDeEIsZUFBTyxTQUFTLENBQUM7QUFBQSxNQUNuQixXQUFXLFdBQVcsQ0FBQyxHQUFHO0FBQ3hCLGVBQU8sc0JBQXNCLEdBQUcsVUFBVSxDQUFDO0FBQUEsTUFDN0MsT0FBTztBQUFBLE1BRVA7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNILFdBQVcsV0FBVyxNQUFNLEdBQUc7QUFDN0IsUUFBSSxJQUFJO0FBQ04sZUFBUyxNQUFNLHNCQUFzQixRQUFRLFVBQVUsQ0FBQztBQUFBLElBQzFELE9BQU87QUFDTCxlQUFTLE1BQU07QUFDYixZQUFJLFlBQVksU0FBUyxhQUFhO0FBQ3BDO0FBQUEsUUFDRjtBQUNBLFlBQUksU0FBUztBQUNYLGtCQUFRO0FBQUEsUUFDVjtBQUNBLGVBQU87QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLENBQUMsU0FBUztBQUFBLFFBQ1o7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLGFBQVM7QUFBQSxFQUVYO0FBQ0EsTUFBSSxNQUFNLE1BQU07QUFDZCxVQUFNLGFBQWE7QUFDbkIsYUFBUyxNQUFNLFNBQVMsV0FBVyxDQUFDO0FBQUEsRUFDdEM7QUFDQSxNQUFJO0FBQ0osTUFBSSxZQUFZLENBQUMsT0FBTztBQUN0QixjQUFVQyxRQUFPLFNBQVMsTUFBTTtBQUM5Qiw0QkFBc0IsSUFBSSxVQUFVLENBQUM7QUFBQSxJQUN2QztBQUFBLEVBQ0Y7QUFDQSxNQUFJO0FBQ0osTUFBSSx1QkFBdUI7QUFDekIsZ0JBQVk7QUFDWixRQUFJLENBQUMsSUFBSTtBQUNQLGFBQU87QUFBQSxJQUNULFdBQVcsV0FBVztBQUNwQixpQ0FBMkIsSUFBSSxVQUFVLEdBQUc7QUFBQSxRQUMxQyxPQUFPO0FBQUEsUUFDUCxnQkFBZ0IsQ0FBQyxJQUFJO0FBQUEsUUFDckI7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQ0EsUUFBSSxVQUFVLFFBQVE7QUFDcEIsWUFBTSxNQUFNLGNBQWM7QUFDMUIsbUJBQWEsSUFBSSxxQkFBcUIsSUFBSSxtQkFBbUIsQ0FBQztBQUFBLElBQ2hFLE9BQU87QUFDTCxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFdBQVcsZ0JBQWdCLElBQUksTUFBTSxPQUFPLE1BQU0sRUFBRSxLQUFLLHFCQUFxQixJQUFJO0FBQ3RGLFFBQU0sTUFBTSxNQUFNO0FBQ2hCLFFBQUksQ0FBQ0EsUUFBTyxRQUFRO0FBQ2xCO0FBQUEsSUFDRjtBQUNBLFFBQUksSUFBSTtBQUNOLFlBQU0sV0FBV0EsUUFBTyxJQUFJO0FBQzVCLFVBQUksUUFBUSxpQkFBaUIsZ0JBQWdCLFNBQVM7QUFBQSxRQUNwRCxDQUFDLEdBQUcsTUFBTSxXQUFXLEdBQUcsU0FBUyxFQUFFO0FBQUEsTUFDckMsSUFBSSxXQUFXLFVBQVUsUUFBUSxNQUFNLE9BQU87QUFDNUMsWUFBSSxTQUFTO0FBQ1gsa0JBQVE7QUFBQSxRQUNWO0FBQ0EsbUNBQTJCLElBQUksVUFBVSxHQUFHO0FBQUEsVUFDMUM7QUFBQSxVQUVBLGFBQWEsd0JBQXdCLFNBQVMsaUJBQWlCLFNBQVMsT0FBTyx3QkFBd0IsQ0FBQyxJQUFJO0FBQUEsVUFDNUc7QUFBQSxRQUNGLENBQUM7QUFDRCxtQkFBVztBQUFBLE1BQ2I7QUFBQSxJQUNGLE9BQU87QUFDTCxNQUFBQSxRQUFPLElBQUk7QUFBQSxJQUNiO0FBQUEsRUFDRjtBQUNBLE1BQUksZUFBZSxDQUFDLENBQUM7QUFDckIsTUFBSTtBQUNKLE1BQUksVUFBVSxRQUFRO0FBQ3BCLGdCQUFZO0FBQUEsRUFDZCxXQUFXLFVBQVUsUUFBUTtBQUMzQixnQkFBWSxNQUFNLHNCQUFzQixLQUFLLFlBQVksU0FBUyxRQUFRO0FBQUEsRUFDNUUsT0FBTztBQUNMLFFBQUksTUFBTTtBQUNWLFFBQUk7QUFDRixVQUFJLEtBQUssU0FBUztBQUNwQixnQkFBWSxNQUFNLFNBQVMsR0FBRztBQUFBLEVBQ2hDO0FBQ0EsUUFBTUEsVUFBUyxJQUFJLGVBQWUsUUFBUSxTQUFTO0FBQ25ELE1BQUksT0FBMkM7QUFDN0MsSUFBQUEsUUFBTyxVQUFVO0FBQ2pCLElBQUFBLFFBQU8sWUFBWTtBQUFBLEVBQ3JCO0FBQ0EsTUFBSSxJQUFJO0FBQ04sUUFBSSxXQUFXO0FBQ2IsVUFBSTtBQUFBLElBQ04sT0FBTztBQUNMLGlCQUFXQSxRQUFPLElBQUk7QUFBQSxJQUN4QjtBQUFBLEVBQ0YsV0FBVyxVQUFVLFFBQVE7QUFDM0I7QUFBQSxNQUNFQSxRQUFPLElBQUksS0FBS0EsT0FBTTtBQUFBLE1BQ3RCLFlBQVksU0FBUztBQUFBLElBQ3ZCO0FBQUEsRUFDRixPQUFPO0FBQ0wsSUFBQUEsUUFBTyxJQUFJO0FBQUEsRUFDYjtBQUNBLFFBQU0sVUFBVSxNQUFNO0FBQ3BCLElBQUFBLFFBQU8sS0FBSztBQUNaLFFBQUksWUFBWSxTQUFTLE9BQU87QUFDOUIsYUFBTyxTQUFTLE1BQU0sU0FBU0EsT0FBTTtBQUFBLElBQ3ZDO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDRixlQUFXLEtBQUssT0FBTztBQUN6QixTQUFPO0FBQ1Q7QUFDQSxTQUFTLGNBQWMsUUFBUSxPQUFPLFNBQVM7QUFDN0MsUUFBTSxhQUFhLEtBQUs7QUFDeEIsUUFBTSxTQUFTLFNBQVMsTUFBTSxJQUFJLE9BQU8sU0FBUyxHQUFHLElBQUksaUJBQWlCLFlBQVksTUFBTSxJQUFJLE1BQU0sV0FBVyxVQUFVLE9BQU8sS0FBSyxZQUFZLFVBQVU7QUFDN0osTUFBSTtBQUNKLE1BQUksV0FBVyxLQUFLLEdBQUc7QUFDckIsU0FBSztBQUFBLEVBQ1AsT0FBTztBQUNMLFNBQUssTUFBTTtBQUNYLGNBQVU7QUFBQSxFQUNaO0FBQ0EsUUFBTSxNQUFNO0FBQ1oscUJBQW1CLElBQUk7QUFDdkIsUUFBTSxNQUFNLFFBQVEsUUFBUSxHQUFHLEtBQUssVUFBVSxHQUFHLE9BQU87QUFDeEQsTUFBSSxLQUFLO0FBQ1AsdUJBQW1CLEdBQUc7QUFBQSxFQUN4QixPQUFPO0FBQ0wseUJBQXFCO0FBQUEsRUFDdkI7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLGlCQUFpQixLQUFLLE1BQU07QUFDbkMsUUFBTSxXQUFXLEtBQUssTUFBTSxHQUFHO0FBQy9CLFNBQU8sTUFBTTtBQUNYLFFBQUksTUFBTTtBQUNWLGFBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxVQUFVLEtBQUssS0FBSztBQUMvQyxZQUFNLElBQUksU0FBUztBQUFBLElBQ3JCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUNBLFNBQVMsU0FBUyxPQUFPLE1BQU07QUFDN0IsTUFBSSxDQUFDLFNBQVMsS0FBSyxLQUFLLE1BQU0sYUFBYTtBQUN6QyxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sUUFBd0Isb0JBQUksSUFBSTtBQUN2QyxNQUFJLEtBQUssSUFBSSxLQUFLLEdBQUc7QUFDbkIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxPQUFLLElBQUksS0FBSztBQUNkLE1BQUksTUFBTSxLQUFLLEdBQUc7QUFDaEIsYUFBUyxNQUFNLE9BQU8sSUFBSTtBQUFBLEVBQzVCLFdBQVcsUUFBUSxLQUFLLEdBQUc7QUFDekIsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxlQUFTLE1BQU0sSUFBSSxJQUFJO0FBQUEsSUFDekI7QUFBQSxFQUNGLFdBQVcsTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEdBQUc7QUFDdkMsVUFBTSxRQUFRLENBQUMsTUFBTTtBQUNuQixlQUFTLEdBQUcsSUFBSTtBQUFBLElBQ2xCLENBQUM7QUFBQSxFQUNILFdBQVcsY0FBYyxLQUFLLEdBQUc7QUFDL0IsZUFBVyxPQUFPLE9BQU87QUFDdkIsZUFBUyxNQUFNLE1BQU0sSUFBSTtBQUFBLElBQzNCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQXVDQSxTQUFTLG9CQUFvQixPQUFPLFdBQVcsVUFBVSxNQUFNO0FBQzdELFFBQU0sV0FBVyxNQUFNO0FBQ3ZCLFFBQU0sY0FBYyxhQUFhLFVBQVU7QUFDM0MsV0FBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsS0FBSztBQUN4QyxVQUFNLFVBQVUsU0FBUztBQUN6QixRQUFJLGFBQWE7QUFDZixjQUFRLFdBQVcsWUFBWSxHQUFHO0FBQUEsSUFDcEM7QUFDQSxRQUFJLE9BQU8sUUFBUSxJQUFJO0FBQ3ZCLFFBQUksTUFBTTtBQUNSLG9CQUFjO0FBQ2QsaUNBQTJCLE1BQU0sVUFBVSxHQUFHO0FBQUEsUUFDNUMsTUFBTTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0YsQ0FBQztBQUNELG9CQUFjO0FBQUEsSUFDaEI7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxTQUFTLHFCQUFxQjtBQUM1QixRQUFNLFFBQVE7QUFBQSxJQUNaLFdBQVc7QUFBQSxJQUNYLFdBQVc7QUFBQSxJQUNYLGNBQWM7QUFBQSxJQUNkLGVBQStCLG9CQUFJLElBQUk7QUFBQSxFQUN6QztBQUNBLFlBQVUsTUFBTTtBQUNkLFVBQU0sWUFBWTtBQUFBLEVBQ3BCLENBQUM7QUFDRCxrQkFBZ0IsTUFBTTtBQUNwQixVQUFNLGVBQWU7QUFBQSxFQUN2QixDQUFDO0FBQ0QsU0FBTztBQUNUO0FBQ0EsSUFBTSwwQkFBMEIsQ0FBQyxVQUFVLEtBQUs7QUFDaEQsSUFBTSxnQ0FBZ0M7QUFBQSxFQUNwQyxNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFFWCxlQUFlO0FBQUEsRUFDZixTQUFTO0FBQUEsRUFDVCxjQUFjO0FBQUEsRUFDZCxrQkFBa0I7QUFBQSxFQUVsQixlQUFlO0FBQUEsRUFDZixTQUFTO0FBQUEsRUFDVCxjQUFjO0FBQUEsRUFDZCxrQkFBa0I7QUFBQSxFQUVsQixnQkFBZ0I7QUFBQSxFQUNoQixVQUFVO0FBQUEsRUFDVixlQUFlO0FBQUEsRUFDZixtQkFBbUI7QUFDckI7QUFDQSxJQUFNLHFCQUFxQjtBQUFBLEVBQ3pCLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE1BQU0sT0FBTyxFQUFFLE1BQU0sR0FBRztBQUN0QixVQUFNLFdBQVcsbUJBQW1CO0FBQ3BDLFVBQU0sUUFBUSxtQkFBbUI7QUFDakMsUUFBSTtBQUNKLFdBQU8sTUFBTTtBQUNYLFlBQU0sV0FBVyxNQUFNLFdBQVcseUJBQXlCLE1BQU0sUUFBUSxHQUFHLElBQUk7QUFDaEYsVUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLFFBQVE7QUFDakM7QUFBQSxNQUNGO0FBQ0EsVUFBSSxRQUFRLFNBQVM7QUFDckIsVUFBSSxTQUFTLFNBQVMsR0FBRztBQUN2QixZQUFJLFdBQVc7QUFDZixtQkFBVyxLQUFLLFVBQVU7QUFDeEIsY0FBSSxFQUFFLFNBQVMsU0FBUztBQUN0QixnQkFBSSxPQUF1RDtBQUN6RDtBQUFBLGdCQUNFO0FBQUEsY0FDRjtBQUNBO0FBQUEsWUFDRjtBQUNBLG9CQUFRO0FBQ1IsdUJBQVc7QUFDWCxnQkFBSTtBQUNGO0FBQUEsVUFDSjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsWUFBTSxXQUFXLE1BQU0sS0FBSztBQUM1QixZQUFNLEVBQUUsS0FBSyxJQUFJO0FBQ2pCLFVBQUksT0FBbUg7QUFDckgsYUFBSyw4QkFBOEIsTUFBTTtBQUFBLE1BQzNDO0FBQ0EsVUFBSSxNQUFNLFdBQVc7QUFDbkIsZUFBTyxpQkFBaUIsS0FBSztBQUFBLE1BQy9CO0FBQ0EsWUFBTSxhQUFhLGtCQUFrQixLQUFLO0FBQzFDLFVBQUksQ0FBQyxZQUFZO0FBQ2YsZUFBTyxpQkFBaUIsS0FBSztBQUFBLE1BQy9CO0FBQ0EsWUFBTSxhQUFhO0FBQUEsUUFDakI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQ0EseUJBQW1CLFlBQVksVUFBVTtBQUN6QyxZQUFNLFdBQVcsU0FBUztBQUMxQixZQUFNLGdCQUFnQixZQUFZLGtCQUFrQixRQUFRO0FBQzVELFVBQUksdUJBQXVCO0FBQzNCLFlBQU0sRUFBRSxpQkFBaUIsSUFBSSxXQUFXO0FBQ3hDLFVBQUksa0JBQWtCO0FBQ3BCLGNBQU0sTUFBTSxpQkFBaUI7QUFDN0IsWUFBSSxzQkFBc0IsUUFBUTtBQUNoQyw4QkFBb0I7QUFBQSxRQUN0QixXQUFXLFFBQVEsbUJBQW1CO0FBQ3BDLDhCQUFvQjtBQUNwQixpQ0FBdUI7QUFBQSxRQUN6QjtBQUFBLE1BQ0Y7QUFDQSxVQUFJLGlCQUFpQixjQUFjLFNBQVMsWUFBWSxDQUFDLGdCQUFnQixZQUFZLGFBQWEsS0FBSyx1QkFBdUI7QUFDNUgsY0FBTSxlQUFlO0FBQUEsVUFDbkI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0EsMkJBQW1CLGVBQWUsWUFBWTtBQUM5QyxZQUFJLFNBQVMsVUFBVTtBQUNyQixnQkFBTSxZQUFZO0FBQ2xCLHVCQUFhLGFBQWEsTUFBTTtBQUM5QixrQkFBTSxZQUFZO0FBQ2xCLGdCQUFJLFNBQVMsT0FBTyxXQUFXLE9BQU87QUFDcEMsdUJBQVMsT0FBTztBQUFBLFlBQ2xCO0FBQUEsVUFDRjtBQUNBLGlCQUFPLGlCQUFpQixLQUFLO0FBQUEsUUFDL0IsV0FBVyxTQUFTLFlBQVksV0FBVyxTQUFTLFNBQVM7QUFDM0QsdUJBQWEsYUFBYSxDQUFDLElBQUksYUFBYSxpQkFBaUI7QUFDM0Qsa0JBQU0scUJBQXFCO0FBQUEsY0FDekI7QUFBQSxjQUNBO0FBQUEsWUFDRjtBQUNBLCtCQUFtQixPQUFPLGNBQWMsR0FBRyxLQUFLO0FBQ2hELGVBQUcsV0FBVyxNQUFNO0FBQ2xCLDBCQUFZO0FBQ1osaUJBQUcsV0FBVztBQUNkLHFCQUFPLFdBQVc7QUFBQSxZQUNwQjtBQUNBLHVCQUFXLGVBQWU7QUFBQSxVQUM1QjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLGlCQUFpQjtBQUN2QixTQUFTLHVCQUF1QixPQUFPLE9BQU87QUFDNUMsUUFBTSxFQUFFLGNBQWMsSUFBSTtBQUMxQixNQUFJLHFCQUFxQixjQUFjLElBQUksTUFBTSxJQUFJO0FBQ3JELE1BQUksQ0FBQyxvQkFBb0I7QUFDdkIseUJBQXFDLHVCQUFPLE9BQU8sSUFBSTtBQUN2RCxrQkFBYyxJQUFJLE1BQU0sTUFBTSxrQkFBa0I7QUFBQSxFQUNsRDtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsdUJBQXVCLE9BQU8sT0FBTyxPQUFPLFVBQVU7QUFDN0QsUUFBTTtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUEsSUFDQSxZQUFZO0FBQUEsSUFDWjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRixJQUFJO0FBQ0osUUFBTSxNQUFNLE9BQU8sTUFBTSxHQUFHO0FBQzVCLFFBQU0scUJBQXFCLHVCQUF1QixPQUFPLEtBQUs7QUFDOUQsUUFBTUMsWUFBVyxDQUFDLE1BQU0sU0FBUztBQUMvQixZQUFRO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxnQkFBZ0IsQ0FBQyxNQUFNLFNBQVM7QUFDcEMsVUFBTSxPQUFPLEtBQUs7QUFDbEIsSUFBQUEsVUFBUyxNQUFNLElBQUk7QUFDbkIsUUFBSSxRQUFRLElBQUksR0FBRztBQUNqQixVQUFJLEtBQUssTUFBTSxDQUFDLFVBQVUsTUFBTSxVQUFVLENBQUM7QUFDekMsYUFBSztBQUFBLElBQ1QsV0FBVyxLQUFLLFVBQVUsR0FBRztBQUMzQixXQUFLO0FBQUEsSUFDUDtBQUFBLEVBQ0Y7QUFDQSxRQUFNLFFBQVE7QUFBQSxJQUNaO0FBQUEsSUFDQTtBQUFBLElBQ0EsWUFBWSxJQUFJO0FBQ2QsVUFBSSxPQUFPO0FBQ1gsVUFBSSxDQUFDLE1BQU0sV0FBVztBQUNwQixZQUFJLFFBQVE7QUFDVixpQkFBTyxrQkFBa0I7QUFBQSxRQUMzQixPQUFPO0FBQ0w7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLFVBQUksR0FBRyxVQUFVO0FBQ2YsV0FBRztBQUFBLFVBQ0Q7QUFBQSxRQUVGO0FBQUEsTUFDRjtBQUNBLFlBQU0sZUFBZSxtQkFBbUI7QUFDeEMsVUFBSSxnQkFBZ0IsZ0JBQWdCLE9BQU8sWUFBWSxLQUFLLGFBQWEsR0FBRyxVQUFVO0FBQ3BGLHFCQUFhLEdBQUcsU0FBUztBQUFBLE1BQzNCO0FBQ0EsTUFBQUEsVUFBUyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQUEsSUFDckI7QUFBQSxJQUNBLE1BQU0sSUFBSTtBQUNSLFVBQUksT0FBTztBQUNYLFVBQUksWUFBWTtBQUNoQixVQUFJLGFBQWE7QUFDakIsVUFBSSxDQUFDLE1BQU0sV0FBVztBQUNwQixZQUFJLFFBQVE7QUFDVixpQkFBTyxZQUFZO0FBQ25CLHNCQUFZLGlCQUFpQjtBQUM3Qix1QkFBYSxxQkFBcUI7QUFBQSxRQUNwQyxPQUFPO0FBQ0w7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLFVBQUksU0FBUztBQUNiLFlBQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxjQUFjO0FBQ3hDLFlBQUk7QUFDRjtBQUNGLGlCQUFTO0FBQ1QsWUFBSSxXQUFXO0FBQ2IsVUFBQUEsVUFBUyxZQUFZLENBQUMsRUFBRSxDQUFDO0FBQUEsUUFDM0IsT0FBTztBQUNMLFVBQUFBLFVBQVMsV0FBVyxDQUFDLEVBQUUsQ0FBQztBQUFBLFFBQzFCO0FBQ0EsWUFBSSxNQUFNLGNBQWM7QUFDdEIsZ0JBQU0sYUFBYTtBQUFBLFFBQ3JCO0FBQ0EsV0FBRyxXQUFXO0FBQUEsTUFDaEI7QUFDQSxVQUFJLE1BQU07QUFDUixzQkFBYyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUM7QUFBQSxNQUNoQyxPQUFPO0FBQ0wsYUFBSztBQUFBLE1BQ1A7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNLElBQUlDLFNBQVE7QUFDaEIsWUFBTSxPQUFPLE9BQU8sTUFBTSxHQUFHO0FBQzdCLFVBQUksR0FBRyxVQUFVO0FBQ2YsV0FBRztBQUFBLFVBQ0Q7QUFBQSxRQUVGO0FBQUEsTUFDRjtBQUNBLFVBQUksTUFBTSxjQUFjO0FBQ3RCLGVBQU9BLFFBQU87QUFBQSxNQUNoQjtBQUNBLE1BQUFELFVBQVMsZUFBZSxDQUFDLEVBQUUsQ0FBQztBQUM1QixVQUFJLFNBQVM7QUFDYixZQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsY0FBYztBQUN4QyxZQUFJO0FBQ0Y7QUFDRixpQkFBUztBQUNULFFBQUFDLFFBQU87QUFDUCxZQUFJLFdBQVc7QUFDYixVQUFBRCxVQUFTLGtCQUFrQixDQUFDLEVBQUUsQ0FBQztBQUFBLFFBQ2pDLE9BQU87QUFDTCxVQUFBQSxVQUFTLGNBQWMsQ0FBQyxFQUFFLENBQUM7QUFBQSxRQUM3QjtBQUNBLFdBQUcsV0FBVztBQUNkLFlBQUksbUJBQW1CLFVBQVUsT0FBTztBQUN0QyxpQkFBTyxtQkFBbUI7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFDQSx5QkFBbUIsUUFBUTtBQUMzQixVQUFJLFNBQVM7QUFDWCxzQkFBYyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUM7QUFBQSxNQUNuQyxPQUFPO0FBQ0wsYUFBSztBQUFBLE1BQ1A7QUFBQSxJQUNGO0FBQUEsSUFDQSxNQUFNLFFBQVE7QUFDWixhQUFPLHVCQUF1QixRQUFRLE9BQU8sT0FBTyxRQUFRO0FBQUEsSUFDOUQ7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxpQkFBaUIsT0FBTztBQUMvQixNQUFJLFlBQVksS0FBSyxHQUFHO0FBQ3RCLFlBQVEsV0FBVyxLQUFLO0FBQ3hCLFVBQU0sV0FBVztBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUNGO0FBQ0EsU0FBUyxrQkFBa0IsT0FBTztBQUNoQyxTQUFPLFlBQVksS0FBSyxJQUFJLE1BQU0sV0FBVyxNQUFNLFNBQVMsS0FBSyxTQUFTO0FBQzVFO0FBQ0EsU0FBUyxtQkFBbUIsT0FBTyxPQUFPO0FBQ3hDLE1BQUksTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXO0FBQzFDLHVCQUFtQixNQUFNLFVBQVUsU0FBUyxLQUFLO0FBQUEsRUFDbkQsV0FBVyxNQUFNLFlBQVksS0FBSztBQUNoQyxVQUFNLFVBQVUsYUFBYSxNQUFNLE1BQU0sTUFBTSxTQUFTO0FBQ3hELFVBQU0sV0FBVyxhQUFhLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFBQSxFQUM1RCxPQUFPO0FBQ0wsVUFBTSxhQUFhO0FBQUEsRUFDckI7QUFDRjtBQUNBLFNBQVMseUJBQXlCLFVBQVUsY0FBYyxPQUFPLFdBQVc7QUFDMUUsTUFBSSxNQUFNLENBQUM7QUFDWCxNQUFJLHFCQUFxQjtBQUN6QixXQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLFFBQUksUUFBUSxTQUFTO0FBQ3JCLFVBQU0sTUFBTSxhQUFhLE9BQU8sTUFBTSxNQUFNLE9BQU8sU0FBUyxJQUFJLE9BQU8sTUFBTSxPQUFPLE9BQU8sTUFBTSxNQUFNLENBQUM7QUFDeEcsUUFBSSxNQUFNLFNBQVMsVUFBVTtBQUMzQixVQUFJLE1BQU0sWUFBWTtBQUNwQjtBQUNGLFlBQU0sSUFBSTtBQUFBLFFBQ1IseUJBQXlCLE1BQU0sVUFBVSxhQUFhLEdBQUc7QUFBQSxNQUMzRDtBQUFBLElBQ0YsV0FBVyxlQUFlLE1BQU0sU0FBUyxTQUFTO0FBQ2hELFVBQUksS0FBSyxPQUFPLE9BQU8sV0FBVyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksS0FBSztBQUFBLElBQzNEO0FBQUEsRUFDRjtBQUNBLE1BQUkscUJBQXFCLEdBQUc7QUFDMUIsYUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxVQUFJLEdBQUcsWUFBWTtBQUFBLElBQ3JCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUVBLFNBQVMsZ0JBQWdCLFNBQVMsY0FBYztBQUM5QyxTQUFPLFdBQVcsT0FBTyxJQUdOLHVCQUFNLE9BQU8sRUFBRSxNQUFNLFFBQVEsS0FBSyxHQUFHLGNBQWMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxHQUFHLElBQ3ZGO0FBQ047QUFFQSxJQUFNLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSztBQXlJdkMsSUFBTSxjQUFjLENBQUMsVUFBVSxNQUFNLEtBQUs7QUEwTTFDLFNBQVMsWUFBWSxNQUFNLFFBQVE7QUFDakMsd0JBQXNCLE1BQU0sS0FBSyxNQUFNO0FBQ3pDO0FBQ0EsU0FBUyxjQUFjLE1BQU0sUUFBUTtBQUNuQyx3QkFBc0IsTUFBTSxNQUFNLE1BQU07QUFDMUM7QUFDQSxTQUFTLHNCQUFzQixNQUFNLE1BQU0sU0FBUyxpQkFBaUI7QUFDbkUsUUFBTSxjQUFjLEtBQUssVUFBVSxLQUFLLFFBQVEsTUFBTTtBQUNwRCxRQUFJLFVBQVU7QUFDZCxXQUFPLFNBQVM7QUFDZCxVQUFJLFFBQVEsZUFBZTtBQUN6QjtBQUFBLE1BQ0Y7QUFDQSxnQkFBVSxRQUFRO0FBQUEsSUFDcEI7QUFDQSxXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQ0EsYUFBVyxNQUFNLGFBQWEsTUFBTTtBQUNwQyxNQUFJLFFBQVE7QUFDVixRQUFJLFVBQVUsT0FBTztBQUNyQixXQUFPLFdBQVcsUUFBUSxRQUFRO0FBQ2hDLFVBQUksWUFBWSxRQUFRLE9BQU8sS0FBSyxHQUFHO0FBQ3JDLDhCQUFzQixhQUFhLE1BQU0sUUFBUSxPQUFPO0FBQUEsTUFDMUQ7QUFDQSxnQkFBVSxRQUFRO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLHNCQUFzQixNQUFNLE1BQU0sUUFBUSxlQUFlO0FBQ2hFLFFBQU0sV0FBVztBQUFBLElBQ2Y7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUVGO0FBQ0EsY0FBWSxNQUFNO0FBQ2hCLFdBQU8sY0FBYyxPQUFPLFFBQVE7QUFBQSxFQUN0QyxHQUFHLE1BQU07QUFDWDtBQVNBLFNBQVMsV0FBVyxNQUFNLE1BQU0sU0FBUyxpQkFBaUIsVUFBVSxPQUFPO0FBQ3pFLE1BQUksUUFBUTtBQUNWLFVBQU0sUUFBUSxPQUFPLFVBQVUsT0FBTyxRQUFRLENBQUM7QUFDL0MsVUFBTSxjQUFjLEtBQUssVUFBVSxLQUFLLFFBQVEsSUFBSSxTQUFTO0FBQzNELFVBQUksT0FBTyxhQUFhO0FBQ3RCO0FBQUEsTUFDRjtBQUNBLG9CQUFjO0FBQ2QseUJBQW1CLE1BQU07QUFDekIsWUFBTSxNQUFNLDJCQUEyQixNQUFNLFFBQVEsTUFBTSxJQUFJO0FBQy9ELDJCQUFxQjtBQUNyQixvQkFBYztBQUNkLGFBQU87QUFBQSxJQUNUO0FBQ0EsUUFBSSxTQUFTO0FBQ1gsWUFBTSxRQUFRLFdBQVc7QUFBQSxJQUMzQixPQUFPO0FBQ0wsWUFBTSxLQUFLLFdBQVc7QUFBQSxJQUN4QjtBQUNBLFdBQU87QUFBQSxFQUNULFdBQVcsT0FBMkM7QUFDcEQsVUFBTSxVQUFVLGFBQWEsaUJBQWlCLE1BQU0sUUFBUSxVQUFVLEVBQUUsQ0FBQztBQUN6RTtBQUFBLE1BQ0UsR0FBRztBQUFBLElBQ0w7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLGFBQWEsQ0FBQyxjQUFjLENBQUMsTUFBTSxTQUFTLHFCQUUvQyxDQUFDLHlCQUF5QixjQUFjLFNBQVMsV0FBVyxXQUFXLElBQUksU0FBUyxLQUFLLEdBQUcsSUFBSSxHQUFHLE1BQU07QUFFNUcsSUFBTSxnQkFBZ0IsV0FBVyxJQUFJO0FBQ3JDLElBQU0sWUFBWSxXQUFXLEdBQUc7QUFDaEMsSUFBTSxpQkFBaUIsV0FBVyxJQUFJO0FBQ3RDLElBQU0sWUFBWSxXQUFXLEdBQUc7QUFDaEMsSUFBTSxrQkFBa0IsV0FBVyxLQUFLO0FBQ3hDLElBQU0sY0FBYyxXQUFXLElBQUk7QUFDbkMsSUFBTSxtQkFBbUIsV0FBVyxJQUFJO0FBQ3hDLElBQU0sb0JBQW9CO0FBQUEsRUFDeEI7QUFDRjtBQUNBLElBQU0sa0JBQWtCO0FBQUEsRUFDdEI7QUFDRjtBQUNBLFNBQVMsZ0JBQWdCLE1BQU0sU0FBUyxpQkFBaUI7QUFDdkQsYUFBVyxNQUFNLE1BQU0sTUFBTTtBQUMvQjtBQU9BLElBQU0seUJBQXlCLE9BQU8sSUFBSSxPQUFPO0FBa0RqRCxTQUFTLFdBQVcsUUFBUSxZQUFZLE9BQU8sT0FBTztBQUNwRCxNQUFJO0FBQ0osUUFBTSxTQUFTLFNBQVMsTUFBTTtBQUM5QixNQUFJLFFBQVEsTUFBTSxLQUFLLFNBQVMsTUFBTSxHQUFHO0FBQ3ZDLFVBQU0sSUFBSSxNQUFNLE9BQU8sTUFBTTtBQUM3QixhQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sUUFBUSxJQUFJLEdBQUcsS0FBSztBQUM3QyxVQUFJLEtBQUssV0FBVyxPQUFPLElBQUksR0FBRyxRQUFRLFVBQVUsT0FBTyxFQUFFO0FBQUEsSUFDL0Q7QUFBQSxFQUNGLFdBQVcsT0FBTyxXQUFXLFVBQVU7QUFDckMsUUFBSSxPQUF3RTtBQUMxRSxXQUFLLG1EQUFtRCxTQUFTO0FBQUEsSUFDbkU7QUFDQSxVQUFNLElBQUksTUFBTSxNQUFNO0FBQ3RCLGFBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxLQUFLO0FBQy9CLFVBQUksS0FBSyxXQUFXLElBQUksR0FBRyxHQUFHLFFBQVEsVUFBVSxPQUFPLEVBQUU7QUFBQSxJQUMzRDtBQUFBLEVBQ0YsV0FBVyxTQUFTLE1BQU0sR0FBRztBQUMzQixRQUFJLE9BQU8sT0FBTyxXQUFXO0FBQzNCLFlBQU0sTUFBTTtBQUFBLFFBQ1Y7QUFBQSxRQUNBLENBQUMsTUFBTSxNQUFNLFdBQVcsTUFBTSxHQUFHLFFBQVEsVUFBVSxPQUFPLEVBQUU7QUFBQSxNQUM5RDtBQUFBLElBQ0YsT0FBTztBQUNMLFlBQU0sT0FBTyxPQUFPLEtBQUssTUFBTTtBQUMvQixZQUFNLElBQUksTUFBTSxLQUFLLE1BQU07QUFDM0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDM0MsY0FBTSxNQUFNLEtBQUs7QUFDakIsWUFBSSxLQUFLLFdBQVcsT0FBTyxNQUFNLEtBQUssR0FBRyxVQUFVLE9BQU8sRUFBRTtBQUFBLE1BQzlEO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLFVBQU0sQ0FBQztBQUFBLEVBQ1Q7QUFDQSxNQUFJLE9BQU87QUFDVCxVQUFNLFNBQVM7QUFBQSxFQUNqQjtBQUNBLFNBQU87QUFDVDtBQWlGQSxJQUFNLG9CQUFvQixDQUFDLE1BQU07QUFDL0IsTUFBSSxDQUFDO0FBQ0gsV0FBTztBQUNULE1BQUksb0JBQW9CLENBQUM7QUFDdkIsV0FBTyxlQUFlLENBQUMsS0FBSyxFQUFFO0FBQ2hDLFNBQU8sa0JBQWtCLEVBQUUsTUFBTTtBQUNuQztBQUNBLElBQU0sc0JBR1ksdUJBQXVCLHVCQUFPLE9BQU8sSUFBSSxHQUFHO0FBQUEsRUFDMUQsR0FBRyxDQUFDLE1BQU07QUFBQSxFQUNWLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTTtBQUFBLEVBQ3BCLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFBQSxFQUNoQixRQUFRLENBQUMsTUFBTSxRQUE0QyxnQkFBZ0IsRUFBRSxLQUFLLElBQUksRUFBRTtBQUFBLEVBQ3hGLFFBQVEsQ0FBQyxNQUFNLFFBQTRDLGdCQUFnQixFQUFFLEtBQUssSUFBSSxFQUFFO0FBQUEsRUFDeEYsUUFBUSxDQUFDLE1BQU0sUUFBNEMsZ0JBQWdCLEVBQUUsS0FBSyxJQUFJLEVBQUU7QUFBQSxFQUN4RixPQUFPLENBQUMsTUFBTSxRQUE0QyxnQkFBZ0IsRUFBRSxJQUFJLElBQUksRUFBRTtBQUFBLEVBQ3RGLFNBQVMsQ0FBQyxNQUFNLGtCQUFrQixFQUFFLE1BQU07QUFBQSxFQUMxQyxPQUFPLENBQUMsTUFBTSxrQkFBa0IsRUFBRSxJQUFJO0FBQUEsRUFDdEMsT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUFBLEVBQ2hCLFVBQVUsQ0FBQyxNQUFNLE9BQXNCLHFCQUFxQixDQUFDLElBQUksRUFBRTtBQUFBLEVBQ25FLGNBQWMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksTUFBTSxTQUFTLEVBQUUsTUFBTTtBQUFBLEVBQzFELFdBQVcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksU0FBUyxLQUFLLEVBQUUsS0FBSztBQUFBLEVBQ3JELFFBQVEsQ0FBQyxNQUFNLE9BQXNCLGNBQWMsS0FBSyxDQUFDLElBQUk7QUFDL0QsQ0FBQztBQUdILElBQU0sa0JBQWtCLENBQUMsT0FBTyxRQUFRLFVBQVUsYUFBYSxDQUFDLE1BQU0sbUJBQW1CLE9BQU8sT0FBTyxHQUFHO0FBQzFHLElBQU0sOEJBQThCO0FBQUEsRUFDbEMsSUFBSSxFQUFFLEdBQUcsU0FBUyxHQUFHLEtBQUs7QUFDeEIsVUFBTSxFQUFFLEtBQUssWUFBWSxNQUFNLE9BQU8sYUFBYSxNQUFNLFdBQVcsSUFBSTtBQUN4RSxRQUFJLE9BQWdFO0FBQ2xFLGFBQU87QUFBQSxJQUNUO0FBQ0EsUUFBSTtBQUNKLFFBQUksSUFBSSxPQUFPLEtBQUs7QUFDbEIsWUFBTSxJQUFJLFlBQVk7QUFDdEIsVUFBSSxNQUFNLFFBQVE7QUFDaEIsZ0JBQVE7QUFBQSxlQUNEO0FBQ0gsbUJBQU8sV0FBVztBQUFBLGVBQ2Y7QUFDSCxtQkFBTyxLQUFLO0FBQUEsZUFDVDtBQUNILG1CQUFPLElBQUk7QUFBQSxlQUNSO0FBQ0gsbUJBQU8sTUFBTTtBQUFBO0FBQUEsTUFFbkIsV0FBVyxnQkFBZ0IsWUFBWSxHQUFHLEdBQUc7QUFDM0Msb0JBQVksT0FBTztBQUNuQixlQUFPLFdBQVc7QUFBQSxNQUNwQixXQUFXLFNBQVMsYUFBYSxPQUFPLE1BQU0sR0FBRyxHQUFHO0FBQ2xELG9CQUFZLE9BQU87QUFDbkIsZUFBTyxLQUFLO0FBQUEsTUFDZCxZQUdHLGtCQUFrQixTQUFTLGFBQWEsT0FBTyxPQUFPLGlCQUFpQixHQUFHLEdBQzNFO0FBQ0Esb0JBQVksT0FBTztBQUNuQixlQUFPLE1BQU07QUFBQSxNQUNmLFdBQVcsUUFBUSxhQUFhLE9BQU8sS0FBSyxHQUFHLEdBQUc7QUFDaEQsb0JBQVksT0FBTztBQUNuQixlQUFPLElBQUk7QUFBQSxNQUNiLFdBQW1DLG1CQUFtQjtBQUNwRCxvQkFBWSxPQUFPO0FBQUEsTUFDckI7QUFBQSxJQUNGO0FBQ0EsVUFBTSxlQUFlLG9CQUFvQjtBQUN6QyxRQUFJLFdBQVc7QUFDZixRQUFJLGNBQWM7QUFDaEIsVUFBSSxRQUFRLFVBQVU7QUFDcEIsY0FBTSxVQUFVLE9BQU8sR0FBRztBQUFBLE1BRTVCLFdBQVcsT0FBK0Q7QUFDeEUsY0FBTSxVQUFVLE9BQU8sR0FBRztBQUFBLE1BQzVCO0FBQ0EsYUFBTyxhQUFhLFFBQVE7QUFBQSxJQUM5QixZQUVHLFlBQVksS0FBSyxrQkFBa0IsWUFBWSxVQUFVLE9BQzFEO0FBQ0EsYUFBTztBQUFBLElBQ1QsV0FBVyxRQUFRLGFBQWEsT0FBTyxLQUFLLEdBQUcsR0FBRztBQUNoRCxrQkFBWSxPQUFPO0FBQ25CLGFBQU8sSUFBSTtBQUFBLElBQ2IsV0FFRSxtQkFBbUIsV0FBVyxPQUFPLGtCQUFrQixPQUFPLGtCQUFrQixHQUFHLEdBQ25GO0FBQ0E7QUFDRSxlQUFPLGlCQUFpQjtBQUFBLE1BQzFCO0FBQUEsSUFDRixXQUFXLE9BRWdCO0FBQ3pCLFVBQUksU0FBUyxhQUFhLGlCQUFpQixJQUFJLEVBQUUsS0FBSyxPQUFPLE1BQU0sR0FBRyxHQUFHO0FBQ3ZFO0FBQUEsVUFDRSxZQUFZLEtBQUs7QUFBQSxZQUNmO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGLFdBQVcsYUFBYSwwQkFBMEI7QUFDaEQ7QUFBQSxVQUNFLFlBQVksS0FBSyxVQUFVLEdBQUc7QUFBQSxRQUNoQztBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBQ0EsSUFBSSxFQUFFLEdBQUcsU0FBUyxHQUFHLEtBQUssT0FBTztBQUMvQixVQUFNLEVBQUUsTUFBTSxZQUFZLElBQUksSUFBSTtBQUNsQyxRQUFJLGdCQUFnQixZQUFZLEdBQUcsR0FBRztBQUNwQyxpQkFBVyxPQUFPO0FBQ2xCLGFBQU87QUFBQSxJQUNULFdBQVcsT0FBb0c7QUFDN0csV0FBSyx5Q0FBeUMsd0JBQXdCO0FBQ3RFLGFBQU87QUFBQSxJQUNULFdBQVcsU0FBUyxhQUFhLE9BQU8sTUFBTSxHQUFHLEdBQUc7QUFDbEQsV0FBSyxPQUFPO0FBQ1osYUFBTztBQUFBLElBQ1QsV0FBVyxPQUFPLFNBQVMsT0FBTyxHQUFHLEdBQUc7QUFFdEMsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLElBQUksT0FBTyxPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssVUFBVTtBQUk5QyxhQUFPO0FBQUEsSUFDVCxPQUFPO0FBQ0wsVUFBSSxPQUFpRztBQUNuRyxlQUFPLGVBQWUsS0FBSyxLQUFLO0FBQUEsVUFDOUIsWUFBWTtBQUFBLFVBQ1osY0FBYztBQUFBLFVBQ2Q7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNILE9BQU87QUFDTCxZQUFJLE9BQU87QUFBQSxNQUNiO0FBQUEsSUFDRjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxJQUFJO0FBQUEsSUFDRixHQUFHLEVBQUUsTUFBTSxZQUFZLGFBQWEsS0FBSyxZQUFZLGFBQWE7QUFBQSxFQUNwRSxHQUFHLEtBQUs7QUFDTixRQUFJO0FBQ0osV0FBTyxDQUFDLENBQUMsWUFBWSxRQUFRLFNBQVMsYUFBYSxPQUFPLE1BQU0sR0FBRyxLQUFLLGdCQUFnQixZQUFZLEdBQUcsTUFBTSxrQkFBa0IsYUFBYSxPQUFPLE9BQU8saUJBQWlCLEdBQUcsS0FBSyxPQUFPLEtBQUssR0FBRyxLQUFLLE9BQU8scUJBQXFCLEdBQUcsS0FBSyxPQUFPLFdBQVcsT0FBTyxrQkFBa0IsR0FBRztBQUFBLEVBQzNSO0FBQUEsRUFDQSxlQUFlLFFBQVEsS0FBSyxZQUFZO0FBQ3RDLFFBQUksV0FBVyxPQUFPLE1BQU07QUFDMUIsYUFBTyxFQUFFLFlBQVksT0FBTztBQUFBLElBQzlCLFdBQVcsT0FBTyxZQUFZLE9BQU8sR0FBRztBQUN0QyxXQUFLLElBQUksUUFBUSxLQUFLLFdBQVcsT0FBTyxJQUFJO0FBQUEsSUFDOUM7QUFDQSxXQUFPLFFBQVEsZUFBZSxRQUFRLEtBQUssVUFBVTtBQUFBLEVBQ3ZEO0FBQ0Y7QUFDQSxJQUFJLE9BQW1EO0FBQ3JELDhCQUE0QixVQUFVLENBQUMsV0FBVztBQUNoRDtBQUFBLE1BQ0U7QUFBQSxJQUNGO0FBQ0EsV0FBTyxRQUFRLFFBQVEsTUFBTTtBQUFBLEVBQy9CO0FBQ0Y7QUEwS0EsU0FBUyxzQkFBc0IsT0FBTztBQUNwQyxTQUFPLFFBQVEsS0FBSyxJQUFJLE1BQU07QUFBQSxJQUM1QixDQUFDLFlBQVlFLFFBQU8sV0FBV0EsTUFBSyxNQUFNO0FBQUEsSUFDMUMsQ0FBQztBQUFBLEVBQ0gsSUFBSTtBQUNOO0FBdUVBLElBQUksb0JBQW9CO0FBQ3hCLFNBQVMsYUFBYSxVQUFVO0FBQzlCLFFBQU0sVUFBVSxxQkFBcUIsUUFBUTtBQUM3QyxRQUFNLGFBQWEsU0FBUztBQUM1QixRQUFNLE1BQU0sU0FBUztBQUNyQixzQkFBb0I7QUFDcEIsTUFBSSxRQUFRLGNBQWM7QUFDeEIsYUFBUyxRQUFRLGNBQWMsVUFBVSxJQUFJO0FBQUEsRUFDL0M7QUFDQSxRQUFNO0FBQUEsSUFFSixNQUFNO0FBQUEsSUFDTixVQUFVO0FBQUEsSUFDVjtBQUFBLElBQ0EsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsUUFBUTtBQUFBLElBRVI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxRQUFBQztBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUVBO0FBQUEsSUFDQTtBQUFBLElBRUE7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsSUFBSTtBQUNKLFFBQU0sMkJBQTJCLFFBQTRDLHVCQUF1QixJQUFJO0FBQ3hHLE1BQUksT0FBMkM7QUFDN0MsVUFBTSxDQUFDLFlBQVksSUFBSSxTQUFTO0FBQ2hDLFFBQUksY0FBYztBQUNoQixpQkFBVyxPQUFPLGNBQWM7QUFDOUIsaUNBQXlCLFNBQXFCLEdBQUc7QUFBQSxNQUNuRDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxlQUFlO0FBQ2pCLHNCQUFrQixlQUFlLEtBQUssd0JBQXdCO0FBQUEsRUFDaEU7QUFDQSxNQUFJLFNBQVM7QUFDWCxlQUFXLE9BQU8sU0FBUztBQUN6QixZQUFNLGdCQUFnQixRQUFRO0FBQzlCLFVBQUksV0FBVyxhQUFhLEdBQUc7QUFDN0IsWUFBSSxPQUEyQztBQUM3QyxpQkFBTyxlQUFlLEtBQUssS0FBSztBQUFBLFlBQzlCLE9BQU8sY0FBYyxLQUFLLFVBQVU7QUFBQSxZQUNwQyxjQUFjO0FBQUEsWUFDZCxZQUFZO0FBQUEsWUFDWixVQUFVO0FBQUEsVUFDWixDQUFDO0FBQUEsUUFDSCxPQUFPO0FBQ0wsY0FBSSxPQUFPLGNBQWMsS0FBSyxVQUFVO0FBQUEsUUFDMUM7QUFDQSxZQUFJLE9BQTJDO0FBQzdDLG1DQUF5QixXQUF5QixHQUFHO0FBQUEsUUFDdkQ7QUFBQSxNQUNGLFdBQVcsT0FBMkM7QUFDcEQ7QUFBQSxVQUNFLFdBQVcsa0JBQWtCLE9BQU87QUFBQSxRQUN0QztBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksYUFBYTtBQUNmLFFBQUksT0FBdUU7QUFDekU7QUFBQSxRQUNFO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxVQUFNLE9BQU8sWUFBWSxLQUFLLFlBQVksVUFBVTtBQUNwRCxRQUFJLE9BQThEO0FBQ2hFO0FBQUEsUUFDRTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxDQUFDLFNBQVMsSUFBSSxHQUFHO0FBQUEsSUFFckIsT0FBTztBQUNMLGVBQVMsT0FBTyxTQUFTLElBQUk7QUFDN0IsVUFBSSxPQUEyQztBQUM3QyxtQkFBVyxPQUFPLE1BQU07QUFDdEIsbUNBQXlCLFFBQW1CLEdBQUc7QUFDL0MsY0FBSSxDQUFDLGlCQUFpQixJQUFJLEVBQUUsR0FBRztBQUM3QixtQkFBTyxlQUFlLEtBQUssS0FBSztBQUFBLGNBQzlCLGNBQWM7QUFBQSxjQUNkLFlBQVk7QUFBQSxjQUNaLEtBQUssTUFBTSxLQUFLO0FBQUEsY0FDaEIsS0FBSztBQUFBLFlBQ1AsQ0FBQztBQUFBLFVBQ0g7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Esc0JBQW9CO0FBQ3BCLE1BQUksaUJBQWlCO0FBQ25CLGVBQVcsT0FBTyxpQkFBaUI7QUFDakMsWUFBTSxNQUFNLGdCQUFnQjtBQUM1QixZQUFNQyxPQUFNLFdBQVcsR0FBRyxJQUFJLElBQUksS0FBSyxZQUFZLFVBQVUsSUFBSSxXQUFXLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxLQUFLLFlBQVksVUFBVSxJQUFJO0FBQzlILFVBQUksT0FBMkQ7QUFDN0QsYUFBSyxzQkFBc0IscUJBQXFCO0FBQUEsTUFDbEQ7QUFDQSxZQUFNQyxPQUFNLENBQUMsV0FBVyxHQUFHLEtBQUssV0FBVyxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxVQUFVLElBQUksUUFBNEMsTUFBTTtBQUNqSTtBQUFBLFVBQ0UsOENBQThDO0FBQUEsUUFDaEQ7QUFBQSxNQUNGLElBQUk7QUFDSixZQUFNLElBQUlDLFVBQVM7QUFBQSxRQUNqQixLQUFBRjtBQUFBLFFBQ0EsS0FBQUM7QUFBQSxNQUNGLENBQUM7QUFDRCxhQUFPLGVBQWUsS0FBSyxLQUFLO0FBQUEsUUFDOUIsWUFBWTtBQUFBLFFBQ1osY0FBYztBQUFBLFFBQ2QsS0FBSyxNQUFNLEVBQUU7QUFBQSxRQUNiLEtBQUssQ0FBQyxNQUFNLEVBQUUsUUFBUTtBQUFBLE1BQ3hCLENBQUM7QUFDRCxVQUFJLE9BQTJDO0FBQzdDLGlDQUF5QixZQUEyQixHQUFHO0FBQUEsTUFDekQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksY0FBYztBQUNoQixlQUFXLE9BQU8sY0FBYztBQUM5QixvQkFBYyxhQUFhLE1BQU0sS0FBSyxZQUFZLEdBQUc7QUFBQSxJQUN2RDtBQUFBLEVBQ0Y7QUFDQSxNQUFJLGdCQUFnQjtBQUNsQixVQUFNLFdBQVcsV0FBVyxjQUFjLElBQUksZUFBZSxLQUFLLFVBQVUsSUFBSTtBQUNoRixZQUFRLFFBQVEsUUFBUSxFQUFFLFFBQVEsQ0FBQyxRQUFRO0FBQ3pDLGNBQVEsS0FBSyxTQUFTLElBQUk7QUFBQSxJQUM1QixDQUFDO0FBQUEsRUFDSDtBQUNBLE1BQUksU0FBUztBQUNYLGFBQVMsU0FBUyxVQUFVLEdBQUc7QUFBQSxFQUNqQztBQUNBLFdBQVMsc0JBQXNCLFVBQVUsTUFBTTtBQUM3QyxRQUFJLFFBQVEsSUFBSSxHQUFHO0FBQ2pCLFdBQUssUUFBUSxDQUFDLFVBQVUsU0FBUyxNQUFNLEtBQUssVUFBVSxDQUFDLENBQUM7QUFBQSxJQUMxRCxXQUFXLE1BQU07QUFDZixlQUFTLEtBQUssS0FBSyxVQUFVLENBQUM7QUFBQSxJQUNoQztBQUFBLEVBQ0Y7QUFDQSx3QkFBc0IsZUFBZSxXQUFXO0FBQ2hELHdCQUFzQixXQUFXLE9BQU87QUFDeEMsd0JBQXNCLGdCQUFnQixZQUFZO0FBQ2xELHdCQUFzQixXQUFXLE9BQU87QUFDeEMsd0JBQXNCLGFBQWEsU0FBUztBQUM1Qyx3QkFBc0IsZUFBZSxXQUFXO0FBQ2hELHdCQUFzQixpQkFBaUIsYUFBYTtBQUNwRCx3QkFBc0IsaUJBQWlCLGFBQWE7QUFDcEQsd0JBQXNCLG1CQUFtQixlQUFlO0FBQ3hELHdCQUFzQixpQkFBaUIsYUFBYTtBQUNwRCx3QkFBc0IsYUFBYSxTQUFTO0FBQzVDLHdCQUFzQixrQkFBa0IsY0FBYztBQUN0RCxNQUFJLFFBQVEsTUFBTSxHQUFHO0FBQ25CLFFBQUksT0FBTyxRQUFRO0FBQ2pCLFlBQU0sVUFBVSxTQUFTLFlBQVksU0FBUyxVQUFVLENBQUM7QUFDekQsYUFBTyxRQUFRLENBQUMsUUFBUTtBQUN0QixlQUFPLGVBQWUsU0FBUyxLQUFLO0FBQUEsVUFDbEMsS0FBSyxNQUFNLFdBQVc7QUFBQSxVQUN0QixLQUFLLENBQUMsUUFBUSxXQUFXLE9BQU87QUFBQSxRQUNsQyxDQUFDO0FBQUEsTUFDSCxDQUFDO0FBQUEsSUFDSCxXQUFXLENBQUMsU0FBUyxTQUFTO0FBQzVCLGVBQVMsVUFBVSxDQUFDO0FBQUEsSUFDdEI7QUFBQSxFQUNGO0FBQ0EsTUFBSUYsV0FBVSxTQUFTLFdBQVcsTUFBTTtBQUN0QyxhQUFTLFNBQVNBO0FBQUEsRUFDcEI7QUFDQSxNQUFJLGdCQUFnQixNQUFNO0FBQ3hCLGFBQVMsZUFBZTtBQUFBLEVBQzFCO0FBQ0EsTUFBSTtBQUNGLGFBQVMsYUFBYTtBQUN4QixNQUFJO0FBQ0YsYUFBUyxhQUFhO0FBQzFCO0FBQ0EsU0FBUyxrQkFBa0IsZUFBZSxLQUFLLDJCQUEyQixNQUFNO0FBQzlFLE1BQUksUUFBUSxhQUFhLEdBQUc7QUFDMUIsb0JBQWdCLGdCQUFnQixhQUFhO0FBQUEsRUFDL0M7QUFDQSxhQUFXLE9BQU8sZUFBZTtBQUMvQixVQUFNLE1BQU0sY0FBYztBQUMxQixRQUFJO0FBQ0osUUFBSSxTQUFTLEdBQUcsR0FBRztBQUNqQixVQUFJLGFBQWEsS0FBSztBQUNwQixtQkFBVztBQUFBLFVBQ1QsSUFBSSxRQUFRO0FBQUEsVUFDWixJQUFJO0FBQUEsVUFDSjtBQUFBLFFBRUY7QUFBQSxNQUNGLE9BQU87QUFDTCxtQkFBVyxPQUFPLElBQUksUUFBUSxHQUFHO0FBQUEsTUFDbkM7QUFBQSxJQUNGLE9BQU87QUFDTCxpQkFBVyxPQUFPLEdBQUc7QUFBQSxJQUN2QjtBQUNBLFFBQUksTUFBTSxRQUFRLEdBQUc7QUFDbkIsYUFBTyxlQUFlLEtBQUssS0FBSztBQUFBLFFBQzlCLFlBQVk7QUFBQSxRQUNaLGNBQWM7QUFBQSxRQUNkLEtBQUssTUFBTSxTQUFTO0FBQUEsUUFDcEIsS0FBSyxDQUFDLE1BQU0sU0FBUyxRQUFRO0FBQUEsTUFDL0IsQ0FBQztBQUFBLElBQ0gsT0FBTztBQUNMLFVBQUksT0FBTztBQUFBLElBQ2I7QUFDQSxRQUFJLE9BQTJDO0FBQzdDLCtCQUF5QixVQUF1QixHQUFHO0FBQUEsSUFDckQ7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFNBQVMsTUFBTSxVQUFVLE1BQU07QUFDdEM7QUFBQSxJQUNFLFFBQVEsSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDSSxPQUFNQSxHQUFFLEtBQUssU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssU0FBUyxLQUFLO0FBQUEsSUFDbEY7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxjQUFjLEtBQUssS0FBSyxZQUFZLEtBQUs7QUFDaEQsUUFBTSxTQUFTLElBQUksU0FBUyxHQUFHLElBQUksaUJBQWlCLFlBQVksR0FBRyxJQUFJLE1BQU0sV0FBVztBQUN4RixNQUFJLFNBQVMsR0FBRyxHQUFHO0FBQ2pCLFVBQU0sVUFBVSxJQUFJO0FBQ3BCLFFBQUksV0FBVyxPQUFPLEdBQUc7QUFDdkIsWUFBTSxRQUFRLE9BQU87QUFBQSxJQUN2QixXQUFXLE9BQTJDO0FBQ3BELFdBQUssMkNBQTJDLFFBQVEsT0FBTztBQUFBLElBQ2pFO0FBQUEsRUFDRixXQUFXLFdBQVcsR0FBRyxHQUFHO0FBQzFCLFVBQU0sUUFBUSxJQUFJLEtBQUssVUFBVSxDQUFDO0FBQUEsRUFDcEMsV0FBVyxTQUFTLEdBQUcsR0FBRztBQUN4QixRQUFJLFFBQVEsR0FBRyxHQUFHO0FBQ2hCLFVBQUksUUFBUSxDQUFDLE1BQU0sY0FBYyxHQUFHLEtBQUssWUFBWSxHQUFHLENBQUM7QUFBQSxJQUMzRCxPQUFPO0FBQ0wsWUFBTSxVQUFVLFdBQVcsSUFBSSxPQUFPLElBQUksSUFBSSxRQUFRLEtBQUssVUFBVSxJQUFJLElBQUksSUFBSTtBQUNqRixVQUFJLFdBQVcsT0FBTyxHQUFHO0FBQ3ZCLGNBQU0sUUFBUSxTQUFTLEdBQUc7QUFBQSxNQUM1QixXQUFXLE9BQTJDO0FBQ3BELGFBQUssMkNBQTJDLElBQUksWUFBWSxPQUFPO0FBQUEsTUFDekU7QUFBQSxJQUNGO0FBQUEsRUFDRixXQUFXLE9BQTJDO0FBQ3BELFNBQUssMEJBQTBCLFFBQVEsR0FBRztBQUFBLEVBQzVDO0FBQ0Y7QUFDQSxTQUFTLHFCQUFxQixVQUFVO0FBQ3RDLFFBQU0sT0FBTyxTQUFTO0FBQ3RCLFFBQU0sRUFBRSxRQUFRLFNBQVMsZUFBZSxJQUFJO0FBQzVDLFFBQU07QUFBQSxJQUNKLFFBQVE7QUFBQSxJQUNSLGNBQWM7QUFBQSxJQUNkLFFBQVEsRUFBRSxzQkFBc0I7QUFBQSxFQUNsQyxJQUFJLFNBQVM7QUFDYixRQUFNLFNBQVMsTUFBTSxJQUFJLElBQUk7QUFDN0IsTUFBSTtBQUNKLE1BQUksUUFBUTtBQUNWLGVBQVc7QUFBQSxFQUNiLFdBQVcsQ0FBQyxhQUFhLFVBQVUsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCO0FBQzdEO0FBQ0UsaUJBQVc7QUFBQSxJQUNiO0FBQUEsRUFDRixPQUFPO0FBQ0wsZUFBVyxDQUFDO0FBQ1osUUFBSSxhQUFhLFFBQVE7QUFDdkIsbUJBQWE7QUFBQSxRQUNYLENBQUMsTUFBTSxhQUFhLFVBQVUsR0FBRyx1QkFBdUIsSUFBSTtBQUFBLE1BQzlEO0FBQUEsSUFDRjtBQUNBLGlCQUFhLFVBQVUsTUFBTSxxQkFBcUI7QUFBQSxFQUNwRDtBQUNBLE1BQUksU0FBUyxJQUFJLEdBQUc7QUFDbEIsVUFBTSxJQUFJLE1BQU0sUUFBUTtBQUFBLEVBQzFCO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxhQUFhLElBQUksTUFBTSxRQUFRLFVBQVUsT0FBTztBQUN2RCxRQUFNLEVBQUUsUUFBUSxTQUFTLGVBQWUsSUFBSTtBQUM1QyxNQUFJLGdCQUFnQjtBQUNsQixpQkFBYSxJQUFJLGdCQUFnQixRQUFRLElBQUk7QUFBQSxFQUMvQztBQUNBLE1BQUksUUFBUTtBQUNWLFdBQU87QUFBQSxNQUNMLENBQUMsTUFBTSxhQUFhLElBQUksR0FBRyxRQUFRLElBQUk7QUFBQSxJQUN6QztBQUFBLEVBQ0Y7QUFDQSxhQUFXLE9BQU8sTUFBTTtBQUN0QixRQUFJLFdBQVcsUUFBUSxVQUFVO0FBQUEsSUFJakMsT0FBTztBQUNMLFlBQU0sUUFBUSwwQkFBMEIsUUFBUSxVQUFVLE9BQU87QUFDakUsU0FBRyxPQUFPLFFBQVEsTUFBTSxHQUFHLE1BQU0sS0FBSyxJQUFJLElBQUksS0FBSztBQUFBLElBQ3JEO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLElBQU0sNEJBQTRCO0FBQUEsRUFDaEMsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBRVAsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBRVYsY0FBYztBQUFBLEVBQ2QsU0FBUztBQUFBLEVBQ1QsYUFBYTtBQUFBLEVBQ2IsU0FBUztBQUFBLEVBQ1QsY0FBYztBQUFBLEVBQ2QsU0FBUztBQUFBLEVBQ1QsZUFBZTtBQUFBLEVBQ2YsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsV0FBVztBQUFBLEVBQ1gsV0FBVztBQUFBLEVBQ1gsYUFBYTtBQUFBLEVBQ2IsZUFBZTtBQUFBLEVBQ2YsZ0JBQWdCO0FBQUEsRUFFaEIsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBRVosT0FBTztBQUFBLEVBRVAsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUNWO0FBQ0EsU0FBUyxZQUFZLElBQUksTUFBTTtBQUM3QixNQUFJLENBQUMsTUFBTTtBQUNULFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxDQUFDLElBQUk7QUFDUCxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sU0FBUyxlQUFlO0FBQzdCLFdBQVE7QUFBQSxNQUNOLFdBQVcsRUFBRSxJQUFJLEdBQUcsS0FBSyxNQUFNLElBQUksSUFBSTtBQUFBLE1BQ3ZDLFdBQVcsSUFBSSxJQUFJLEtBQUssS0FBSyxNQUFNLElBQUksSUFBSTtBQUFBLElBQzdDO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxZQUFZLElBQUksTUFBTTtBQUM3QixTQUFPLG1CQUFtQixnQkFBZ0IsRUFBRSxHQUFHLGdCQUFnQixJQUFJLENBQUM7QUFDdEU7QUFDQSxTQUFTLGdCQUFnQixLQUFLO0FBQzVCLE1BQUksUUFBUSxHQUFHLEdBQUc7QUFDaEIsVUFBTSxNQUFNLENBQUM7QUFDYixhQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLFVBQUksSUFBSSxNQUFNLElBQUk7QUFBQSxJQUNwQjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxhQUFhLElBQUksTUFBTTtBQUM5QixTQUFPLEtBQUssQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUk7QUFDbEQ7QUFDQSxTQUFTLG1CQUFtQixJQUFJLE1BQU07QUFDcEMsU0FBTyxLQUFLLE9BQXVCLHVCQUFPLE9BQU8sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJO0FBQ3RFO0FBQ0EsU0FBUyx5QkFBeUIsSUFBSSxNQUFNO0FBQzFDLE1BQUksSUFBSTtBQUNOLFFBQUksUUFBUSxFQUFFLEtBQUssUUFBUSxJQUFJLEdBQUc7QUFDaEMsYUFBTyxDQUFDLEdBQW1CLG9CQUFJLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQ3REO0FBQ0EsV0FBTztBQUFBLE1BQ1csdUJBQU8sT0FBTyxJQUFJO0FBQUEsTUFDbEMsc0JBQXNCLEVBQUU7QUFBQSxNQUN4QixzQkFBc0IsUUFBUSxPQUFPLE9BQU8sQ0FBQyxDQUFDO0FBQUEsSUFDaEQ7QUFBQSxFQUNGLE9BQU87QUFDTCxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBQ0EsU0FBUyxrQkFBa0IsSUFBSSxNQUFNO0FBQ25DLE1BQUksQ0FBQztBQUNILFdBQU87QUFDVCxNQUFJLENBQUM7QUFDSCxXQUFPO0FBQ1QsUUFBTSxTQUFTLE9BQXVCLHVCQUFPLE9BQU8sSUFBSSxHQUFHLEVBQUU7QUFDN0QsYUFBVyxPQUFPLE1BQU07QUFDdEIsV0FBTyxPQUFPLGFBQWEsR0FBRyxNQUFNLEtBQUssSUFBSTtBQUFBLEVBQy9DO0FBQ0EsU0FBTztBQUNUO0FBRUEsU0FBUyxtQkFBbUI7QUFDMUIsU0FBTztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLE1BQ04sYUFBYTtBQUFBLE1BQ2IsYUFBYTtBQUFBLE1BQ2Isa0JBQWtCLENBQUM7QUFBQSxNQUNuQix1QkFBdUIsQ0FBQztBQUFBLE1BQ3hCLGNBQWM7QUFBQSxNQUNkLGFBQWE7QUFBQSxNQUNiLGlCQUFpQixDQUFDO0FBQUEsSUFDcEI7QUFBQSxJQUNBLFFBQVEsQ0FBQztBQUFBLElBQ1QsWUFBWSxDQUFDO0FBQUEsSUFDYixZQUFZLENBQUM7QUFBQSxJQUNiLFVBQTBCLHVCQUFPLE9BQU8sSUFBSTtBQUFBLElBQzVDLGNBQThCLG9CQUFJLFFBQVE7QUFBQSxJQUMxQyxZQUE0QixvQkFBSSxRQUFRO0FBQUEsSUFDeEMsWUFBNEIsb0JBQUksUUFBUTtBQUFBLEVBQzFDO0FBQ0Y7QUFDQSxJQUFJLFFBQVE7QUFDWixTQUFTLGFBQWFKLFNBQVEsU0FBUztBQUNyQyxTQUFPLFNBQVNLLFdBQVUsZUFBZSxZQUFZLE1BQU07QUFDekQsUUFBSSxDQUFDLFdBQVcsYUFBYSxHQUFHO0FBQzlCLHNCQUFnQixPQUFPLENBQUMsR0FBRyxhQUFhO0FBQUEsSUFDMUM7QUFDQSxRQUFJLGFBQWEsUUFBUSxDQUFDLFNBQVMsU0FBUyxHQUFHO0FBRTdDLGtCQUFZO0FBQUEsSUFDZDtBQUNBLFVBQU0sVUFBVSxpQkFBaUI7QUFDakMsUUFBSSxPQUEyQztBQUM3QyxhQUFPLGVBQWUsUUFBUSxRQUFRLHFCQUFxQjtBQUFBLFFBQ3pELE1BQU07QUFDSixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxRQUNBLE1BQU07QUFDSjtBQUFBLFlBQ0U7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0g7QUFDQSxVQUFNLG1CQUFtQyxvQkFBSSxJQUFJO0FBQ2pELFFBQUksWUFBWTtBQUNoQixVQUFNLE1BQU0sUUFBUSxNQUFNO0FBQUEsTUFDeEIsTUFBTTtBQUFBLE1BQ04sWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLE1BQ1YsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBLElBQUksU0FBUztBQUNYLGVBQU8sUUFBUTtBQUFBLE1BQ2pCO0FBQUEsTUFDQSxJQUFJLE9BQU8sR0FBRztBQUNaLFlBQUksT0FBMkM7QUFDN0M7QUFBQSxZQUNFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsTUFDQSxJQUFJLFdBQVcsU0FBUztBQUN0QixZQUFJLGlCQUFpQixJQUFJLE1BQU0sR0FBRztBQUFBLFFBRWxDLFdBQVcsVUFBVSxXQUFXLE9BQU8sT0FBTyxHQUFHO0FBQy9DLDJCQUFpQixJQUFJLE1BQU07QUFDM0IsaUJBQU8sUUFBUSxLQUFLLEdBQUcsT0FBTztBQUFBLFFBQ2hDLFdBQVcsV0FBVyxNQUFNLEdBQUc7QUFDN0IsMkJBQWlCLElBQUksTUFBTTtBQUMzQixpQkFBTyxLQUFLLEdBQUcsT0FBTztBQUFBLFFBQ3hCLFdBQVcsT0FBMkM7QUFDcEQ7QUFBQSxZQUNFO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsTUFBTSxPQUFPO0FBQ1gsWUFBSSxNQUFxQjtBQUN2QixjQUFJLENBQUMsUUFBUSxPQUFPLFNBQVMsS0FBSyxHQUFHO0FBQ25DLG9CQUFRLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDM0IsV0FBVyxPQUEyQztBQUNwRDtBQUFBLGNBQ0Usa0RBQWtELE1BQU0sT0FBTyxLQUFLLE1BQU0sU0FBUztBQUFBLFlBQ3JGO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVyxPQUEyQztBQUNwRCxlQUFLLDREQUE0RDtBQUFBLFFBQ25FO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLFVBQVUsTUFBTSxXQUFXO0FBQ3pCLFlBQUksT0FBMkM7QUFDN0MsZ0NBQXNCLE1BQU0sUUFBUSxNQUFNO0FBQUEsUUFDNUM7QUFDQSxZQUFJLENBQUMsV0FBVztBQUNkLGlCQUFPLFFBQVEsV0FBVztBQUFBLFFBQzVCO0FBQ0EsWUFBSSxPQUF1RTtBQUN6RSxlQUFLLGNBQWMsa0RBQWtEO0FBQUEsUUFDdkU7QUFDQSxnQkFBUSxXQUFXLFFBQVE7QUFDM0IsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLFVBQVUsTUFBTSxXQUFXO0FBQ3pCLFlBQUksT0FBMkM7QUFDN0MsZ0NBQXNCLElBQUk7QUFBQSxRQUM1QjtBQUNBLFlBQUksQ0FBQyxXQUFXO0FBQ2QsaUJBQU8sUUFBUSxXQUFXO0FBQUEsUUFDNUI7QUFDQSxZQUFJLE9BQXVFO0FBQ3pFLGVBQUssY0FBYyxrREFBa0Q7QUFBQSxRQUN2RTtBQUNBLGdCQUFRLFdBQVcsUUFBUTtBQUMzQixlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsTUFBTSxlQUFlLFdBQVcsT0FBTztBQUNyQyxZQUFJLENBQUMsV0FBVztBQUNkLGNBQUksT0FBd0U7QUFDMUU7QUFBQSxjQUNFO0FBQUE7QUFBQSxZQUVGO0FBQUEsVUFDRjtBQUNBLGdCQUFNLFFBQVE7QUFBQSxZQUNaO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxhQUFhO0FBQ25CLGNBQUksT0FBMkM7QUFDN0Msb0JBQVEsU0FBUyxNQUFNO0FBQ3JCLGNBQUFMLFFBQU8sV0FBVyxLQUFLLEdBQUcsZUFBZSxLQUFLO0FBQUEsWUFDaEQ7QUFBQSxVQUNGO0FBQ0EsY0FBSSxhQUFhLFNBQVM7QUFDeEIsb0JBQVEsT0FBTyxhQUFhO0FBQUEsVUFDOUIsT0FBTztBQUNMLFlBQUFBLFFBQU8sT0FBTyxlQUFlLEtBQUs7QUFBQSxVQUNwQztBQUNBLHNCQUFZO0FBQ1osY0FBSSxhQUFhO0FBQ2pCLHdCQUFjLGNBQWM7QUFDNUIsY0FBaUQsT0FBdUI7QUFDdEUsZ0JBQUksWUFBWSxNQUFNO0FBQ3RCLDRCQUFnQixLQUFLLE9BQU87QUFBQSxVQUM5QjtBQUNBLGlCQUFPLGVBQWUsTUFBTSxTQUFTLEtBQUssTUFBTSxVQUFVO0FBQUEsUUFDNUQsV0FBVyxPQUEyQztBQUNwRDtBQUFBLFlBQ0U7QUFBQTtBQUFBLFVBRUY7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLE1BQ0EsVUFBVTtBQUNSLFlBQUksV0FBVztBQUNiLFVBQUFBLFFBQU8sTUFBTSxJQUFJLFVBQVU7QUFDM0IsY0FBaUQsT0FBdUI7QUFDdEUsZ0JBQUksWUFBWTtBQUNoQiwrQkFBbUIsR0FBRztBQUFBLFVBQ3hCO0FBQ0EsaUJBQU8sSUFBSSxXQUFXO0FBQUEsUUFDeEIsV0FBVyxPQUEyQztBQUNwRCxlQUFLLDRDQUE0QztBQUFBLFFBQ25EO0FBQUEsTUFDRjtBQUFBLE1BQ0EsUUFBUSxLQUFLLE9BQU87QUFDbEIsWUFBSSxPQUFzRTtBQUN4RTtBQUFBLFlBQ0UsMkNBQTJDLE9BQU8sR0FBRztBQUFBLFVBQ3ZEO0FBQUEsUUFDRjtBQUNBLGdCQUFRLFNBQVMsT0FBTztBQUN4QixlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsZUFBZSxJQUFJO0FBQ2pCLHFCQUFhO0FBQ2IsWUFBSTtBQUNGLGlCQUFPLEdBQUc7QUFBQSxRQUNaLFVBQUU7QUFDQSx1QkFBYTtBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFDQSxJQUFJLGFBQWE7QUFFakIsU0FBUyxRQUFRLEtBQUssT0FBTztBQUMzQixNQUFJLENBQUMsaUJBQWlCO0FBQ3BCLFFBQUksT0FBMkM7QUFDN0MsV0FBSyw0Q0FBNEM7QUFBQSxJQUNuRDtBQUFBLEVBQ0YsT0FBTztBQUNMLFFBQUksV0FBVyxnQkFBZ0I7QUFDL0IsVUFBTSxpQkFBaUIsZ0JBQWdCLFVBQVUsZ0JBQWdCLE9BQU87QUFDeEUsUUFBSSxtQkFBbUIsVUFBVTtBQUMvQixpQkFBVyxnQkFBZ0IsV0FBVyxPQUFPLE9BQU8sY0FBYztBQUFBLElBQ3BFO0FBQ0EsYUFBUyxPQUFPO0FBQUEsRUFDbEI7QUFDRjtBQUNBLFNBQVMsT0FBTyxLQUFLLGNBQWMsd0JBQXdCLE9BQU87QUFDaEUsUUFBTSxXQUFXLG1CQUFtQjtBQUNwQyxNQUFJLFlBQVksWUFBWTtBQUMxQixVQUFNLFdBQVcsV0FBVyxTQUFTLFVBQVUsT0FBTyxTQUFTLE1BQU0sY0FBYyxTQUFTLE1BQU0sV0FBVyxXQUFXLFNBQVMsT0FBTyxXQUFXLFdBQVcsU0FBUztBQUN2SyxRQUFJLFlBQVksT0FBTyxVQUFVO0FBQy9CLGFBQU8sU0FBUztBQUFBLElBQ2xCLFdBQVcsVUFBVSxTQUFTLEdBQUc7QUFDL0IsYUFBTyx5QkFBeUIsV0FBVyxZQUFZLElBQUksYUFBYSxLQUFLLFlBQVksU0FBUyxLQUFLLElBQUk7QUFBQSxJQUM3RyxXQUFXLE9BQTJDO0FBQ3BELFdBQUssY0FBYyxPQUFPLEdBQUcsZUFBZTtBQUFBLElBQzlDO0FBQUEsRUFDRixXQUFXLE9BQTJDO0FBQ3BELFNBQUssb0VBQW9FO0FBQUEsRUFDM0U7QUFDRjtBQUtBLFNBQVMsVUFBVSxVQUFVLFVBQVUsWUFBWSxRQUFRLE9BQU87QUFDaEUsUUFBTSxRQUFRLENBQUM7QUFDZixRQUFNLFFBQVEsQ0FBQztBQUNmLE1BQUksT0FBTyxtQkFBbUIsQ0FBQztBQUMvQixXQUFTLGdCQUFnQyx1QkFBTyxPQUFPLElBQUk7QUFDM0QsZUFBYSxVQUFVLFVBQVUsT0FBTyxLQUFLO0FBQzdDLGFBQVcsT0FBTyxTQUFTLGFBQWEsSUFBSTtBQUMxQyxRQUFJLEVBQUUsT0FBTyxRQUFRO0FBQ25CLFlBQU0sT0FBTztBQUFBLElBQ2Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxPQUEyQztBQUM3QyxrQkFBYyxZQUFZLENBQUMsR0FBRyxPQUFPLFFBQVE7QUFBQSxFQUMvQztBQUNBLE1BQUksWUFBWTtBQUNkLGFBQVMsUUFBUSxRQUFRLFFBQVEsZ0JBQWdCLEtBQUs7QUFBQSxFQUN4RCxPQUFPO0FBQ0wsUUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPO0FBQ3hCLGVBQVMsUUFBUTtBQUFBLElBQ25CLE9BQU87QUFDTCxlQUFTLFFBQVE7QUFBQSxJQUNuQjtBQUFBLEVBQ0Y7QUFDQSxXQUFTLFFBQVE7QUFDbkI7QUFRQSxTQUFTLFlBQVksVUFBVSxVQUFVLGNBQWMsV0FBVztBQUNoRSxRQUFNO0FBQUEsSUFDSjtBQUFBLElBQ0E7QUFBQSxJQUNBLE9BQU8sRUFBRSxVQUFVO0FBQUEsRUFDckIsSUFBSTtBQUNKLFFBQU0sa0JBQWtCLE1BQU0sS0FBSztBQUNuQyxRQUFNLENBQUMsT0FBTyxJQUFJLFNBQVM7QUFDM0IsTUFBSSxrQkFBa0I7QUFDdEIsT0FJK0UsYUFBYSxZQUFZLE1BQU0sRUFBRSxZQUFZLEtBQzFIO0FBQ0EsUUFBSSxZQUFZLEdBQUc7QUFDakIsWUFBTSxnQkFBZ0IsU0FBUyxNQUFNO0FBQ3JDLGVBQVMsSUFBSSxHQUFHLElBQUksY0FBYyxRQUFRLEtBQUs7QUFDN0MsWUFBSSxNQUFNLGNBQWM7QUFDeEIsWUFBSSxlQUFlLFNBQVMsY0FBYyxHQUFHLEdBQUc7QUFDOUM7QUFBQSxRQUNGO0FBQ0EsY0FBTSxRQUFRLFNBQVM7QUFDdkIsWUFBSSxTQUFTO0FBQ1gsY0FBSSxPQUFPLE9BQU8sR0FBRyxHQUFHO0FBQ3RCLGdCQUFJLFVBQVUsTUFBTSxNQUFNO0FBQ3hCLG9CQUFNLE9BQU87QUFDYixnQ0FBa0I7QUFBQSxZQUNwQjtBQUFBLFVBQ0YsT0FBTztBQUNMLGtCQUFNLGVBQWUsU0FBUyxHQUFHO0FBQ2pDLGtCQUFNLGdCQUFnQjtBQUFBLGNBQ3BCO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxZQUVGO0FBQUEsVUFDRjtBQUFBLFFBQ0YsT0FBTztBQUNMLGNBQUksVUFBVSxNQUFNLE1BQU07QUFDeEIsa0JBQU0sT0FBTztBQUNiLDhCQUFrQjtBQUFBLFVBQ3BCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBQ0wsUUFBSSxhQUFhLFVBQVUsVUFBVSxPQUFPLEtBQUssR0FBRztBQUNsRCx3QkFBa0I7QUFBQSxJQUNwQjtBQUNBLFFBQUk7QUFDSixlQUFXLE9BQU8saUJBQWlCO0FBQ2pDLFVBQUksQ0FBQyxZQUNMLENBQUMsT0FBTyxVQUFVLEdBQUcsT0FFbkIsV0FBVyxVQUFVLEdBQUcsT0FBTyxPQUFPLENBQUMsT0FBTyxVQUFVLFFBQVEsSUFBSTtBQUNwRSxZQUFJLFNBQVM7QUFDWCxjQUFJLGlCQUNILGFBQWEsU0FBUyxVQUN2QixhQUFhLGNBQWMsU0FBUztBQUNsQyxrQkFBTSxPQUFPO0FBQUEsY0FDWDtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsWUFFRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGLE9BQU87QUFDTCxpQkFBTyxNQUFNO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxVQUFVLGlCQUFpQjtBQUM3QixpQkFBVyxPQUFPLE9BQU87QUFDdkIsWUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLFVBQVUsR0FBRyxLQUFLLE1BQU07QUFDL0MsaUJBQU8sTUFBTTtBQUNiLDRCQUFrQjtBQUFBLFFBQ3BCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsTUFBSSxpQkFBaUI7QUFDbkIsWUFBUSxVQUFVLE9BQU8sUUFBUTtBQUFBLEVBQ25DO0FBQ0EsTUFBSSxPQUEyQztBQUM3QyxrQkFBYyxZQUFZLENBQUMsR0FBRyxPQUFPLFFBQVE7QUFBQSxFQUMvQztBQUNGO0FBQ0EsU0FBUyxhQUFhLFVBQVUsVUFBVSxPQUFPLE9BQU87QUFDdEQsUUFBTSxDQUFDLFNBQVMsWUFBWSxJQUFJLFNBQVM7QUFDekMsTUFBSSxrQkFBa0I7QUFDdEIsTUFBSTtBQUNKLE1BQUksVUFBVTtBQUNaLGFBQVMsT0FBTyxVQUFVO0FBQ3hCLFVBQUksZUFBZSxHQUFHLEdBQUc7QUFDdkI7QUFBQSxNQUNGO0FBQ0EsWUFBTSxRQUFRLFNBQVM7QUFDdkIsVUFBSTtBQUNKLFVBQUksV0FBVyxPQUFPLFNBQVMsV0FBVyxTQUFTLEdBQUcsQ0FBQyxHQUFHO0FBQ3hELFlBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLFNBQVMsUUFBUSxHQUFHO0FBQ3JELGdCQUFNLFlBQVk7QUFBQSxRQUNwQixPQUFPO0FBQ0wsV0FBQyxrQkFBa0IsZ0JBQWdCLENBQUMsSUFBSSxZQUFZO0FBQUEsUUFDdEQ7QUFBQSxNQUNGLFdBQVcsQ0FBQyxlQUFlLFNBQVMsY0FBYyxHQUFHLEdBQUc7QUFDdEQsWUFBSSxFQUFFLE9BQU8sVUFBVSxVQUFVLE1BQU0sTUFBTTtBQUMzQyxnQkFBTSxPQUFPO0FBQ2IsNEJBQWtCO0FBQUEsUUFDcEI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLGNBQWM7QUFDaEIsVUFBTSxrQkFBa0IsTUFBTSxLQUFLO0FBQ25DLFVBQU0sYUFBYSxpQkFBaUI7QUFDcEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLFFBQVEsS0FBSztBQUM1QyxZQUFNLE1BQU0sYUFBYTtBQUN6QixZQUFNLE9BQU87QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLFdBQVc7QUFBQSxRQUNYO0FBQUEsUUFDQSxDQUFDLE9BQU8sWUFBWSxHQUFHO0FBQUEsTUFDekI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsaUJBQWlCLFNBQVMsT0FBTyxLQUFLLE9BQU8sVUFBVSxVQUFVO0FBQ3hFLFFBQU0sTUFBTSxRQUFRO0FBQ3BCLE1BQUksT0FBTyxNQUFNO0FBQ2YsVUFBTSxhQUFhLE9BQU8sS0FBSyxTQUFTO0FBQ3hDLFFBQUksY0FBYyxVQUFVLFFBQVE7QUFDbEMsWUFBTSxlQUFlLElBQUk7QUFDekIsVUFBSSxJQUFJLFNBQVMsWUFBWSxDQUFDLElBQUksZUFBZSxXQUFXLFlBQVksR0FBRztBQUN6RSxjQUFNLEVBQUUsY0FBYyxJQUFJO0FBQzFCLFlBQUksT0FBTyxlQUFlO0FBQ3hCLGtCQUFRLGNBQWM7QUFBQSxRQUN4QixPQUFPO0FBQ0wsNkJBQW1CLFFBQVE7QUFDM0Isa0JBQVEsY0FBYyxPQUFPLGFBQWE7QUFBQSxZQUN4QztBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsK0JBQXFCO0FBQUEsUUFDdkI7QUFBQSxNQUNGLE9BQU87QUFDTCxnQkFBUTtBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxJQUFJLElBQXFCO0FBQzNCLFVBQUksWUFBWSxDQUFDLFlBQVk7QUFDM0IsZ0JBQVE7QUFBQSxNQUNWLFdBQVcsSUFBSSxPQUE0QixVQUFVLE1BQU0sVUFBVSxVQUFVLEdBQUcsSUFBSTtBQUNwRixnQkFBUTtBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsc0JBQXNCLE1BQU0sWUFBWSxVQUFVLE9BQU87QUFDaEUsUUFBTSxRQUFRLFdBQVc7QUFDekIsUUFBTSxTQUFTLE1BQU0sSUFBSSxJQUFJO0FBQzdCLE1BQUksUUFBUTtBQUNWLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxNQUFNLEtBQUs7QUFDakIsUUFBTSxhQUFhLENBQUM7QUFDcEIsUUFBTSxlQUFlLENBQUM7QUFDdEIsTUFBSSxhQUFhO0FBQ2pCLE1BQTJCLENBQUMsV0FBVyxJQUFJLEdBQUc7QUFDNUMsVUFBTSxjQUFjLENBQUMsU0FBUztBQUM1QixtQkFBYTtBQUNiLFlBQU0sQ0FBQyxPQUFPLElBQUksSUFBSSxzQkFBc0IsTUFBTSxZQUFZLElBQUk7QUFDbEUsYUFBTyxZQUFZLEtBQUs7QUFDeEIsVUFBSTtBQUNGLHFCQUFhLEtBQUssR0FBRyxJQUFJO0FBQUEsSUFDN0I7QUFDQSxRQUFJLENBQUMsV0FBVyxXQUFXLE9BQU8sUUFBUTtBQUN4QyxpQkFBVyxPQUFPLFFBQVEsV0FBVztBQUFBLElBQ3ZDO0FBQ0EsUUFBSSxLQUFLLFNBQVM7QUFDaEIsa0JBQVksS0FBSyxPQUFPO0FBQUEsSUFDMUI7QUFDQSxRQUFJLEtBQUssUUFBUTtBQUNmLFdBQUssT0FBTyxRQUFRLFdBQVc7QUFBQSxJQUNqQztBQUFBLEVBQ0Y7QUFDQSxNQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7QUFDdkIsUUFBSSxTQUFTLElBQUksR0FBRztBQUNsQixZQUFNLElBQUksTUFBTSxTQUFTO0FBQUEsSUFDM0I7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksUUFBUSxHQUFHLEdBQUc7QUFDaEIsYUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxVQUFJLE9BQWdFO0FBQ2xFLGFBQUssa0RBQWtELElBQUksRUFBRTtBQUFBLE1BQy9EO0FBQ0EsWUFBTSxnQkFBZ0IsU0FBUyxJQUFJLEVBQUU7QUFDckMsVUFBSSxpQkFBaUIsYUFBYSxHQUFHO0FBQ25DLG1CQUFXLGlCQUFpQjtBQUFBLE1BQzlCO0FBQUEsSUFDRjtBQUFBLEVBQ0YsV0FBVyxLQUFLO0FBQ2QsUUFBSSxPQUE2RDtBQUMvRCxXQUFLLHlCQUF5QixHQUFHO0FBQUEsSUFDbkM7QUFDQSxlQUFXLE9BQU8sS0FBSztBQUNyQixZQUFNLGdCQUFnQixTQUFTLEdBQUc7QUFDbEMsVUFBSSxpQkFBaUIsYUFBYSxHQUFHO0FBQ25DLGNBQU0sTUFBTSxJQUFJO0FBQ2hCLGNBQU0sT0FBTyxXQUFXLGlCQUFpQixRQUFRLEdBQUcsS0FBSyxXQUFXLEdBQUcsSUFBSSxFQUFFLE1BQU0sSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEdBQUc7QUFDekcsWUFBSSxNQUFNO0FBQ1IsZ0JBQU0sZUFBZSxhQUFhLFNBQVMsS0FBSyxJQUFJO0FBQ3BELGdCQUFNLGNBQWMsYUFBYSxRQUFRLEtBQUssSUFBSTtBQUNsRCxlQUFLLEtBQXNCLGVBQWU7QUFDMUMsZUFBSyxLQUEwQixjQUFjLEtBQUssZUFBZTtBQUNqRSxjQUFJLGVBQWUsTUFBTSxPQUFPLE1BQU0sU0FBUyxHQUFHO0FBQ2hELHlCQUFhLEtBQUssYUFBYTtBQUFBLFVBQ2pDO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFFBQU0sTUFBTSxDQUFDLFlBQVksWUFBWTtBQUNyQyxNQUFJLFNBQVMsSUFBSSxHQUFHO0FBQ2xCLFVBQU0sSUFBSSxNQUFNLEdBQUc7QUFBQSxFQUNyQjtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsaUJBQWlCLEtBQUs7QUFDN0IsTUFBSSxJQUFJLE9BQU8sS0FBSztBQUNsQixXQUFPO0FBQUEsRUFDVCxXQUFXLE9BQTJDO0FBQ3BELFNBQUssdUJBQXVCLDhCQUE4QjtBQUFBLEVBQzVEO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxRQUFRLE1BQU07QUFDckIsUUFBTSxRQUFRLFFBQVEsS0FBSyxTQUFTLEVBQUUsTUFBTSw0QkFBNEI7QUFDeEUsU0FBTyxRQUFRLE1BQU0sS0FBSyxTQUFTLE9BQU8sU0FBUztBQUNyRDtBQUNBLFNBQVMsV0FBVyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxRQUFRLENBQUMsTUFBTSxRQUFRLENBQUM7QUFDakM7QUFDQSxTQUFTLGFBQWEsTUFBTSxlQUFlO0FBQ3pDLE1BQUksUUFBUSxhQUFhLEdBQUc7QUFDMUIsV0FBTyxjQUFjLFVBQVUsQ0FBQyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFBQSxFQUMzRCxXQUFXLFdBQVcsYUFBYSxHQUFHO0FBQ3BDLFdBQU8sV0FBVyxlQUFlLElBQUksSUFBSSxJQUFJO0FBQUEsRUFDL0M7QUFDQSxTQUFPO0FBQ1Q7QUFxR0EsSUFBTSxnQkFBZ0IsQ0FBQyxRQUFRLElBQUksT0FBTyxPQUFPLFFBQVE7QUFDekQsSUFBTSxxQkFBcUIsQ0FBQyxVQUFVLFFBQVEsS0FBSyxJQUFJLE1BQU0sSUFBSSxjQUFjLElBQUksQ0FBQyxlQUFlLEtBQUssQ0FBQztBQUN6RyxJQUFNLGdCQUFnQixDQUFDLEtBQUssU0FBUyxRQUFRO0FBQzNDLE1BQUksUUFBUSxJQUFJO0FBQ2QsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLGFBQWEsUUFBUSxJQUFJLFNBQVM7QUFDdEMsUUFBSSxPQUE4RDtBQUNoRTtBQUFBLFFBQ0UsU0FBUztBQUFBLE1BQ1g7QUFBQSxJQUNGO0FBQ0EsV0FBTyxtQkFBbUIsUUFBUSxHQUFHLElBQUksQ0FBQztBQUFBLEVBQzVDLEdBQUcsR0FBRztBQUNOLGFBQVcsS0FBSztBQUNoQixTQUFPO0FBQ1Q7QUFDQSxJQUFNLHVCQUF1QixDQUFDLFVBQVUsT0FBTyxhQUFhO0FBQzFELFFBQU0sTUFBTSxTQUFTO0FBQ3JCLGFBQVcsT0FBTyxVQUFVO0FBQzFCLFFBQUksY0FBYyxHQUFHO0FBQ25CO0FBQ0YsVUFBTSxRQUFRLFNBQVM7QUFDdkIsUUFBSSxXQUFXLEtBQUssR0FBRztBQUNyQixZQUFNLE9BQU8sY0FBYyxLQUFLLE9BQU8sR0FBRztBQUFBLElBQzVDLFdBQVcsU0FBUyxNQUFNO0FBQ3hCLFVBQUksT0FBbUQ7QUFDckQ7QUFBQSxVQUNFLDRDQUE0QztBQUFBLFFBQzlDO0FBQUEsTUFDRjtBQUNBLFlBQU0sYUFBYSxtQkFBbUIsS0FBSztBQUMzQyxZQUFNLE9BQU8sTUFBTTtBQUFBLElBQ3JCO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTSxzQkFBc0IsQ0FBQyxVQUFVLGFBQWE7QUFDbEQsTUFBSSxPQUFtRjtBQUNyRjtBQUFBLE1BQ0U7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFFBQU0sYUFBYSxtQkFBbUIsUUFBUTtBQUM5QyxXQUFTLE1BQU0sVUFBVSxNQUFNO0FBQ2pDO0FBQ0EsSUFBTSxZQUFZLENBQUMsVUFBVSxhQUFhO0FBQ3hDLE1BQUksU0FBUyxNQUFNLFlBQVksSUFBSTtBQUNqQyxVQUFNLE9BQU8sU0FBUztBQUN0QixRQUFJLE1BQU07QUFDUixlQUFTLFFBQVEsTUFBTSxRQUFRO0FBQy9CLFVBQUksVUFBVSxLQUFLLElBQUk7QUFBQSxJQUN6QixPQUFPO0FBQ0w7QUFBQSxRQUNFO0FBQUEsUUFDQSxTQUFTLFFBQVEsQ0FBQztBQUFBLE1BQUM7QUFBQSxJQUN2QjtBQUFBLEVBQ0YsT0FBTztBQUNMLGFBQVMsUUFBUSxDQUFDO0FBQ2xCLFFBQUksVUFBVTtBQUNaLDBCQUFvQixVQUFVLFFBQVE7QUFBQSxJQUN4QztBQUFBLEVBQ0Y7QUFDQSxNQUFJLFNBQVMsT0FBTyxtQkFBbUIsQ0FBQztBQUMxQztBQUNBLElBQU0sY0FBYyxDQUFDLFVBQVUsVUFBVSxjQUFjO0FBQ3JELFFBQU0sRUFBRSxPQUFPLE1BQU0sSUFBSTtBQUN6QixNQUFJLG9CQUFvQjtBQUN4QixNQUFJLDJCQUEyQjtBQUMvQixNQUFJLE1BQU0sWUFBWSxJQUFJO0FBQ3hCLFVBQU0sT0FBTyxTQUFTO0FBQ3RCLFFBQUksTUFBTTtBQUNSLFVBQUksT0FBNEQ7QUFDOUQsZUFBTyxPQUFPLFFBQVE7QUFDdEIsZ0JBQVEsVUFBVSxPQUFPLFFBQVE7QUFBQSxNQUNuQyxXQUFXLGFBQWEsU0FBUyxHQUFHO0FBQ2xDLDRCQUFvQjtBQUFBLE1BQ3RCLE9BQU87QUFDTCxlQUFPLE9BQU8sUUFBUTtBQUN0QixZQUFJLENBQUMsYUFBYSxTQUFTLEdBQUc7QUFDNUIsaUJBQU8sTUFBTTtBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBQUEsSUFDRixPQUFPO0FBQ0wsMEJBQW9CLENBQUMsU0FBUztBQUM5QiwyQkFBcUIsVUFBVSxLQUFLO0FBQUEsSUFDdEM7QUFDQSwrQkFBMkI7QUFBQSxFQUM3QixXQUFXLFVBQVU7QUFDbkIsd0JBQW9CLFVBQVUsUUFBUTtBQUN0QywrQkFBMkIsRUFBRSxTQUFTLEVBQUU7QUFBQSxFQUMxQztBQUNBLE1BQUksbUJBQW1CO0FBQ3JCLGVBQVcsT0FBTyxPQUFPO0FBQ3ZCLFVBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxFQUFFLE9BQU8sMkJBQTJCO0FBQzdELGVBQU8sTUFBTTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBRUEsU0FBUyxPQUFPLFFBQVEsV0FBVyxnQkFBZ0IsT0FBTyxZQUFZLE9BQU87QUFDM0UsTUFBSSxRQUFRLE1BQU0sR0FBRztBQUNuQixXQUFPO0FBQUEsTUFDTCxDQUFDLEdBQUcsTUFBTTtBQUFBLFFBQ1I7QUFBQSxRQUNBLGNBQWMsUUFBUSxTQUFTLElBQUksVUFBVSxLQUFLO0FBQUEsUUFDbEQ7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0E7QUFBQSxFQUNGO0FBQ0EsTUFBSSxlQUFlLEtBQUssS0FBSyxDQUFDLFdBQVc7QUFDdkM7QUFBQSxFQUNGO0FBQ0EsUUFBTSxXQUFXLE1BQU0sWUFBWSxJQUFJLGVBQWUsTUFBTSxTQUFTLEtBQUssTUFBTSxVQUFVLFFBQVEsTUFBTTtBQUN4RyxRQUFNLFFBQVEsWUFBWSxPQUFPO0FBQ2pDLFFBQU0sRUFBRSxHQUFHLE9BQU8sR0FBR00sS0FBSSxJQUFJO0FBQzdCLE1BQUksT0FBcUQ7QUFDdkQ7QUFBQSxNQUNFO0FBQUEsSUFDRjtBQUNBO0FBQUEsRUFDRjtBQUNBLFFBQU0sU0FBUyxhQUFhLFVBQVU7QUFDdEMsUUFBTSxPQUFPLE1BQU0sU0FBUyxZQUFZLE1BQU0sT0FBTyxDQUFDLElBQUksTUFBTTtBQUNoRSxRQUFNLGFBQWEsTUFBTTtBQUN6QixNQUFJLFVBQVUsUUFBUSxXQUFXQSxNQUFLO0FBQ3BDLFFBQUksU0FBUyxNQUFNLEdBQUc7QUFDcEIsV0FBSyxVQUFVO0FBQ2YsVUFBSSxPQUFPLFlBQVksTUFBTSxHQUFHO0FBQzlCLG1CQUFXLFVBQVU7QUFBQSxNQUN2QjtBQUFBLElBQ0YsV0FBVyxNQUFNLE1BQU0sR0FBRztBQUN4QixhQUFPLFFBQVE7QUFBQSxJQUNqQjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFdBQVdBLElBQUcsR0FBRztBQUNuQiwwQkFBc0JBLE1BQUssT0FBTyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUM7QUFBQSxFQUNyRCxPQUFPO0FBQ0wsVUFBTSxZQUFZLFNBQVNBLElBQUc7QUFDOUIsVUFBTSxTQUFTLE1BQU1BLElBQUc7QUFDeEIsUUFBSSxhQUFhLFFBQVE7QUFDdkIsWUFBTSxRQUFRLE1BQU07QUFDbEIsWUFBSSxPQUFPLEdBQUc7QUFDWixnQkFBTSxXQUFXLFlBQVksT0FBTyxZQUFZQSxJQUFHLElBQUksV0FBV0EsUUFBTyxLQUFLQSxRQUFPQSxLQUFJO0FBQ3pGLGNBQUksV0FBVztBQUNiLG9CQUFRLFFBQVEsS0FBSyxPQUFPLFVBQVUsUUFBUTtBQUFBLFVBQ2hELE9BQU87QUFDTCxnQkFBSSxDQUFDLFFBQVEsUUFBUSxHQUFHO0FBQ3RCLGtCQUFJLFdBQVc7QUFDYixxQkFBS0EsUUFBTyxDQUFDLFFBQVE7QUFDckIsb0JBQUksT0FBTyxZQUFZQSxJQUFHLEdBQUc7QUFDM0IsNkJBQVdBLFFBQU8sS0FBS0E7QUFBQSxnQkFDekI7QUFBQSxjQUNGLE9BQU87QUFDTCxnQkFBQUEsS0FBSSxRQUFRLENBQUMsUUFBUTtBQUNyQixvQkFBSSxPQUFPO0FBQ1QsdUJBQUssT0FBTyxLQUFLQSxLQUFJO0FBQUEsY0FDekI7QUFBQSxZQUNGLFdBQVcsQ0FBQyxTQUFTLFNBQVMsUUFBUSxHQUFHO0FBQ3ZDLHVCQUFTLEtBQUssUUFBUTtBQUFBLFlBQ3hCO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVyxXQUFXO0FBQ3BCLGVBQUtBLFFBQU87QUFDWixjQUFJLE9BQU8sWUFBWUEsSUFBRyxHQUFHO0FBQzNCLHVCQUFXQSxRQUFPO0FBQUEsVUFDcEI7QUFBQSxRQUNGLFdBQVcsUUFBUTtBQUNqQixVQUFBQSxLQUFJLFFBQVE7QUFDWixjQUFJLE9BQU87QUFDVCxpQkFBSyxPQUFPLEtBQUs7QUFBQSxRQUNyQixXQUFXLE9BQTJDO0FBQ3BELGVBQUssOEJBQThCQSxNQUFLLElBQUksT0FBT0EsT0FBTTtBQUFBLFFBQzNEO0FBQUEsTUFDRjtBQUNBLFVBQUksT0FBTztBQUNULGNBQU0sS0FBSztBQUNYLDhCQUFzQixPQUFPLGNBQWM7QUFBQSxNQUM3QyxPQUFPO0FBQ0wsY0FBTTtBQUFBLE1BQ1I7QUFBQSxJQUNGLFdBQVcsT0FBMkM7QUFDcEQsV0FBSyw4QkFBOEJBLE1BQUssSUFBSSxPQUFPQSxPQUFNO0FBQUEsSUFDM0Q7QUFBQSxFQUNGO0FBQ0Y7QUE0YkEsU0FBUyxtQkFBbUI7QUFDMUIsUUFBTSxXQUFXLENBQUM7QUFDbEIsTUFBSSxPQUEwQztBQUU1QyxrQkFBYyxFQUFFLHNCQUFzQjtBQUFBLEVBQ3hDO0FBQ0EsTUFBSSxPQUE0QztBQUU5QyxrQkFBYyxFQUFFLHdCQUF3QjtBQUFBLEVBQzFDO0FBQ0EsTUFBSSxPQUE4RDtBQUNoRSxVQUFNLFFBQVEsU0FBUyxTQUFTO0FBQ2hDLFlBQVE7QUFBQSxNQUNOLGVBQWUsUUFBUSxNQUFNLE1BQU0sU0FBUyxLQUFLLElBQUksS0FBSyxRQUFRLFFBQVE7QUFBQTtBQUFBO0FBQUEsSUFHNUU7QUFBQSxFQUNGO0FBQ0Y7QUFFQSxJQUFNLHdCQUF3QjtBQUM5QixTQUFTLGVBQWUsU0FBUztBQUMvQixTQUFPLG1CQUFtQixPQUFPO0FBQ25DO0FBSUEsU0FBUyxtQkFBbUIsU0FBUyxvQkFBb0I7QUFDdkQ7QUFDRSxxQkFBaUI7QUFBQSxFQUNuQjtBQUNBLFFBQU0sU0FBUyxjQUFjO0FBQzdCLFNBQU8sVUFBVTtBQUNqQixNQUFpRCxPQUF1QjtBQUN0RSxvQkFBZ0IsT0FBTyw4QkFBOEIsTUFBTTtBQUFBLEVBQzdEO0FBQ0EsUUFBTTtBQUFBLElBQ0osUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsV0FBVztBQUFBLElBQ1gsZUFBZTtBQUFBLElBQ2YsWUFBWTtBQUFBLElBQ1osZUFBZTtBQUFBLElBQ2YsU0FBUztBQUFBLElBQ1QsZ0JBQWdCO0FBQUEsSUFDaEIsWUFBWTtBQUFBLElBQ1osYUFBYTtBQUFBLElBQ2IsWUFBWSxpQkFBaUI7QUFBQSxJQUM3QixxQkFBcUI7QUFBQSxFQUN2QixJQUFJO0FBQ0osUUFBTSxRQUFRLENBQUMsSUFBSSxJQUFJLFdBQVcsU0FBUyxNQUFNLGtCQUFrQixNQUFNLGlCQUFpQixNQUFNLFFBQVEsT0FBTyxlQUFlLE1BQU0sWUFBWSxRQUE2RCxRQUFRLENBQUMsQ0FBQyxHQUFHLG9CQUFvQjtBQUM1TyxRQUFJLE9BQU8sSUFBSTtBQUNiO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTSxDQUFDLGdCQUFnQixJQUFJLEVBQUUsR0FBRztBQUNsQyxlQUFTLGdCQUFnQixFQUFFO0FBQzNCLGNBQVEsSUFBSSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDakQsV0FBSztBQUFBLElBQ1A7QUFDQSxRQUFJLEdBQUcsY0FBYyxJQUFJO0FBQ3ZCLGtCQUFZO0FBQ1osU0FBRyxrQkFBa0I7QUFBQSxJQUN2QjtBQUNBLFVBQU0sRUFBRSxNQUFNLEtBQUFDLE1BQUssVUFBVSxJQUFJO0FBQ2pDLFlBQVE7QUFBQSxXQUNEO0FBQ0gsb0JBQVksSUFBSSxJQUFJLFdBQVcsTUFBTTtBQUNyQztBQUFBLFdBQ0c7QUFDSCwyQkFBbUIsSUFBSSxJQUFJLFdBQVcsTUFBTTtBQUM1QztBQUFBLFdBQ0c7QUFDSCxZQUFJLE1BQU0sTUFBTTtBQUNkLDBCQUFnQixJQUFJLFdBQVcsUUFBUSxLQUFLO0FBQUEsUUFDOUMsV0FBVyxPQUEyQztBQUNwRCwwQkFBZ0IsSUFBSSxJQUFJLFdBQVcsS0FBSztBQUFBLFFBQzFDO0FBQ0E7QUFBQSxXQUNHO0FBQ0g7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0E7QUFBQTtBQUVBLFlBQUksWUFBWSxHQUFHO0FBQ2pCO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVyxZQUFZLEdBQUc7QUFDeEI7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsUUFDRixXQUFXLFlBQVksSUFBSTtBQUN6QixlQUFLO0FBQUEsWUFDSDtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGLFdBQVcsWUFBWSxLQUFLO0FBQzFCLGVBQUs7QUFBQSxZQUNIO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVyxPQUEyQztBQUNwRCxlQUFLLHVCQUF1QixNQUFNLElBQUksT0FBTyxPQUFPO0FBQUEsUUFDdEQ7QUFBQTtBQUVKLFFBQUlBLFFBQU8sUUFBUSxpQkFBaUI7QUFDbEMsYUFBT0EsTUFBSyxNQUFNLEdBQUcsS0FBSyxnQkFBZ0IsTUFBTSxJQUFJLENBQUMsRUFBRTtBQUFBLElBQ3pEO0FBQUEsRUFDRjtBQUNBLFFBQU0sY0FBYyxDQUFDLElBQUksSUFBSSxXQUFXLFdBQVc7QUFDakQsUUFBSSxNQUFNLE1BQU07QUFDZDtBQUFBLFFBQ0UsR0FBRyxLQUFLLGVBQWUsR0FBRyxRQUFRO0FBQUEsUUFDbEM7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLFlBQU0sS0FBSyxHQUFHLEtBQUssR0FBRztBQUN0QixVQUFJLEdBQUcsYUFBYSxHQUFHLFVBQVU7QUFDL0Isb0JBQVksSUFBSSxHQUFHLFFBQVE7QUFBQSxNQUM3QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxxQkFBcUIsQ0FBQyxJQUFJLElBQUksV0FBVyxXQUFXO0FBQ3hELFFBQUksTUFBTSxNQUFNO0FBQ2Q7QUFBQSxRQUNFLEdBQUcsS0FBSyxrQkFBa0IsR0FBRyxZQUFZLEVBQUU7QUFBQSxRQUMzQztBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRixPQUFPO0FBQ0wsU0FBRyxLQUFLLEdBQUc7QUFBQSxJQUNiO0FBQUEsRUFDRjtBQUNBLFFBQU0sa0JBQWtCLENBQUMsSUFBSSxXQUFXLFFBQVEsVUFBVTtBQUN4RCxLQUFDLEdBQUcsSUFBSSxHQUFHLE1BQU0sSUFBSTtBQUFBLE1BQ25CLEdBQUc7QUFBQSxNQUNIO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLEdBQUc7QUFBQSxNQUNILEdBQUc7QUFBQSxJQUNMO0FBQUEsRUFDRjtBQUNBLFFBQU0sa0JBQWtCLENBQUMsSUFBSSxJQUFJLFdBQVcsVUFBVTtBQUNwRCxRQUFJLEdBQUcsYUFBYSxHQUFHLFVBQVU7QUFDL0IsWUFBTSxTQUFTLGdCQUFnQixHQUFHLE1BQU07QUFDeEMsdUJBQWlCLEVBQUU7QUFDbkIsT0FBQyxHQUFHLElBQUksR0FBRyxNQUFNLElBQUk7QUFBQSxRQUNuQixHQUFHO0FBQUEsUUFDSDtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLFNBQUcsS0FBSyxHQUFHO0FBQ1gsU0FBRyxTQUFTLEdBQUc7QUFBQSxJQUNqQjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGlCQUFpQixDQUFDLEVBQUUsSUFBSSxPQUFPLEdBQUcsV0FBVyxnQkFBZ0I7QUFDakUsUUFBSTtBQUNKLFdBQU8sTUFBTSxPQUFPLFFBQVE7QUFDMUIsYUFBTyxnQkFBZ0IsRUFBRTtBQUN6QixpQkFBVyxJQUFJLFdBQVcsV0FBVztBQUNyQyxXQUFLO0FBQUEsSUFDUDtBQUNBLGVBQVcsUUFBUSxXQUFXLFdBQVc7QUFBQSxFQUMzQztBQUNBLFFBQU0sbUJBQW1CLENBQUMsRUFBRSxJQUFJLE9BQU8sTUFBTTtBQUMzQyxRQUFJO0FBQ0osV0FBTyxNQUFNLE9BQU8sUUFBUTtBQUMxQixhQUFPLGdCQUFnQixFQUFFO0FBQ3pCLGlCQUFXLEVBQUU7QUFDYixXQUFLO0FBQUEsSUFDUDtBQUNBLGVBQVcsTUFBTTtBQUFBLEVBQ25CO0FBQ0EsUUFBTSxpQkFBaUIsQ0FBQyxJQUFJLElBQUksV0FBVyxRQUFRLGlCQUFpQixnQkFBZ0IsT0FBTyxjQUFjLGNBQWM7QUFDckgsWUFBUSxTQUFTLEdBQUcsU0FBUztBQUM3QixRQUFJLE1BQU0sTUFBTTtBQUNkO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRixPQUFPO0FBQ0w7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxlQUFlLENBQUMsT0FBTyxXQUFXLFFBQVEsaUJBQWlCLGdCQUFnQixPQUFPLGNBQWMsY0FBYztBQUNsSCxRQUFJO0FBQ0osUUFBSTtBQUNKLFVBQU0sRUFBRSxNQUFNLE9BQU8sV0FBVyxZQUFZLEtBQUssSUFBSTtBQUNyRCxTQUFLLE1BQU0sS0FBSztBQUFBLE1BQ2QsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLFNBQVMsTUFBTTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxZQUFZLEdBQUc7QUFDakIseUJBQW1CLElBQUksTUFBTSxRQUFRO0FBQUEsSUFDdkMsV0FBVyxZQUFZLElBQUk7QUFDekI7QUFBQSxRQUNFLE1BQU07QUFBQSxRQUNOO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQSxTQUFTLFNBQVM7QUFBQSxRQUNsQjtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTTtBQUNSLDBCQUFvQixPQUFPLE1BQU0saUJBQWlCLFNBQVM7QUFBQSxJQUM3RDtBQUNBLGVBQVcsSUFBSSxPQUFPLE1BQU0sU0FBUyxjQUFjLGVBQWU7QUFDbEUsUUFBSSxPQUFPO0FBQ1QsaUJBQVcsT0FBTyxPQUFPO0FBQ3ZCLFlBQUksUUFBUSxXQUFXLENBQUMsZUFBZSxHQUFHLEdBQUc7QUFDM0M7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBLE1BQU07QUFBQSxZQUNOO0FBQUEsWUFDQSxNQUFNO0FBQUEsWUFDTjtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsVUFBSSxXQUFXLE9BQU87QUFDcEIsc0JBQWMsSUFBSSxTQUFTLE1BQU0sTUFBTSxLQUFLO0FBQUEsTUFDOUM7QUFDQSxVQUFJLFlBQVksTUFBTSxvQkFBb0I7QUFDeEMsd0JBQWdCLFdBQVcsaUJBQWlCLEtBQUs7QUFBQSxNQUNuRDtBQUFBLElBQ0Y7QUFDQSxRQUFpRCxPQUF1QjtBQUN0RSxhQUFPLGVBQWUsSUFBSSxXQUFXO0FBQUEsUUFDbkMsT0FBTztBQUFBLFFBQ1AsWUFBWTtBQUFBLE1BQ2QsQ0FBQztBQUNELGFBQU8sZUFBZSxJQUFJLHdCQUF3QjtBQUFBLFFBQ2hELE9BQU87QUFBQSxRQUNQLFlBQVk7QUFBQSxNQUNkLENBQUM7QUFBQSxJQUNIO0FBQ0EsUUFBSSxNQUFNO0FBQ1IsMEJBQW9CLE9BQU8sTUFBTSxpQkFBaUIsYUFBYTtBQUFBLElBQ2pFO0FBQ0EsVUFBTSwyQkFBMkIsQ0FBQyxrQkFBa0Isa0JBQWtCLENBQUMsZUFBZSxrQkFBa0IsY0FBYyxDQUFDLFdBQVc7QUFDbEksUUFBSSx5QkFBeUI7QUFDM0IsaUJBQVcsWUFBWSxFQUFFO0FBQUEsSUFDM0I7QUFDQSxlQUFXLElBQUksV0FBVyxNQUFNO0FBQ2hDLFNBQUssWUFBWSxTQUFTLE1BQU0sbUJBQW1CLDJCQUEyQixNQUFNO0FBQ2xGLDRCQUFzQixNQUFNO0FBQzFCLHFCQUFhLGdCQUFnQixXQUFXLGlCQUFpQixLQUFLO0FBQzlELG1DQUEyQixXQUFXLE1BQU0sRUFBRTtBQUM5QyxnQkFBUSxvQkFBb0IsT0FBTyxNQUFNLGlCQUFpQixTQUFTO0FBQUEsTUFDckUsR0FBRyxjQUFjO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBQ0EsUUFBTSxhQUFhLENBQUMsSUFBSSxPQUFPLFNBQVMsY0FBYyxvQkFBb0I7QUFDeEUsUUFBSSxTQUFTO0FBQ1gscUJBQWUsSUFBSSxPQUFPO0FBQUEsSUFDNUI7QUFDQSxRQUFJLGNBQWM7QUFDaEIsZUFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLFFBQVEsS0FBSztBQUM1Qyx1QkFBZSxJQUFJLGFBQWEsRUFBRTtBQUFBLE1BQ3BDO0FBQUEsSUFDRjtBQUNBLFFBQUksaUJBQWlCO0FBQ25CLFVBQUksVUFBVSxnQkFBZ0I7QUFDOUIsVUFBSSxPQUFnRztBQUNsRyxrQkFBVSxpQkFBaUIsUUFBUSxRQUFRLEtBQUs7QUFBQSxNQUNsRDtBQUNBLFVBQUksVUFBVSxTQUFTO0FBQ3JCLGNBQU0sY0FBYyxnQkFBZ0I7QUFDcEM7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0EsWUFBWTtBQUFBLFVBQ1osWUFBWTtBQUFBLFVBQ1osZ0JBQWdCO0FBQUEsUUFDbEI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGdCQUFnQixDQUFDLFVBQVUsV0FBVyxRQUFRLGlCQUFpQixnQkFBZ0IsT0FBTyxjQUFjLFdBQVcsUUFBUSxNQUFNO0FBQ2pJLGFBQVMsSUFBSSxPQUFPLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDNUMsWUFBTSxRQUFRLFNBQVMsS0FBSyxZQUFZLGVBQWUsU0FBUyxFQUFFLElBQUksZUFBZSxTQUFTLEVBQUU7QUFDaEc7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGVBQWUsQ0FBQyxJQUFJLElBQUksaUJBQWlCLGdCQUFnQixPQUFPLGNBQWMsY0FBYztBQUNoRyxVQUFNLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDdEIsUUFBSSxFQUFFLFdBQVcsaUJBQWlCLEtBQUssSUFBSTtBQUMzQyxpQkFBYSxHQUFHLFlBQVk7QUFDNUIsVUFBTSxXQUFXLEdBQUcsU0FBUztBQUM3QixVQUFNLFdBQVcsR0FBRyxTQUFTO0FBQzdCLFFBQUk7QUFDSix1QkFBbUIsY0FBYyxpQkFBaUIsS0FBSztBQUN2RCxRQUFJLFlBQVksU0FBUyxxQkFBcUI7QUFDNUMsc0JBQWdCLFdBQVcsaUJBQWlCLElBQUksRUFBRTtBQUFBLElBQ3BEO0FBQ0EsUUFBSSxNQUFNO0FBQ1IsMEJBQW9CLElBQUksSUFBSSxpQkFBaUIsY0FBYztBQUFBLElBQzdEO0FBQ0EsdUJBQW1CLGNBQWMsaUJBQWlCLElBQUk7QUFDdEQsUUFBSSxPQUE0RDtBQUM5RCxrQkFBWTtBQUNaLGtCQUFZO0FBQ1osd0JBQWtCO0FBQUEsSUFDcEI7QUFDQSxVQUFNLGlCQUFpQixTQUFTLEdBQUcsU0FBUztBQUM1QyxRQUFJLGlCQUFpQjtBQUNuQjtBQUFBLFFBQ0UsR0FBRztBQUFBLFFBQ0g7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFDQSxVQUFJLE9BQTJDO0FBQzdDLCtCQUF1QixJQUFJLEVBQUU7QUFBQSxNQUMvQjtBQUFBLElBQ0YsV0FBVyxDQUFDLFdBQVc7QUFDckI7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksWUFBWSxHQUFHO0FBQ2pCLFVBQUksWUFBWSxJQUFJO0FBQ2xCO0FBQUEsVUFDRTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGLE9BQU87QUFDTCxZQUFJLFlBQVksR0FBRztBQUNqQixjQUFJLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFDckMsMEJBQWMsSUFBSSxTQUFTLE1BQU0sU0FBUyxPQUFPLEtBQUs7QUFBQSxVQUN4RDtBQUFBLFFBQ0Y7QUFDQSxZQUFJLFlBQVksR0FBRztBQUNqQix3QkFBYyxJQUFJLFNBQVMsU0FBUyxPQUFPLFNBQVMsT0FBTyxLQUFLO0FBQUEsUUFDbEU7QUFDQSxZQUFJLFlBQVksR0FBRztBQUNqQixnQkFBTSxnQkFBZ0IsR0FBRztBQUN6QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxjQUFjLFFBQVEsS0FBSztBQUM3QyxrQkFBTSxNQUFNLGNBQWM7QUFDMUIsa0JBQU0sT0FBTyxTQUFTO0FBQ3RCLGtCQUFNLE9BQU8sU0FBUztBQUN0QixnQkFBSSxTQUFTLFFBQVEsUUFBUSxTQUFTO0FBQ3BDO0FBQUEsZ0JBQ0U7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLEdBQUc7QUFBQSxnQkFDSDtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLFVBQUksWUFBWSxHQUFHO0FBQ2pCLFlBQUksR0FBRyxhQUFhLEdBQUcsVUFBVTtBQUMvQiw2QkFBbUIsSUFBSSxHQUFHLFFBQVE7QUFBQSxRQUNwQztBQUFBLE1BQ0Y7QUFBQSxJQUNGLFdBQVcsQ0FBQyxhQUFhLG1CQUFtQixNQUFNO0FBQ2hEO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsU0FBSyxZQUFZLFNBQVMsbUJBQW1CLE1BQU07QUFDakQsNEJBQXNCLE1BQU07QUFDMUIscUJBQWEsZ0JBQWdCLFdBQVcsaUJBQWlCLElBQUksRUFBRTtBQUMvRCxnQkFBUSxvQkFBb0IsSUFBSSxJQUFJLGlCQUFpQixTQUFTO0FBQUEsTUFDaEUsR0FBRyxjQUFjO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBQ0EsUUFBTSxxQkFBcUIsQ0FBQyxhQUFhLGFBQWEsbUJBQW1CLGlCQUFpQixnQkFBZ0IsT0FBTyxpQkFBaUI7QUFDaEksYUFBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLFFBQVEsS0FBSztBQUMzQyxZQUFNLFdBQVcsWUFBWTtBQUM3QixZQUFNLFdBQVcsWUFBWTtBQUM3QixZQUFNLFlBR0osU0FBUyxPQUVSLFNBQVMsU0FBUyxZQUVuQixDQUFDLGdCQUFnQixVQUFVLFFBQVEsS0FDbkMsU0FBUyxhQUFhLElBQUksT0FBTyxlQUFlLFNBQVMsRUFBRSxJQUd6RDtBQUdKO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxhQUFhLENBQUMsSUFBSSxPQUFPLFVBQVUsVUFBVSxpQkFBaUIsZ0JBQWdCLFVBQVU7QUFDNUYsUUFBSSxhQUFhLFVBQVU7QUFDekIsVUFBSSxhQUFhLFdBQVc7QUFDMUIsbUJBQVcsT0FBTyxVQUFVO0FBQzFCLGNBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxFQUFFLE9BQU8sV0FBVztBQUM5QztBQUFBLGNBQ0U7QUFBQSxjQUNBO0FBQUEsY0FDQSxTQUFTO0FBQUEsY0FDVDtBQUFBLGNBQ0E7QUFBQSxjQUNBLE1BQU07QUFBQSxjQUNOO0FBQUEsY0FDQTtBQUFBLGNBQ0E7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsaUJBQVcsT0FBTyxVQUFVO0FBQzFCLFlBQUksZUFBZSxHQUFHO0FBQ3BCO0FBQ0YsY0FBTSxPQUFPLFNBQVM7QUFDdEIsY0FBTSxPQUFPLFNBQVM7QUFDdEIsWUFBSSxTQUFTLFFBQVEsUUFBUSxTQUFTO0FBQ3BDO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBLE1BQU07QUFBQSxZQUNOO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxVQUFJLFdBQVcsVUFBVTtBQUN2QixzQkFBYyxJQUFJLFNBQVMsU0FBUyxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQzNEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGtCQUFrQixDQUFDLElBQUksSUFBSSxXQUFXLFFBQVEsaUJBQWlCLGdCQUFnQixPQUFPLGNBQWMsY0FBYztBQUN0SCxVQUFNLHNCQUFzQixHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssZUFBZSxFQUFFO0FBQ2xFLFVBQU0sb0JBQW9CLEdBQUcsU0FBUyxLQUFLLEdBQUcsU0FBUyxlQUFlLEVBQUU7QUFDeEUsUUFBSSxFQUFFLFdBQVcsaUJBQWlCLGNBQWMscUJBQXFCLElBQUk7QUFDekUsUUFBSSxPQUNpQztBQUNuQyxrQkFBWTtBQUNaLGtCQUFZO0FBQ1osd0JBQWtCO0FBQUEsSUFDcEI7QUFDQSxRQUFJLHNCQUFzQjtBQUN4QixxQkFBZSxlQUFlLGFBQWEsT0FBTyxvQkFBb0IsSUFBSTtBQUFBLElBQzVFO0FBQ0EsUUFBSSxNQUFNLE1BQU07QUFDZCxpQkFBVyxxQkFBcUIsV0FBVyxNQUFNO0FBQ2pELGlCQUFXLG1CQUFtQixXQUFXLE1BQU07QUFDL0M7QUFBQSxRQUNFLEdBQUc7QUFBQSxRQUNIO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLFVBQUksWUFBWSxLQUFLLFlBQVksTUFBTSxtQkFFdkMsR0FBRyxpQkFBaUI7QUFDbEI7QUFBQSxVQUNFLEdBQUc7QUFBQSxVQUNIO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0EsWUFBSSxPQUEyQztBQUM3QyxpQ0FBdUIsSUFBSSxFQUFFO0FBQUEsUUFDL0IsV0FLRSxHQUFHLE9BQU8sUUFBUSxtQkFBbUIsT0FBTyxnQkFBZ0IsU0FDNUQ7QUFDQTtBQUFBLFlBQ0U7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBRUY7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0w7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxtQkFBbUIsQ0FBQyxJQUFJLElBQUksV0FBVyxRQUFRLGlCQUFpQixnQkFBZ0IsT0FBTyxjQUFjLGNBQWM7QUFDdkgsT0FBRyxlQUFlO0FBQ2xCLFFBQUksTUFBTSxNQUFNO0FBQ2QsVUFBSSxHQUFHLFlBQVksS0FBSztBQUN0Qix3QkFBZ0IsSUFBSTtBQUFBLFVBQ2xCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGLE9BQU87QUFDTDtBQUFBLFVBQ0U7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLHNCQUFnQixJQUFJLElBQUksU0FBUztBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUNBLFFBQU0saUJBQWlCLENBQUMsY0FBYyxXQUFXLFFBQVEsaUJBQWlCLGdCQUFnQixPQUFPLGNBQWM7QUFDN0csVUFBTSxXQUFZLGFBQWEsWUFBWTtBQUFBLE1BQ3pDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EsUUFBSSxPQUFvRTtBQUN0RSxrQkFBWSxRQUFRO0FBQUEsSUFDdEI7QUFDQSxRQUFJLE9BQTJDO0FBQzdDLHlCQUFtQixZQUFZO0FBQy9CLG1CQUFhLFVBQVUsT0FBTztBQUFBLElBQ2hDO0FBQ0EsUUFBSSxZQUFZLFlBQVksR0FBRztBQUM3QixlQUFTLElBQUksV0FBVztBQUFBLElBQzFCO0FBQ0E7QUFDRSxVQUFJLE9BQTJDO0FBQzdDLHFCQUFhLFVBQVUsTUFBTTtBQUFBLE1BQy9CO0FBQ0EscUJBQWUsUUFBUTtBQUN2QixVQUFJLE9BQTJDO0FBQzdDLG1CQUFXLFVBQVUsTUFBTTtBQUFBLE1BQzdCO0FBQUEsSUFDRjtBQUNBLFFBQUksU0FBUyxVQUFVO0FBQ3JCLHdCQUFrQixlQUFlLFlBQVksVUFBVSxpQkFBaUI7QUFDeEUsVUFBSSxDQUFDLGFBQWEsSUFBSTtBQUNwQixjQUFNLGNBQWMsU0FBUyxVQUFVLFlBQVksT0FBTztBQUMxRCwyQkFBbUIsTUFBTSxhQUFhLFdBQVcsTUFBTTtBQUFBLE1BQ3pEO0FBQ0E7QUFBQSxJQUNGO0FBQ0E7QUFBQSxNQUNFO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLFFBQUksT0FBMkM7QUFDN0Msd0JBQWtCO0FBQ2xCLGlCQUFXLFVBQVUsT0FBTztBQUFBLElBQzlCO0FBQUEsRUFDRjtBQUNBLFFBQU0sa0JBQWtCLENBQUMsSUFBSSxJQUFJLGNBQWM7QUFDN0MsVUFBTSxXQUFXLEdBQUcsWUFBWSxHQUFHO0FBQ25DLFFBQUksc0JBQXNCLElBQUksSUFBSSxTQUFTLEdBQUc7QUFDNUMsVUFBSSxTQUFTLFlBQVksQ0FBQyxTQUFTLGVBQWU7QUFDaEQsWUFBSSxPQUEyQztBQUM3Qyw2QkFBbUIsRUFBRTtBQUFBLFFBQ3ZCO0FBQ0EsaUNBQXlCLFVBQVUsSUFBSSxTQUFTO0FBQ2hELFlBQUksT0FBMkM7QUFDN0MsNEJBQWtCO0FBQUEsUUFDcEI7QUFDQTtBQUFBLE1BQ0YsT0FBTztBQUNMLGlCQUFTLE9BQU87QUFDaEIsc0JBQWMsU0FBUyxNQUFNO0FBQzdCLGlCQUFTLE9BQU87QUFBQSxNQUNsQjtBQUFBLElBQ0YsT0FBTztBQUNMLFNBQUcsS0FBSyxHQUFHO0FBQ1gsZUFBUyxRQUFRO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBQ0EsUUFBTSxvQkFBb0IsQ0FBQyxVQUFVLGNBQWMsV0FBVyxRQUFRLGdCQUFnQixPQUFPLGNBQWM7QUFDekcsVUFBTSxvQkFBb0IsTUFBTTtBQUM5QixVQUFJLENBQUMsU0FBUyxXQUFXO0FBQ3ZCLFlBQUk7QUFDSixjQUFNLEVBQUUsSUFBSSxNQUFNLElBQUk7QUFDdEIsY0FBTSxFQUFFLElBQUksR0FBRyxPQUFPLElBQUk7QUFDMUIsY0FBTSxzQkFBc0IsZUFBZSxZQUFZO0FBQ3ZELHNCQUFjLFVBQVUsS0FBSztBQUM3QixZQUFJLElBQUk7QUFDTix5QkFBZSxFQUFFO0FBQUEsUUFDbkI7QUFDQSxZQUFJLENBQUMsd0JBQXdCLFlBQVksU0FBUyxNQUFNLHFCQUFxQjtBQUMzRSwwQkFBZ0IsV0FBVyxRQUFRLFlBQVk7QUFBQSxRQUNqRDtBQUNBLHNCQUFjLFVBQVUsSUFBSTtBQUM1QixZQUFJLE1BQU0sYUFBYTtBQUNyQixnQkFBTSxpQkFBaUIsTUFBTTtBQUMzQixnQkFBSSxPQUEyQztBQUM3QywyQkFBYSxVQUFVLFFBQVE7QUFBQSxZQUNqQztBQUNBLHFCQUFTLFVBQVUsb0JBQW9CLFFBQVE7QUFDL0MsZ0JBQUksT0FBMkM7QUFDN0MseUJBQVcsVUFBVSxRQUFRO0FBQUEsWUFDL0I7QUFDQSxnQkFBSSxPQUEyQztBQUM3QywyQkFBYSxVQUFVLFNBQVM7QUFBQSxZQUNsQztBQUNBO0FBQUEsY0FDRTtBQUFBLGNBQ0EsU0FBUztBQUFBLGNBQ1Q7QUFBQSxjQUNBO0FBQUEsY0FDQTtBQUFBLFlBQ0Y7QUFDQSxnQkFBSSxPQUEyQztBQUM3Qyx5QkFBVyxVQUFVLFNBQVM7QUFBQSxZQUNoQztBQUFBLFVBQ0Y7QUFDQSxjQUFJLHFCQUFxQjtBQUN2Qix5QkFBYSxLQUFLLGNBQWMsRUFBRTtBQUFBLGNBS2hDLE1BQU0sQ0FBQyxTQUFTLGVBQWUsZUFBZTtBQUFBLFlBQ2hEO0FBQUEsVUFDRixPQUFPO0FBQ0wsMkJBQWU7QUFBQSxVQUNqQjtBQUFBLFFBQ0YsT0FBTztBQUNMLGNBQUksT0FBMkM7QUFDN0MseUJBQWEsVUFBVSxRQUFRO0FBQUEsVUFDakM7QUFDQSxnQkFBTSxVQUFVLFNBQVMsVUFBVSxvQkFBb0IsUUFBUTtBQUMvRCxjQUFJLE9BQTJDO0FBQzdDLHVCQUFXLFVBQVUsUUFBUTtBQUFBLFVBQy9CO0FBQ0EsY0FBSSxPQUEyQztBQUM3Qyx5QkFBYSxVQUFVLE9BQU87QUFBQSxVQUNoQztBQUNBO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFDQSxjQUFJLE9BQTJDO0FBQzdDLHVCQUFXLFVBQVUsT0FBTztBQUFBLFVBQzlCO0FBQ0EsdUJBQWEsS0FBSyxRQUFRO0FBQUEsUUFDNUI7QUFDQSxZQUFJLEdBQUc7QUFDTCxnQ0FBc0IsR0FBRyxjQUFjO0FBQUEsUUFDekM7QUFDQSxZQUFJLENBQUMsd0JBQXdCLFlBQVksU0FBUyxNQUFNLGlCQUFpQjtBQUN2RSxnQkFBTSxxQkFBcUI7QUFDM0I7QUFBQSxZQUNFLE1BQU0sZ0JBQWdCLFdBQVcsUUFBUSxrQkFBa0I7QUFBQSxZQUMzRDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxhQUFhLFlBQVksT0FBTyxVQUFVLGVBQWUsT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLFlBQVksS0FBSztBQUMxRyxtQkFBUyxLQUFLLHNCQUFzQixTQUFTLEdBQUcsY0FBYztBQUFBLFFBQ2hFO0FBQ0EsaUJBQVMsWUFBWTtBQUNyQixZQUFpRCxPQUF1QjtBQUN0RSxpQ0FBdUIsUUFBUTtBQUFBLFFBQ2pDO0FBQ0EsdUJBQWUsWUFBWSxTQUFTO0FBQUEsTUFDdEMsT0FBTztBQUNMLFlBQUksRUFBRSxNQUFNLElBQUksR0FBRyxRQUFRLE1BQU0sSUFBSTtBQUNyQyxZQUFJLGFBQWE7QUFDakIsWUFBSTtBQUNKLFlBQUksT0FBMkM7QUFDN0MsNkJBQW1CLFFBQVEsU0FBUyxLQUFLO0FBQUEsUUFDM0M7QUFDQSxzQkFBYyxVQUFVLEtBQUs7QUFDN0IsWUFBSSxNQUFNO0FBQ1IsZUFBSyxLQUFLLE1BQU07QUFDaEIsbUNBQXlCLFVBQVUsTUFBTSxTQUFTO0FBQUEsUUFDcEQsT0FBTztBQUNMLGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUksSUFBSTtBQUNOLHlCQUFlLEVBQUU7QUFBQSxRQUNuQjtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQVMsS0FBSyxNQUFNLHFCQUFxQjtBQUM1RCwwQkFBZ0IsV0FBVyxRQUFRLE1BQU0sS0FBSztBQUFBLFFBQ2hEO0FBQ0Esc0JBQWMsVUFBVSxJQUFJO0FBQzVCLFlBQUksT0FBMkM7QUFDN0MsdUJBQWEsVUFBVSxRQUFRO0FBQUEsUUFDakM7QUFDQSxjQUFNLFdBQVcsb0JBQW9CLFFBQVE7QUFDN0MsWUFBSSxPQUEyQztBQUM3QyxxQkFBVyxVQUFVLFFBQVE7QUFBQSxRQUMvQjtBQUNBLGNBQU0sV0FBVyxTQUFTO0FBQzFCLGlCQUFTLFVBQVU7QUFDbkIsWUFBSSxPQUEyQztBQUM3Qyx1QkFBYSxVQUFVLE9BQU87QUFBQSxRQUNoQztBQUNBO0FBQUEsVUFDRTtBQUFBLFVBQ0E7QUFBQSxVQUVBLGVBQWUsU0FBUyxFQUFFO0FBQUEsVUFFMUIsZ0JBQWdCLFFBQVE7QUFBQSxVQUN4QjtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUNBLFlBQUksT0FBMkM7QUFDN0MscUJBQVcsVUFBVSxPQUFPO0FBQUEsUUFDOUI7QUFDQSxhQUFLLEtBQUssU0FBUztBQUNuQixZQUFJLGVBQWUsTUFBTTtBQUN2QiwwQkFBZ0IsVUFBVSxTQUFTLEVBQUU7QUFBQSxRQUN2QztBQUNBLFlBQUksR0FBRztBQUNMLGdDQUFzQixHQUFHLGNBQWM7QUFBQSxRQUN6QztBQUNBLFlBQUksWUFBWSxLQUFLLFNBQVMsS0FBSyxNQUFNLGdCQUFnQjtBQUN2RDtBQUFBLFlBQ0UsTUFBTSxnQkFBZ0IsV0FBVyxRQUFRLE1BQU0sS0FBSztBQUFBLFlBQ3BEO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxZQUFpRCxPQUF1QjtBQUN0RSxtQ0FBeUIsUUFBUTtBQUFBLFFBQ25DO0FBQ0EsWUFBSSxPQUEyQztBQUM3Qyw0QkFBa0I7QUFBQSxRQUNwQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsVUFBTUMsVUFBUyxTQUFTLFNBQVMsSUFBSTtBQUFBLE1BQ25DO0FBQUEsTUFDQSxNQUFNLFNBQVMsTUFBTTtBQUFBLE1BQ3JCLFNBQVM7QUFBQSxJQUVYO0FBQ0EsVUFBTSxTQUFTLFNBQVMsU0FBUyxNQUFNQSxRQUFPLElBQUk7QUFDbEQsV0FBTyxLQUFLLFNBQVM7QUFDckIsa0JBQWMsVUFBVSxJQUFJO0FBQzVCLFFBQUksT0FBMkM7QUFDN0MsTUFBQUEsUUFBTyxVQUFVLFNBQVMsTUFBTSxDQUFDLE1BQU0sZUFBZSxTQUFTLEtBQUssQ0FBQyxJQUFJO0FBQ3pFLE1BQUFBLFFBQU8sWUFBWSxTQUFTLE1BQU0sQ0FBQyxNQUFNLGVBQWUsU0FBUyxLQUFLLENBQUMsSUFBSTtBQUMzRSxhQUFPLGdCQUFnQjtBQUFBLElBQ3pCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLDJCQUEyQixDQUFDLFVBQVUsV0FBVyxjQUFjO0FBQ25FLGNBQVUsWUFBWTtBQUN0QixVQUFNLFlBQVksU0FBUyxNQUFNO0FBQ2pDLGFBQVMsUUFBUTtBQUNqQixhQUFTLE9BQU87QUFDaEIsZ0JBQVksVUFBVSxVQUFVLE9BQU8sV0FBVyxTQUFTO0FBQzNELGdCQUFZLFVBQVUsVUFBVSxVQUFVLFNBQVM7QUFDbkQsa0JBQWM7QUFDZCxxQkFBaUI7QUFDakIsa0JBQWM7QUFBQSxFQUNoQjtBQUNBLFFBQU0sZ0JBQWdCLENBQUMsSUFBSSxJQUFJLFdBQVcsUUFBUSxpQkFBaUIsZ0JBQWdCLE9BQU8sY0FBYyxZQUFZLFVBQVU7QUFDNUgsVUFBTSxLQUFLLE1BQU0sR0FBRztBQUNwQixVQUFNLGdCQUFnQixLQUFLLEdBQUcsWUFBWTtBQUMxQyxVQUFNLEtBQUssR0FBRztBQUNkLFVBQU0sRUFBRSxXQUFXLFVBQVUsSUFBSTtBQUNqQyxRQUFJLFlBQVksR0FBRztBQUNqQixVQUFJLFlBQVksS0FBSztBQUNuQjtBQUFBLFVBQ0U7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQTtBQUFBLE1BQ0YsV0FBVyxZQUFZLEtBQUs7QUFDMUI7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksWUFBWSxHQUFHO0FBQ2pCLFVBQUksZ0JBQWdCLElBQUk7QUFDdEIsd0JBQWdCLElBQUksaUJBQWlCLGNBQWM7QUFBQSxNQUNyRDtBQUNBLFVBQUksT0FBTyxJQUFJO0FBQ2IsMkJBQW1CLFdBQVcsRUFBRTtBQUFBLE1BQ2xDO0FBQUEsSUFDRixPQUFPO0FBQ0wsVUFBSSxnQkFBZ0IsSUFBSTtBQUN0QixZQUFJLFlBQVksSUFBSTtBQUNsQjtBQUFBLFlBQ0U7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGLE9BQU87QUFDTCwwQkFBZ0IsSUFBSSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFBQSxRQUMzRDtBQUFBLE1BQ0YsT0FBTztBQUNMLFlBQUksZ0JBQWdCLEdBQUc7QUFDckIsNkJBQW1CLFdBQVcsRUFBRTtBQUFBLFFBQ2xDO0FBQ0EsWUFBSSxZQUFZLElBQUk7QUFDbEI7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSx1QkFBdUIsQ0FBQyxJQUFJLElBQUksV0FBVyxRQUFRLGlCQUFpQixnQkFBZ0IsT0FBTyxjQUFjLGNBQWM7QUFDM0gsU0FBSyxNQUFNO0FBQ1gsU0FBSyxNQUFNO0FBQ1gsVUFBTSxZQUFZLEdBQUc7QUFDckIsVUFBTSxZQUFZLEdBQUc7QUFDckIsVUFBTSxlQUFlLEtBQUssSUFBSSxXQUFXLFNBQVM7QUFDbEQsUUFBSTtBQUNKLFNBQUssSUFBSSxHQUFHLElBQUksY0FBYyxLQUFLO0FBQ2pDLFlBQU0sWUFBWSxHQUFHLEtBQUssWUFBWSxlQUFlLEdBQUcsRUFBRSxJQUFJLGVBQWUsR0FBRyxFQUFFO0FBQ2xGO0FBQUEsUUFDRSxHQUFHO0FBQUEsUUFDSDtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksWUFBWSxXQUFXO0FBQ3pCO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxxQkFBcUIsQ0FBQyxJQUFJLElBQUksV0FBVyxjQUFjLGlCQUFpQixnQkFBZ0IsT0FBTyxjQUFjLGNBQWM7QUFDL0gsUUFBSSxJQUFJO0FBQ1IsVUFBTSxLQUFLLEdBQUc7QUFDZCxRQUFJLEtBQUssR0FBRyxTQUFTO0FBQ3JCLFFBQUksS0FBSyxLQUFLO0FBQ2QsV0FBTyxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ3pCLFlBQU0sS0FBSyxHQUFHO0FBQ2QsWUFBTSxLQUFLLEdBQUcsS0FBSyxZQUFZLGVBQWUsR0FBRyxFQUFFLElBQUksZUFBZSxHQUFHLEVBQUU7QUFDM0UsVUFBSSxnQkFBZ0IsSUFBSSxFQUFFLEdBQUc7QUFDM0I7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0w7QUFBQSxNQUNGO0FBQ0E7QUFBQSxJQUNGO0FBQ0EsV0FBTyxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ3pCLFlBQU0sS0FBSyxHQUFHO0FBQ2QsWUFBTSxLQUFLLEdBQUcsTUFBTSxZQUFZLGVBQWUsR0FBRyxHQUFHLElBQUksZUFBZSxHQUFHLEdBQUc7QUFDOUUsVUFBSSxnQkFBZ0IsSUFBSSxFQUFFLEdBQUc7QUFDM0I7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0w7QUFBQSxNQUNGO0FBQ0E7QUFDQTtBQUFBLElBQ0Y7QUFDQSxRQUFJLElBQUksSUFBSTtBQUNWLFVBQUksS0FBSyxJQUFJO0FBQ1gsY0FBTSxVQUFVLEtBQUs7QUFDckIsY0FBTSxTQUFTLFVBQVUsS0FBSyxHQUFHLFNBQVMsS0FBSztBQUMvQyxlQUFPLEtBQUssSUFBSTtBQUNkO0FBQUEsWUFDRTtBQUFBLFlBQ0EsR0FBRyxLQUFLLFlBQVksZUFBZSxHQUFHLEVBQUUsSUFBSSxlQUFlLEdBQUcsRUFBRTtBQUFBLFlBQ2hFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFdBQVcsSUFBSSxJQUFJO0FBQ2pCLGFBQU8sS0FBSyxJQUFJO0FBQ2QsZ0JBQVEsR0FBRyxJQUFJLGlCQUFpQixnQkFBZ0IsSUFBSTtBQUNwRDtBQUFBLE1BQ0Y7QUFBQSxJQUNGLE9BQU87QUFDTCxZQUFNLEtBQUs7QUFDWCxZQUFNLEtBQUs7QUFDWCxZQUFNLG1CQUFtQyxvQkFBSSxJQUFJO0FBQ2pELFdBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLO0FBQ3pCLGNBQU0sWUFBWSxHQUFHLEtBQUssWUFBWSxlQUFlLEdBQUcsRUFBRSxJQUFJLGVBQWUsR0FBRyxFQUFFO0FBQ2xGLFlBQUksVUFBVSxPQUFPLE1BQU07QUFDekIsY0FBSSxPQUFrRjtBQUNwRjtBQUFBLGNBQ0U7QUFBQSxjQUNBLEtBQUssVUFBVSxVQUFVLEdBQUc7QUFBQSxjQUM1QjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsMkJBQWlCLElBQUksVUFBVSxLQUFLLENBQUM7QUFBQSxRQUN2QztBQUFBLE1BQ0Y7QUFDQSxVQUFJO0FBQ0osVUFBSSxVQUFVO0FBQ2QsWUFBTSxjQUFjLEtBQUssS0FBSztBQUM5QixVQUFJLFFBQVE7QUFDWixVQUFJLG1CQUFtQjtBQUN2QixZQUFNLHdCQUF3QixJQUFJLE1BQU0sV0FBVztBQUNuRCxXQUFLLElBQUksR0FBRyxJQUFJLGFBQWE7QUFDM0IsOEJBQXNCLEtBQUs7QUFDN0IsV0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLEtBQUs7QUFDekIsY0FBTSxZQUFZLEdBQUc7QUFDckIsWUFBSSxXQUFXLGFBQWE7QUFDMUIsa0JBQVEsV0FBVyxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDeEQ7QUFBQSxRQUNGO0FBQ0EsWUFBSTtBQUNKLFlBQUksVUFBVSxPQUFPLE1BQU07QUFDekIscUJBQVcsaUJBQWlCLElBQUksVUFBVSxHQUFHO0FBQUEsUUFDL0MsT0FBTztBQUNMLGVBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLO0FBQ3pCLGdCQUFJLHNCQUFzQixJQUFJLFFBQVEsS0FBSyxnQkFBZ0IsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUM1RSx5QkFBVztBQUNYO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxhQUFhLFFBQVE7QUFDdkIsa0JBQVEsV0FBVyxpQkFBaUIsZ0JBQWdCLElBQUk7QUFBQSxRQUMxRCxPQUFPO0FBQ0wsZ0NBQXNCLFdBQVcsTUFBTSxJQUFJO0FBQzNDLGNBQUksWUFBWSxrQkFBa0I7QUFDaEMsK0JBQW1CO0FBQUEsVUFDckIsT0FBTztBQUNMLG9CQUFRO0FBQUEsVUFDVjtBQUNBO0FBQUEsWUFDRTtBQUFBLFlBQ0EsR0FBRztBQUFBLFlBQ0g7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0E7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUNBLFlBQU0sNkJBQTZCLFFBQVEsWUFBWSxxQkFBcUIsSUFBSTtBQUNoRixVQUFJLDJCQUEyQixTQUFTO0FBQ3hDLFdBQUssSUFBSSxjQUFjLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDckMsY0FBTSxZQUFZLEtBQUs7QUFDdkIsY0FBTSxZQUFZLEdBQUc7QUFDckIsY0FBTSxTQUFTLFlBQVksSUFBSSxLQUFLLEdBQUcsWUFBWSxHQUFHLEtBQUs7QUFDM0QsWUFBSSxzQkFBc0IsT0FBTyxHQUFHO0FBQ2xDO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0YsV0FBVyxPQUFPO0FBQ2hCLGNBQUksSUFBSSxLQUFLLE1BQU0sMkJBQTJCLElBQUk7QUFDaEQsaUJBQUssV0FBVyxXQUFXLFFBQVEsQ0FBQztBQUFBLFVBQ3RDLE9BQU87QUFDTDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsUUFBTSxPQUFPLENBQUMsT0FBTyxXQUFXLFFBQVEsVUFBVSxpQkFBaUIsU0FBUztBQUMxRSxVQUFNLEVBQUUsSUFBSSxNQUFNLFlBQVksVUFBVSxVQUFVLElBQUk7QUFDdEQsUUFBSSxZQUFZLEdBQUc7QUFDakIsV0FBSyxNQUFNLFVBQVUsU0FBUyxXQUFXLFFBQVEsUUFBUTtBQUN6RDtBQUFBLElBQ0Y7QUFDQSxRQUFJLFlBQVksS0FBSztBQUNuQixZQUFNLFNBQVMsS0FBSyxXQUFXLFFBQVEsUUFBUTtBQUMvQztBQUFBLElBQ0Y7QUFDQSxRQUFJLFlBQVksSUFBSTtBQUNsQixXQUFLLEtBQUssT0FBTyxXQUFXLFFBQVEsU0FBUztBQUM3QztBQUFBLElBQ0Y7QUFDQSxRQUFJLFNBQVMsVUFBVTtBQUNyQixpQkFBVyxJQUFJLFdBQVcsTUFBTTtBQUNoQyxlQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLGFBQUssU0FBUyxJQUFJLFdBQVcsUUFBUSxRQUFRO0FBQUEsTUFDL0M7QUFDQSxpQkFBVyxNQUFNLFFBQVEsV0FBVyxNQUFNO0FBQzFDO0FBQUEsSUFDRjtBQUNBLFFBQUksU0FBUyxRQUFRO0FBQ25CLHFCQUFlLE9BQU8sV0FBVyxNQUFNO0FBQ3ZDO0FBQUEsSUFDRjtBQUNBLFVBQU0saUJBQWlCLGFBQWEsS0FBSyxZQUFZLEtBQUs7QUFDMUQsUUFBSSxnQkFBZ0I7QUFDbEIsVUFBSSxhQUFhLEdBQUc7QUFDbEIsbUJBQVcsWUFBWSxFQUFFO0FBQ3pCLG1CQUFXLElBQUksV0FBVyxNQUFNO0FBQ2hDLDhCQUFzQixNQUFNLFdBQVcsTUFBTSxFQUFFLEdBQUcsY0FBYztBQUFBLE1BQ2xFLE9BQU87QUFDTCxjQUFNLEVBQUUsT0FBTyxZQUFZLFdBQVcsSUFBSTtBQUMxQyxjQUFNQyxXQUFVLE1BQU0sV0FBVyxJQUFJLFdBQVcsTUFBTTtBQUN0RCxjQUFNLGVBQWUsTUFBTTtBQUN6QixnQkFBTSxJQUFJLE1BQU07QUFDZCxZQUFBQSxTQUFRO0FBQ1IsMEJBQWMsV0FBVztBQUFBLFVBQzNCLENBQUM7QUFBQSxRQUNIO0FBQ0EsWUFBSSxZQUFZO0FBQ2QscUJBQVcsSUFBSUEsVUFBUyxZQUFZO0FBQUEsUUFDdEMsT0FBTztBQUNMLHVCQUFhO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLE9BQU87QUFDTCxpQkFBVyxJQUFJLFdBQVcsTUFBTTtBQUFBLElBQ2xDO0FBQUEsRUFDRjtBQUNBLFFBQU0sVUFBVSxDQUFDLE9BQU8saUJBQWlCLGdCQUFnQixXQUFXLE9BQU8sWUFBWSxVQUFVO0FBQy9GLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLE1BQ0EsS0FBQUY7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSTtBQUNKLFFBQUlBLFFBQU8sTUFBTTtBQUNmLGFBQU9BLE1BQUssTUFBTSxnQkFBZ0IsT0FBTyxJQUFJO0FBQUEsSUFDL0M7QUFDQSxRQUFJLFlBQVksS0FBSztBQUNuQixzQkFBZ0IsSUFBSSxXQUFXLEtBQUs7QUFDcEM7QUFBQSxJQUNGO0FBQ0EsVUFBTSxtQkFBbUIsWUFBWSxLQUFLO0FBQzFDLFVBQU0sd0JBQXdCLENBQUMsZUFBZSxLQUFLO0FBQ25ELFFBQUk7QUFDSixRQUFJLDBCQUEwQixZQUFZLFNBQVMsTUFBTSx1QkFBdUI7QUFDOUUsc0JBQWdCLFdBQVcsaUJBQWlCLEtBQUs7QUFBQSxJQUNuRDtBQUNBLFFBQUksWUFBWSxHQUFHO0FBQ2pCLHVCQUFpQixNQUFNLFdBQVcsZ0JBQWdCLFFBQVE7QUFBQSxJQUM1RCxPQUFPO0FBQ0wsVUFBSSxZQUFZLEtBQUs7QUFDbkIsY0FBTSxTQUFTLFFBQVEsZ0JBQWdCLFFBQVE7QUFDL0M7QUFBQSxNQUNGO0FBQ0EsVUFBSSxrQkFBa0I7QUFDcEIsNEJBQW9CLE9BQU8sTUFBTSxpQkFBaUIsZUFBZTtBQUFBLE1BQ25FO0FBQ0EsVUFBSSxZQUFZLElBQUk7QUFDbEIsY0FBTSxLQUFLO0FBQUEsVUFDVDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0YsV0FBVyxvQkFDVixTQUFTLFlBQVksWUFBWSxLQUFLLFlBQVksS0FBSztBQUN0RDtBQUFBLFVBQ0U7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0YsV0FBVyxTQUFTLFlBQVksYUFBYSxNQUFNLFFBQVEsQ0FBQyxhQUFhLFlBQVksSUFBSTtBQUN2Rix3QkFBZ0IsVUFBVSxpQkFBaUIsY0FBYztBQUFBLE1BQzNEO0FBQ0EsVUFBSSxVQUFVO0FBQ1osUUFBQUcsUUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFDQSxRQUFJLDBCQUEwQixZQUFZLFNBQVMsTUFBTSxxQkFBcUIsa0JBQWtCO0FBQzlGLDRCQUFzQixNQUFNO0FBQzFCLHFCQUFhLGdCQUFnQixXQUFXLGlCQUFpQixLQUFLO0FBQzlELDRCQUFvQixvQkFBb0IsT0FBTyxNQUFNLGlCQUFpQixXQUFXO0FBQUEsTUFDbkYsR0FBRyxjQUFjO0FBQUEsSUFDbkI7QUFBQSxFQUNGO0FBQ0EsUUFBTUEsVUFBUyxDQUFDLFVBQVU7QUFDeEIsVUFBTSxFQUFFLE1BQU0sSUFBSSxRQUFRLFdBQVcsSUFBSTtBQUN6QyxRQUFJLFNBQVMsVUFBVTtBQUNyQixVQUFJLE9BQW1JO0FBQ3JJLGNBQU0sU0FBUyxRQUFRLENBQUMsVUFBVTtBQUNoQyxjQUFJLE1BQU0sU0FBUyxTQUFTO0FBQzFCLHVCQUFXLE1BQU0sRUFBRTtBQUFBLFVBQ3JCLE9BQU87QUFDTCxZQUFBQSxRQUFPLEtBQUs7QUFBQSxVQUNkO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSCxPQUFPO0FBQ0wsdUJBQWUsSUFBSSxNQUFNO0FBQUEsTUFDM0I7QUFDQTtBQUFBLElBQ0Y7QUFDQSxRQUFJLFNBQVMsUUFBUTtBQUNuQix1QkFBaUIsS0FBSztBQUN0QjtBQUFBLElBQ0Y7QUFDQSxVQUFNLGdCQUFnQixNQUFNO0FBQzFCLGlCQUFXLEVBQUU7QUFDYixVQUFJLGNBQWMsQ0FBQyxXQUFXLGFBQWEsV0FBVyxZQUFZO0FBQ2hFLG1CQUFXLFdBQVc7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFDQSxRQUFJLE1BQU0sWUFBWSxLQUFLLGNBQWMsQ0FBQyxXQUFXLFdBQVc7QUFDOUQsWUFBTSxFQUFFLE9BQU8sV0FBVyxJQUFJO0FBQzlCLFlBQU0sZUFBZSxNQUFNLE1BQU0sSUFBSSxhQUFhO0FBQ2xELFVBQUksWUFBWTtBQUNkLG1CQUFXLE1BQU0sSUFBSSxlQUFlLFlBQVk7QUFBQSxNQUNsRCxPQUFPO0FBQ0wscUJBQWE7QUFBQSxNQUNmO0FBQUEsSUFDRixPQUFPO0FBQ0wsb0JBQWM7QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGlCQUFpQixDQUFDLEtBQUssUUFBUTtBQUNuQyxRQUFJO0FBQ0osV0FBTyxRQUFRLEtBQUs7QUFDbEIsYUFBTyxnQkFBZ0IsR0FBRztBQUMxQixpQkFBVyxHQUFHO0FBQ2QsWUFBTTtBQUFBLElBQ1I7QUFDQSxlQUFXLEdBQUc7QUFBQSxFQUNoQjtBQUNBLFFBQU0sbUJBQW1CLENBQUMsVUFBVSxnQkFBZ0IsYUFBYTtBQUMvRCxRQUFJLE9BQW9FO0FBQ3RFLG9CQUFjLFFBQVE7QUFBQSxJQUN4QjtBQUNBLFVBQU0sRUFBRSxLQUFLLE9BQU8sUUFBUSxTQUFTLEdBQUcsSUFBSTtBQUM1QyxRQUFJLEtBQUs7QUFDUCxxQkFBZSxHQUFHO0FBQUEsSUFDcEI7QUFDQSxVQUFNLEtBQUs7QUFDWCxRQUFJLFFBQVE7QUFDVixhQUFPLFNBQVM7QUFDaEIsY0FBUSxTQUFTLFVBQVUsZ0JBQWdCLFFBQVE7QUFBQSxJQUNyRDtBQUNBLFFBQUksSUFBSTtBQUNOLDRCQUFzQixJQUFJLGNBQWM7QUFBQSxJQUMxQztBQUNBLDBCQUFzQixNQUFNO0FBQzFCLGVBQVMsY0FBYztBQUFBLElBQ3pCLEdBQUcsY0FBYztBQUNqQixRQUFJLGtCQUFrQixlQUFlLGlCQUFpQixDQUFDLGVBQWUsZUFBZSxTQUFTLFlBQVksQ0FBQyxTQUFTLGlCQUFpQixTQUFTLGVBQWUsZUFBZSxXQUFXO0FBQ3JMLHFCQUFlO0FBQ2YsVUFBSSxlQUFlLFNBQVMsR0FBRztBQUM3Qix1QkFBZSxRQUFRO0FBQUEsTUFDekI7QUFBQSxJQUNGO0FBQ0EsUUFBaUQsT0FBdUI7QUFDdEUsK0JBQXlCLFFBQVE7QUFBQSxJQUNuQztBQUFBLEVBQ0Y7QUFDQSxRQUFNLGtCQUFrQixDQUFDLFVBQVUsaUJBQWlCLGdCQUFnQixXQUFXLE9BQU8sWUFBWSxPQUFPLFFBQVEsTUFBTTtBQUNySCxhQUFTLElBQUksT0FBTyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQzVDLGNBQVEsU0FBUyxJQUFJLGlCQUFpQixnQkFBZ0IsVUFBVSxTQUFTO0FBQUEsSUFDM0U7QUFBQSxFQUNGO0FBQ0EsUUFBTSxrQkFBa0IsQ0FBQyxVQUFVO0FBQ2pDLFFBQUksTUFBTSxZQUFZLEdBQUc7QUFDdkIsYUFBTyxnQkFBZ0IsTUFBTSxVQUFVLE9BQU87QUFBQSxJQUNoRDtBQUNBLFFBQUksTUFBTSxZQUFZLEtBQUs7QUFDekIsYUFBTyxNQUFNLFNBQVMsS0FBSztBQUFBLElBQzdCO0FBQ0EsV0FBTyxnQkFBZ0IsTUFBTSxVQUFVLE1BQU0sRUFBRTtBQUFBLEVBQ2pEO0FBQ0EsUUFBTUMsVUFBUyxDQUFDLE9BQU8sV0FBVyxVQUFVO0FBQzFDLFFBQUksU0FBUyxNQUFNO0FBQ2pCLFVBQUksVUFBVSxRQUFRO0FBQ3BCLGdCQUFRLFVBQVUsUUFBUSxNQUFNLE1BQU0sSUFBSTtBQUFBLE1BQzVDO0FBQUEsSUFDRixPQUFPO0FBQ0wsWUFBTSxVQUFVLFVBQVUsTUFBTSxPQUFPLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSztBQUFBLElBQzNFO0FBQ0EscUJBQWlCO0FBQ2pCLHNCQUFrQjtBQUNsQixjQUFVLFNBQVM7QUFBQSxFQUNyQjtBQUNBLFFBQU0sWUFBWTtBQUFBLElBQ2hCLEdBQUc7QUFBQSxJQUNILElBQUk7QUFBQSxJQUNKLEdBQUc7QUFBQSxJQUNILEdBQUdEO0FBQUEsSUFDSCxJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixJQUFJO0FBQUEsSUFDSixLQUFLO0FBQUEsSUFDTCxHQUFHO0FBQUEsSUFDSCxHQUFHO0FBQUEsRUFDTDtBQUNBLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSSxvQkFBb0I7QUFDdEIsS0FBQyxTQUFTLFdBQVcsSUFBSTtBQUFBLE1BQ3ZCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQUEsSUFDTCxRQUFBQztBQUFBLElBQ0E7QUFBQSxJQUNBLFdBQVcsYUFBYUEsU0FBUSxPQUFPO0FBQUEsRUFDekM7QUFDRjtBQUNBLFNBQVMsY0FBYyxFQUFFLFFBQUFILFNBQVEsT0FBTyxHQUFHLFNBQVM7QUFDbEQsRUFBQUEsUUFBTyxlQUFlLE9BQU8sZUFBZTtBQUM5QztBQUNBLFNBQVMsdUJBQXVCLElBQUksSUFBSSxVQUFVLE9BQU87QUFDdkQsUUFBTSxNQUFNLEdBQUc7QUFDZixRQUFNLE1BQU0sR0FBRztBQUNmLE1BQUksUUFBUSxHQUFHLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFDaEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsS0FBSztBQUNuQyxZQUFNLEtBQUssSUFBSTtBQUNmLFVBQUksS0FBSyxJQUFJO0FBQ2IsVUFBSSxHQUFHLFlBQVksS0FBSyxDQUFDLEdBQUcsaUJBQWlCO0FBQzNDLFlBQUksR0FBRyxhQUFhLEtBQUssR0FBRyxjQUFjLElBQUk7QUFDNUMsZUFBSyxJQUFJLEtBQUssZUFBZSxJQUFJLEVBQUU7QUFDbkMsYUFBRyxLQUFLLEdBQUc7QUFBQSxRQUNiO0FBQ0EsWUFBSSxDQUFDO0FBQ0gsaUNBQXVCLElBQUksRUFBRTtBQUFBLE1BQ2pDO0FBQ0EsVUFBSSxHQUFHLFNBQVMsTUFBTTtBQUNwQixXQUFHLEtBQUssR0FBRztBQUFBLE1BQ2I7QUFDQSxVQUFJLE9BQTRFO0FBQzlFLFdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDYjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFlBQVksS0FBSztBQUN4QixRQUFNSSxLQUFJLElBQUksTUFBTTtBQUNwQixRQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQ2pCLE1BQUksR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNoQixRQUFNLE1BQU0sSUFBSTtBQUNoQixPQUFLLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSztBQUN4QixVQUFNLE9BQU8sSUFBSTtBQUNqQixRQUFJLFNBQVMsR0FBRztBQUNkLFVBQUksT0FBTyxPQUFPLFNBQVM7QUFDM0IsVUFBSSxJQUFJLEtBQUssTUFBTTtBQUNqQixRQUFBQSxHQUFFLEtBQUs7QUFDUCxlQUFPLEtBQUssQ0FBQztBQUNiO0FBQUEsTUFDRjtBQUNBLFVBQUk7QUFDSixVQUFJLE9BQU8sU0FBUztBQUNwQixhQUFPLElBQUksR0FBRztBQUNaLFlBQUksSUFBSSxLQUFLO0FBQ2IsWUFBSSxJQUFJLE9BQU8sTUFBTSxNQUFNO0FBQ3pCLGNBQUksSUFBSTtBQUFBLFFBQ1YsT0FBTztBQUNMLGNBQUk7QUFBQSxRQUNOO0FBQUEsTUFDRjtBQUNBLFVBQUksT0FBTyxJQUFJLE9BQU8sS0FBSztBQUN6QixZQUFJLElBQUksR0FBRztBQUNULFVBQUFBLEdBQUUsS0FBSyxPQUFPLElBQUk7QUFBQSxRQUNwQjtBQUNBLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksT0FBTztBQUNYLE1BQUksT0FBTyxJQUFJO0FBQ2YsU0FBTyxNQUFNLEdBQUc7QUFDZCxXQUFPLEtBQUs7QUFDWixRQUFJQSxHQUFFO0FBQUEsRUFDUjtBQUNBLFNBQU87QUFDVDtBQUVBLElBQU0sYUFBYSxDQUFDLFNBQVMsS0FBSztBQXFRbEMsSUFBTSxXQUFXLE9BQU8sSUFBSSxPQUFPO0FBQ25DLElBQU0sT0FBTyxPQUFPLElBQUksT0FBTztBQUMvQixJQUFNLFVBQVUsT0FBTyxJQUFJLE9BQU87QUFDbEMsSUFBTSxTQUFTLE9BQU8sSUFBSSxPQUFPO0FBQ2pDLElBQU0sYUFBYSxDQUFDO0FBQ3BCLElBQUksZUFBZTtBQUNuQixTQUFTLFVBQVUsa0JBQWtCLE9BQU87QUFDMUMsYUFBVyxLQUFLLGVBQWUsa0JBQWtCLE9BQU8sQ0FBQyxDQUFDO0FBQzVEO0FBQ0EsU0FBUyxhQUFhO0FBQ3BCLGFBQVcsSUFBSTtBQUNmLGlCQUFlLFdBQVcsV0FBVyxTQUFTLE1BQU07QUFDdEQ7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixTQUFTLGlCQUFpQixPQUFPO0FBQy9CLHdCQUFzQjtBQUN4QjtBQUNBLFNBQVMsV0FBVyxPQUFPO0FBQ3pCLFFBQU0sa0JBQWtCLHFCQUFxQixJQUFJLGdCQUFnQixZQUFZO0FBQzdFLGFBQVc7QUFDWCxNQUFJLHFCQUFxQixLQUFLLGNBQWM7QUFDMUMsaUJBQWEsS0FBSyxLQUFLO0FBQUEsRUFDekI7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLG1CQUFtQixNQUFNLE9BQU8sVUFBVSxXQUFXLGNBQWMsV0FBVztBQUNyRixTQUFPO0FBQUEsSUFDTDtBQUFBLE1BQ0U7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUVGO0FBQUEsRUFDRjtBQUNGO0FBY0EsU0FBUyxRQUFRLE9BQU87QUFDdEIsU0FBTyxRQUFRLE1BQU0sZ0JBQWdCLE9BQU87QUFDOUM7QUFDQSxTQUFTLGdCQUFnQixJQUFJLElBQUk7QUFDL0IsTUFBSSxPQUFrRztBQUNwRyxPQUFHLGFBQWEsQ0FBQztBQUNqQixPQUFHLGFBQWEsQ0FBQztBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sR0FBRyxTQUFTLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRztBQUM5QztBQVVBLElBQU0sb0JBQW9CO0FBQzFCLElBQU0sZUFBZSxDQUFDLEVBQUUsSUFBSSxNQUFNLE9BQU8sT0FBTyxNQUFNO0FBQ3RELElBQU0sZUFBZSxDQUFDO0FBQUEsRUFDcEIsS0FBQUM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNGLE1BQU07QUFDSixNQUFJLE9BQU9BLFNBQVEsVUFBVTtBQUMzQixJQUFBQSxPQUFNLEtBQUtBO0FBQUEsRUFDYjtBQUNBLFNBQU9BLFFBQU8sT0FBTyxTQUFTQSxJQUFHLEtBQUssTUFBTUEsSUFBRyxLQUFLLFdBQVdBLElBQUcsSUFBSSxFQUFFLEdBQUcsMEJBQTBCLEdBQUdBLE1BQUssR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFFBQVEsSUFBSUEsT0FBTTtBQUNsSjtBQUNBLFNBQVMsZ0JBQWdCLE1BQU0sUUFBUSxNQUFNLFdBQVcsTUFBTSxZQUFZLEdBQUcsZUFBZSxNQUFNLFlBQVksU0FBUyxXQUFXLElBQUksR0FBRyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU87QUFDbk0sUUFBTSxRQUFRO0FBQUEsSUFDWixhQUFhO0FBQUEsSUFDYixVQUFVO0FBQUEsSUFDVjtBQUFBLElBQ0E7QUFBQSxJQUNBLEtBQUssU0FBUyxhQUFhLEtBQUs7QUFBQSxJQUNoQyxLQUFLLFNBQVMsYUFBYSxLQUFLO0FBQUEsSUFDaEMsU0FBUztBQUFBLElBQ1QsY0FBYztBQUFBLElBQ2Q7QUFBQSxJQUNBLFdBQVc7QUFBQSxJQUNYLFVBQVU7QUFBQSxJQUNWLFdBQVc7QUFBQSxJQUNYLFlBQVk7QUFBQSxJQUNaLE1BQU07QUFBQSxJQUNOLFlBQVk7QUFBQSxJQUNaLElBQUk7QUFBQSxJQUNKLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLGNBQWM7QUFBQSxJQUNkLGFBQWE7QUFBQSxJQUNiO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLGlCQUFpQjtBQUFBLElBQ2pCLFlBQVk7QUFBQSxJQUNaLEtBQUs7QUFBQSxFQUNQO0FBQ0EsTUFBSSwrQkFBK0I7QUFDakMsc0JBQWtCLE9BQU8sUUFBUTtBQUNqQyxRQUFJLFlBQVksS0FBSztBQUNuQixXQUFLLFVBQVUsS0FBSztBQUFBLElBQ3RCO0FBQUEsRUFDRixXQUFXLFVBQVU7QUFDbkIsVUFBTSxhQUFhLFNBQVMsUUFBUSxJQUFJLElBQUk7QUFBQSxFQUM5QztBQUNBLE1BQUksT0FBc0U7QUFDeEUsU0FBSyxxREFBcUQsTUFBTSxJQUFJO0FBQUEsRUFDdEU7QUFDQSxNQUFJLHFCQUFxQixLQUN6QixDQUFDLGVBQ0QsaUJBSUMsTUFBTSxZQUFZLEtBQUssWUFBWSxNQUVwQyxNQUFNLGNBQWMsSUFBSTtBQUN0QixpQkFBYSxLQUFLLEtBQUs7QUFBQSxFQUN6QjtBQUNBLFNBQU87QUFDVDtBQUNBLElBQU0sY0FBYyxRQUE0QywrQkFBK0I7QUFDL0YsU0FBUyxhQUFhLE1BQU0sUUFBUSxNQUFNLFdBQVcsTUFBTSxZQUFZLEdBQUcsZUFBZSxNQUFNLGNBQWMsT0FBTztBQUNsSCxNQUFJLENBQUMsUUFBUSxTQUFTLHdCQUF3QjtBQUM1QyxRQUFJLE9BQW9EO0FBQ3RELFdBQUssMkNBQTJDLE9BQU87QUFBQSxJQUN6RDtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxRQUFRLElBQUksR0FBRztBQUNqQixVQUFNLFNBQVM7QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUVGO0FBQ0EsUUFBSSxVQUFVO0FBQ1osd0JBQWtCLFFBQVEsUUFBUTtBQUFBLElBQ3BDO0FBQ0EsUUFBSSxxQkFBcUIsS0FBSyxDQUFDLGVBQWUsY0FBYztBQUMxRCxVQUFJLE9BQU8sWUFBWSxHQUFHO0FBQ3hCLHFCQUFhLGFBQWEsUUFBUSxJQUFJLEtBQUs7QUFBQSxNQUM3QyxPQUFPO0FBQ0wscUJBQWEsS0FBSyxNQUFNO0FBQUEsTUFDMUI7QUFBQSxJQUNGO0FBQ0EsV0FBTyxhQUFhO0FBQ3BCLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxpQkFBaUIsSUFBSSxHQUFHO0FBQzFCLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFDQSxNQUFJLE9BQU87QUFDVCxZQUFRLG1CQUFtQixLQUFLO0FBQ2hDLFFBQUksRUFBRSxPQUFPLE9BQU8sTUFBTSxJQUFJO0FBQzlCLFFBQUksU0FBUyxDQUFDLFNBQVMsS0FBSyxHQUFHO0FBQzdCLFlBQU0sUUFBUSxlQUFlLEtBQUs7QUFBQSxJQUNwQztBQUNBLFFBQUksU0FBUyxLQUFLLEdBQUc7QUFDbkIsVUFBSSxRQUFRLEtBQUssS0FBSyxDQUFDLFFBQVEsS0FBSyxHQUFHO0FBQ3JDLGdCQUFRLE9BQU8sQ0FBQyxHQUFHLEtBQUs7QUFBQSxNQUMxQjtBQUNBLFlBQU0sUUFBUSxlQUFlLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0Y7QUFDQSxRQUFNLFlBQVksU0FBUyxJQUFJLElBQUksSUFBSSxXQUFXLElBQUksSUFBSSxNQUFNLFdBQVcsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksSUFBSSxXQUFXLElBQUksSUFBSSxJQUFJO0FBQ3BJLE1BQUksT0FBNkU7QUFDL0UsV0FBTyxNQUFNLElBQUk7QUFDakI7QUFBQSxNQUNFO0FBQUEsTUFDQTtBQUFBO0FBQUEsTUFFQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBQ0EsU0FBUyxtQkFBbUIsT0FBTztBQUNqQyxNQUFJLENBQUM7QUFDSCxXQUFPO0FBQ1QsU0FBTyxRQUFRLEtBQUssS0FBSyxxQkFBcUIsUUFBUSxPQUFPLENBQUMsR0FBRyxLQUFLLElBQUk7QUFDNUU7QUFDQSxTQUFTLFdBQVcsT0FBTyxZQUFZLFdBQVcsT0FBTztBQUN2RCxRQUFNLEVBQUUsT0FBTyxLQUFBQSxNQUFLLFdBQVcsU0FBUyxJQUFJO0FBQzVDLFFBQU0sY0FBYyxhQUFhLFdBQVcsU0FBUyxDQUFDLEdBQUcsVUFBVSxJQUFJO0FBQ3ZFLFFBQU0sU0FBUztBQUFBLElBQ2IsYUFBYTtBQUFBLElBQ2IsVUFBVTtBQUFBLElBQ1YsTUFBTSxNQUFNO0FBQUEsSUFDWixPQUFPO0FBQUEsSUFDUCxLQUFLLGVBQWUsYUFBYSxXQUFXO0FBQUEsSUFDNUMsS0FBSyxjQUFjLFdBQVcsTUFJNUIsWUFBWUEsT0FBTSxRQUFRQSxJQUFHLElBQUlBLEtBQUksT0FBTyxhQUFhLFVBQVUsQ0FBQyxJQUFJLENBQUNBLE1BQUssYUFBYSxVQUFVLENBQUMsSUFBSSxhQUFhLFVBQVUsSUFDL0hBO0FBQUEsSUFDSixTQUFTLE1BQU07QUFBQSxJQUNmLGNBQWMsTUFBTTtBQUFBLElBQ3BCLFVBQVUsUUFBcUYsU0FBUyxJQUFJLGNBQWMsSUFBSTtBQUFBLElBQzlILFFBQVEsTUFBTTtBQUFBLElBQ2QsY0FBYyxNQUFNO0FBQUEsSUFDcEIsYUFBYSxNQUFNO0FBQUEsSUFDbkIsV0FBVyxNQUFNO0FBQUEsSUFLakIsV0FBVyxjQUFjLE1BQU0sU0FBUyxXQUFXLGNBQWMsS0FBSyxLQUFLLFlBQVksS0FBSztBQUFBLElBQzVGLGNBQWMsTUFBTTtBQUFBLElBQ3BCLGlCQUFpQixNQUFNO0FBQUEsSUFDdkIsWUFBWSxNQUFNO0FBQUEsSUFDbEIsTUFBTSxNQUFNO0FBQUEsSUFDWixZQUFZLE1BQU07QUFBQSxJQUtsQixXQUFXLE1BQU07QUFBQSxJQUNqQixVQUFVLE1BQU07QUFBQSxJQUNoQixXQUFXLE1BQU0sYUFBYSxXQUFXLE1BQU0sU0FBUztBQUFBLElBQ3hELFlBQVksTUFBTSxjQUFjLFdBQVcsTUFBTSxVQUFVO0FBQUEsSUFDM0QsSUFBSSxNQUFNO0FBQUEsSUFDVixRQUFRLE1BQU07QUFBQSxJQUNkLEtBQUssTUFBTTtBQUFBLElBQ1gsSUFBSSxNQUFNO0FBQUEsRUFDWjtBQUNBLFNBQU87QUFDVDtBQVFBLFNBQVMsZ0JBQWdCLE9BQU8sS0FBSyxPQUFPLEdBQUc7QUFDN0MsU0FBTyxZQUFZLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFDM0M7QUFTQSxTQUFTLGVBQWUsT0FBTztBQUM3QixNQUFJLFNBQVMsUUFBUSxPQUFPLFVBQVUsV0FBVztBQUMvQyxXQUFPLFlBQVksT0FBTztBQUFBLEVBQzVCLFdBQVcsUUFBUSxLQUFLLEdBQUc7QUFDekIsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBO0FBQUEsTUFFQSxNQUFNLE1BQU07QUFBQSxJQUNkO0FBQUEsRUFDRixXQUFXLE9BQU8sVUFBVSxVQUFVO0FBQ3BDLFdBQU8sZUFBZSxLQUFLO0FBQUEsRUFDN0IsT0FBTztBQUNMLFdBQU8sWUFBWSxNQUFNLE1BQU0sT0FBTyxLQUFLLENBQUM7QUFBQSxFQUM5QztBQUNGO0FBQ0EsU0FBUyxlQUFlLE9BQU87QUFDN0IsU0FBTyxNQUFNLE9BQU8sUUFBUSxNQUFNLGNBQWMsTUFBTSxNQUFNLE9BQU8sUUFBUSxXQUFXLEtBQUs7QUFDN0Y7QUFDQSxTQUFTLGtCQUFrQixPQUFPLFVBQVU7QUFDMUMsTUFBSSxPQUFPO0FBQ1gsUUFBTSxFQUFFLFVBQVUsSUFBSTtBQUN0QixNQUFJLFlBQVksTUFBTTtBQUNwQixlQUFXO0FBQUEsRUFDYixXQUFXLFFBQVEsUUFBUSxHQUFHO0FBQzVCLFdBQU87QUFBQSxFQUNULFdBQVcsT0FBTyxhQUFhLFVBQVU7QUFDdkMsUUFBSSxhQUFhLElBQUksS0FBSztBQUN4QixZQUFNLE9BQU8sU0FBUztBQUN0QixVQUFJLE1BQU07QUFDUixhQUFLLE9BQU8sS0FBSyxLQUFLO0FBQ3RCLDBCQUFrQixPQUFPLEtBQUssQ0FBQztBQUMvQixhQUFLLE9BQU8sS0FBSyxLQUFLO0FBQUEsTUFDeEI7QUFDQTtBQUFBLElBQ0YsT0FBTztBQUNMLGFBQU87QUFDUCxZQUFNLFdBQVcsU0FBUztBQUMxQixVQUFJLENBQUMsWUFBWSxFQUFFLHFCQUFxQixXQUFXO0FBQ2pELGlCQUFTLE9BQU87QUFBQSxNQUNsQixXQUFXLGFBQWEsS0FBSywwQkFBMEI7QUFDckQsWUFBSSx5QkFBeUIsTUFBTSxNQUFNLEdBQUc7QUFDMUMsbUJBQVMsSUFBSTtBQUFBLFFBQ2YsT0FBTztBQUNMLG1CQUFTLElBQUk7QUFDYixnQkFBTSxhQUFhO0FBQUEsUUFDckI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0YsV0FBVyxXQUFXLFFBQVEsR0FBRztBQUMvQixlQUFXLEVBQUUsU0FBUyxVQUFVLE1BQU0seUJBQXlCO0FBQy9ELFdBQU87QUFBQSxFQUNULE9BQU87QUFDTCxlQUFXLE9BQU8sUUFBUTtBQUMxQixRQUFJLFlBQVksSUFBSTtBQUNsQixhQUFPO0FBQ1AsaUJBQVcsQ0FBQyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUEsSUFDdkMsT0FBTztBQUNMLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNBLFFBQU0sV0FBVztBQUNqQixRQUFNLGFBQWE7QUFDckI7QUFDQSxTQUFTLGNBQWMsTUFBTTtBQUMzQixRQUFNLE1BQU0sQ0FBQztBQUNiLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDcEMsVUFBTSxVQUFVLEtBQUs7QUFDckIsZUFBVyxPQUFPLFNBQVM7QUFDekIsVUFBSSxRQUFRLFNBQVM7QUFDbkIsWUFBSSxJQUFJLFVBQVUsUUFBUSxPQUFPO0FBQy9CLGNBQUksUUFBUSxlQUFlLENBQUMsSUFBSSxPQUFPLFFBQVEsS0FBSyxDQUFDO0FBQUEsUUFDdkQ7QUFBQSxNQUNGLFdBQVcsUUFBUSxTQUFTO0FBQzFCLFlBQUksUUFBUSxlQUFlLENBQUMsSUFBSSxPQUFPLFFBQVEsS0FBSyxDQUFDO0FBQUEsTUFDdkQsV0FBVyxLQUFLLEdBQUcsR0FBRztBQUNwQixjQUFNLFdBQVcsSUFBSTtBQUNyQixjQUFNLFdBQVcsUUFBUTtBQUN6QixZQUFJLFlBQVksYUFBYSxZQUFZLEVBQUUsUUFBUSxRQUFRLEtBQUssU0FBUyxTQUFTLFFBQVEsSUFBSTtBQUM1RixjQUFJLE9BQU8sV0FBVyxDQUFDLEVBQUUsT0FBTyxVQUFVLFFBQVEsSUFBSTtBQUFBLFFBQ3hEO0FBQUEsTUFDRixXQUFXLFFBQVEsSUFBSTtBQUNyQixZQUFJLE9BQU8sUUFBUTtBQUFBLE1BQ3JCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLGdCQUFnQixNQUFNLFVBQVUsT0FBTyxZQUFZLE1BQU07QUFDaEUsNkJBQTJCLE1BQU0sVUFBVSxHQUFHO0FBQUEsSUFDNUM7QUFBQSxJQUNBO0FBQUEsRUFDRixDQUFDO0FBQ0g7QUFFQSxJQUFNLGtCQUFrQixpQkFBaUI7QUFDekMsSUFBSSxNQUFNO0FBQ1YsU0FBUyx3QkFBd0IsT0FBTyxRQUFRLFVBQVU7QUFDeEQsUUFBTSxPQUFPLE1BQU07QUFDbkIsUUFBTSxjQUFjLFNBQVMsT0FBTyxhQUFhLE1BQU0sZUFBZTtBQUN0RSxRQUFNLFdBQVc7QUFBQSxJQUNmLEtBQUs7QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFFTixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFFVCxRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFFUixPQUFPLElBQUk7QUFBQSxNQUNUO0FBQUEsSUFFRjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsYUFBYTtBQUFBLElBQ2IsV0FBVztBQUFBLElBQ1gsVUFBVSxTQUFTLE9BQU8sV0FBVyxPQUFPLE9BQU8sV0FBVyxRQUFRO0FBQUEsSUFDdEUsYUFBYTtBQUFBLElBQ2IsYUFBYSxDQUFDO0FBQUEsSUFFZCxZQUFZO0FBQUEsSUFDWixZQUFZO0FBQUEsSUFFWixjQUFjLHNCQUFzQixNQUFNLFVBQVU7QUFBQSxJQUNwRCxjQUFjLHNCQUFzQixNQUFNLFVBQVU7QUFBQSxJQUVwRCxNQUFNO0FBQUEsSUFFTixTQUFTO0FBQUEsSUFFVCxlQUFlO0FBQUEsSUFFZixjQUFjLEtBQUs7QUFBQSxJQUVuQixLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixZQUFZO0FBQUEsSUFDWixjQUFjO0FBQUEsSUFDZCxZQUFZO0FBQUEsSUFDWixZQUFZO0FBQUEsSUFFWjtBQUFBLElBQ0EsWUFBWSxXQUFXLFNBQVMsWUFBWTtBQUFBLElBQzVDLFVBQVU7QUFBQSxJQUNWLGVBQWU7QUFBQSxJQUdmLFdBQVc7QUFBQSxJQUNYLGFBQWE7QUFBQSxJQUNiLGVBQWU7QUFBQSxJQUNmLElBQUk7QUFBQSxJQUNKLEdBQUc7QUFBQSxJQUNILElBQUk7QUFBQSxJQUNKLEdBQUc7QUFBQSxJQUNILElBQUk7QUFBQSxJQUNKLEdBQUc7QUFBQSxJQUNILElBQUk7QUFBQSxJQUNKLEtBQUs7QUFBQSxJQUNMLElBQUk7QUFBQSxJQUNKLEdBQUc7QUFBQSxJQUNILEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLElBQUk7QUFBQSxJQUNKLElBQUk7QUFBQSxFQUNOO0FBQ0EsTUFBSSxPQUEyQztBQUM3QyxhQUFTLE1BQU0sdUJBQXVCLFFBQVE7QUFBQSxFQUNoRCxPQUFPO0FBQ0wsYUFBUyxNQUFNLEVBQUUsR0FBRyxTQUFTO0FBQUEsRUFDL0I7QUFDQSxXQUFTLE9BQU8sU0FBUyxPQUFPLE9BQU87QUFDdkMsV0FBUyxPQUFPLEtBQUssS0FBSyxNQUFNLFFBQVE7QUFDeEMsTUFBSSxNQUFNLElBQUk7QUFDWixVQUFNLEdBQUcsUUFBUTtBQUFBLEVBQ25CO0FBQ0EsU0FBTztBQUNUO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEIsSUFBTSxxQkFBcUIsTUFBTSxtQkFBbUI7QUFDcEQsSUFBSTtBQUNKLElBQUk7QUFDSixJQUFJLGFBQWE7QUFDakI7QUFDRSxNQUFJLEVBQUUsK0JBQStCLGNBQWMsRUFBRSxjQUFjO0FBQ2pFLG1DQUErQixjQUFjLEVBQUUsY0FBYyxDQUFDO0FBQUEsRUFDaEU7QUFDQSwrQkFBNkIsS0FBSyxDQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDNUQsK0JBQTZCLENBQUMsYUFBYTtBQUN6QyxRQUFJLDZCQUE2QixTQUFTLEdBQUc7QUFDM0MsbUNBQTZCLFFBQVEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDO0FBQUEsSUFDekQsT0FBTztBQUNMLG1DQUE2QixHQUFHLFFBQVE7QUFBQSxJQUMxQztBQUFBLEVBQ0Y7QUFDRjtBQUNBLElBQU0scUJBQXFCLENBQUMsYUFBYTtBQUN2Qyw2QkFBMkIsUUFBUTtBQUNuQyxXQUFTLE1BQU0sR0FBRztBQUNwQjtBQUNBLElBQU0sdUJBQXVCLE1BQU07QUFDakMscUJBQW1CLGdCQUFnQixNQUFNLElBQUk7QUFDN0MsNkJBQTJCLElBQUk7QUFDakM7QUFVQSxTQUFTLG9CQUFvQixVQUFVO0FBQ3JDLFNBQU8sU0FBUyxNQUFNLFlBQVk7QUFDcEM7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QixTQUFTLGVBQWUsVUFBVSxRQUFRLE9BQU87QUFDL0MsMEJBQXdCO0FBQ3hCLFFBQU0sRUFBRSxPQUFPLFNBQVMsSUFBSSxTQUFTO0FBQ3JDLFFBQU0sYUFBYSxvQkFBb0IsUUFBUTtBQUMvQyxZQUFVLFVBQVUsT0FBTyxZQUFZLEtBQUs7QUFDNUMsWUFBVSxVQUFVLFFBQVE7QUFDNUIsUUFBTSxjQUFjLGFBQWEsdUJBQXVCLFVBQVUsS0FBSyxJQUFJO0FBQzNFLDBCQUF3QjtBQUN4QixTQUFPO0FBQ1Q7QUFDQSxTQUFTLHVCQUF1QixVQUFVLE9BQU87QUFDL0MsTUFBSTtBQUNKLFFBQU0sWUFBWSxTQUFTO0FBQzNCLE1BQUksT0FBMkM7QUFDN0MsUUFBSSxVQUFVLE1BQU07QUFDbEIsNEJBQXNCLFVBQVUsTUFBTSxTQUFTLFdBQVcsTUFBTTtBQUFBLElBQ2xFO0FBQ0EsUUFBSSxVQUFVLFlBQVk7QUFDeEIsWUFBTSxRQUFRLE9BQU8sS0FBSyxVQUFVLFVBQVU7QUFDOUMsZUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyw4QkFBc0IsTUFBTSxJQUFJLFNBQVMsV0FBVyxNQUFNO0FBQUEsTUFDNUQ7QUFBQSxJQUNGO0FBQ0EsUUFBSSxVQUFVLFlBQVk7QUFDeEIsWUFBTSxRQUFRLE9BQU8sS0FBSyxVQUFVLFVBQVU7QUFDOUMsZUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyw4QkFBc0IsTUFBTSxFQUFFO0FBQUEsTUFDaEM7QUFBQSxJQUNGO0FBQ0EsUUFBSSxVQUFVLG1CQUFtQixjQUFjLEdBQUc7QUFDaEQ7QUFBQSxRQUNFO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsV0FBUyxjQUE4Qix1QkFBTyxPQUFPLElBQUk7QUFDekQsV0FBUyxRQUFRLFFBQVEsSUFBSSxNQUFNLFNBQVMsS0FBSywyQkFBMkIsQ0FBQztBQUM3RSxNQUFJLE9BQTJDO0FBQzdDLCtCQUEyQixRQUFRO0FBQUEsRUFDckM7QUFDQSxRQUFNLEVBQUUsTUFBTSxJQUFJO0FBQ2xCLE1BQUksT0FBTztBQUNULFVBQU0sZUFBZSxTQUFTLGVBQWUsTUFBTSxTQUFTLElBQUksbUJBQW1CLFFBQVEsSUFBSTtBQUMvRix1QkFBbUIsUUFBUTtBQUMzQixrQkFBYztBQUNkLFVBQU0sY0FBYztBQUFBLE1BQ2xCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLENBQUMsUUFBNEMsZ0JBQWdCLFNBQVMsS0FBSyxJQUFJLFNBQVMsT0FBTyxZQUFZO0FBQUEsSUFDN0c7QUFDQSxrQkFBYztBQUNkLHlCQUFxQjtBQUNyQixRQUFJLFVBQVUsV0FBVyxHQUFHO0FBQzFCLGtCQUFZLEtBQUssc0JBQXNCLG9CQUFvQjtBQUMzRCxVQUFJLE9BQU87QUFDVCxlQUFPLFlBQVksS0FBSyxDQUFDLG1CQUFtQjtBQUMxQyw0QkFBa0IsVUFBVSxnQkFBZ0IsS0FBSztBQUFBLFFBQ25ELENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTTtBQUNkLHNCQUFZLEdBQUcsVUFBVSxDQUFDO0FBQUEsUUFDNUIsQ0FBQztBQUFBLE1BQ0gsT0FBTztBQUNMLGlCQUFTLFdBQVc7QUFDcEIsWUFBSSxPQUFpRTtBQUNuRSxnQkFBTSxRQUFRLEtBQUssVUFBVSxTQUFTLE9BQU8sS0FBSztBQUNsRDtBQUFBLFlBQ0UsY0FBYztBQUFBLFVBQ2hCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLE9BQU87QUFDTCx3QkFBa0IsVUFBVSxhQUFhLEtBQUs7QUFBQSxJQUNoRDtBQUFBLEVBQ0YsT0FBTztBQUNMLHlCQUFxQixVQUFVLEtBQUs7QUFBQSxFQUN0QztBQUNGO0FBQ0EsU0FBUyxrQkFBa0IsVUFBVSxhQUFhLE9BQU87QUFDdkQsTUFBSSxXQUFXLFdBQVcsR0FBRztBQUMzQixRQUFJLFNBQVMsS0FBSyxtQkFBbUI7QUFDbkMsZUFBUyxZQUFZO0FBQUEsSUFDdkIsT0FBTztBQUNMLGVBQVMsU0FBUztBQUFBLElBQ3BCO0FBQUEsRUFDRixXQUFXLFNBQVMsV0FBVyxHQUFHO0FBQ2hDLFFBQUksT0FBbUU7QUFDckU7QUFBQSxRQUNFO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxRQUFpRCxPQUF1QjtBQUN0RSxlQUFTLHdCQUF3QjtBQUFBLElBQ25DO0FBQ0EsYUFBUyxhQUFhLFVBQVUsV0FBVztBQUMzQyxRQUFJLE9BQTJDO0FBQzdDLHNDQUFnQyxRQUFRO0FBQUEsSUFDMUM7QUFBQSxFQUNGLFdBQVcsT0FBcUU7QUFDOUU7QUFBQSxNQUNFLDhDQUE4QyxnQkFBZ0IsT0FBTyxTQUFTLE9BQU87QUFBQSxJQUN2RjtBQUFBLEVBQ0Y7QUFDQSx1QkFBcUIsVUFBVSxLQUFLO0FBQ3RDO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFVSixTQUFTLHFCQUFxQixVQUFVLE9BQU8sYUFBYTtBQUMxRCxRQUFNLFlBQVksU0FBUztBQUMzQixNQUFJLENBQUMsU0FBUyxRQUFRO0FBQ3BCLFFBQUksQ0FBQyxTQUFTLFdBQVcsQ0FBQyxVQUFVLFFBQVE7QUFDMUMsWUFBTSxXQUFXLFVBQVUsWUFBWSxxQkFBcUIsUUFBUSxFQUFFO0FBQ3RFLFVBQUksVUFBVTtBQUNaLFlBQUksT0FBMkM7QUFDN0MsdUJBQWEsVUFBVSxTQUFTO0FBQUEsUUFDbEM7QUFDQSxjQUFNLEVBQUUsaUJBQWlCLGdCQUFnQixJQUFJLFNBQVMsV0FBVztBQUNqRSxjQUFNLEVBQUUsWUFBWSxpQkFBaUIseUJBQXlCLElBQUk7QUFDbEUsY0FBTSx1QkFBdUI7QUFBQSxVQUMzQjtBQUFBLFlBQ0U7QUFBQSxjQUNFO0FBQUEsY0FDQTtBQUFBLFlBQ0Y7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0Esa0JBQVUsU0FBUyxRQUFRLFVBQVUsb0JBQW9CO0FBQ3pELFlBQUksT0FBMkM7QUFDN0MscUJBQVcsVUFBVSxTQUFTO0FBQUEsUUFDaEM7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLGFBQVMsU0FBUyxVQUFVLFVBQVU7QUFDdEMsUUFBSSxrQkFBa0I7QUFDcEIsdUJBQWlCLFFBQVE7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFDQSxNQUEyQixNQUFNO0FBQy9CLHVCQUFtQixRQUFRO0FBQzNCLGtCQUFjO0FBQ2QsaUJBQWEsUUFBUTtBQUNyQixrQkFBYztBQUNkLHlCQUFxQjtBQUFBLEVBQ3ZCO0FBQ0EsTUFBSSxPQUFzRztBQUN4RyxRQUFJLENBQUMsV0FBVyxVQUFVLFVBQVU7QUFDbEM7QUFBQSxRQUNFO0FBQUEsTUFFRjtBQUFBLElBQ0YsT0FBTztBQUNMLFdBQUssbURBQW1EO0FBQUEsSUFDMUQ7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLGNBQWMsVUFBVTtBQUMvQixTQUFPLFNBQVMsZUFBZSxTQUFTLGFBQWEsSUFBSTtBQUFBLElBQ3ZELFNBQVM7QUFBQSxJQUNULFFBQTRDO0FBQUEsTUFDMUMsSUFBSSxRQUFRLEtBQUs7QUFDZiwwQkFBa0I7QUFDbEIsY0FBTSxVQUFVLE9BQU8sUUFBUTtBQUMvQixlQUFPLE9BQU87QUFBQSxNQUNoQjtBQUFBLE1BQ0EsTUFBTTtBQUNKLGFBQUssaUNBQWlDO0FBQ3RDLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxpQkFBaUI7QUFDZixhQUFLLGlDQUFpQztBQUN0QyxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0YsSUFBSTtBQUFBLE1BQ0YsSUFBSSxRQUFRLEtBQUs7QUFDZixjQUFNLFVBQVUsT0FBTyxRQUFRO0FBQy9CLGVBQU8sT0FBTztBQUFBLE1BQ2hCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQVNBLFNBQVMsbUJBQW1CLFVBQVU7QUFDcEMsUUFBTSxTQUFTLENBQUMsWUFBWTtBQUMxQixRQUFJLE9BQTJDO0FBQzdDLFVBQUksU0FBUyxTQUFTO0FBQ3BCLGFBQUssa0RBQWtEO0FBQUEsTUFDekQ7QUFDQSxVQUFJLFdBQVcsTUFBTTtBQUNuQixZQUFJLGNBQWMsT0FBTztBQUN6QixZQUFJLGdCQUFnQixVQUFVO0FBQzVCLGNBQUksUUFBUSxPQUFPLEdBQUc7QUFDcEIsMEJBQWM7QUFBQSxVQUNoQixXQUFXLE1BQU0sT0FBTyxHQUFHO0FBQ3pCLDBCQUFjO0FBQUEsVUFDaEI7QUFBQSxRQUNGO0FBQ0EsWUFBSSxnQkFBZ0IsVUFBVTtBQUM1QjtBQUFBLFlBQ0Usc0RBQXNEO0FBQUEsVUFDeEQ7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxhQUFTLFVBQVUsV0FBVyxDQUFDO0FBQUEsRUFDakM7QUFDQSxNQUFJLE9BQTJDO0FBQzdDLFdBQU8sT0FBTyxPQUFPO0FBQUEsTUFDbkIsSUFBSSxRQUFRO0FBQ1YsZUFBTyxjQUFjLFFBQVE7QUFBQSxNQUMvQjtBQUFBLE1BQ0EsSUFBSSxRQUFRO0FBQ1YsZUFBTyxjQUFjLFFBQVE7QUFBQSxNQUMvQjtBQUFBLE1BQ0EsSUFBSSxPQUFPO0FBQ1QsZUFBTyxDQUFDLFVBQVUsU0FBUyxTQUFTLEtBQUssT0FBTyxHQUFHLElBQUk7QUFBQSxNQUN6RDtBQUFBLE1BQ0E7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNILE9BQU87QUFDTCxXQUFPO0FBQUEsTUFDTCxJQUFJLFFBQVE7QUFDVixlQUFPLGNBQWMsUUFBUTtBQUFBLE1BQy9CO0FBQUEsTUFDQSxPQUFPLFNBQVM7QUFBQSxNQUNoQixNQUFNLFNBQVM7QUFBQSxNQUNmO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLFNBQVMsZUFBZSxVQUFVO0FBQ2hDLE1BQUksU0FBUyxTQUFTO0FBQ3BCLFdBQU8sU0FBUyxnQkFBZ0IsU0FBUyxjQUFjLElBQUksTUFBTSxVQUFVLFFBQVEsU0FBUyxPQUFPLENBQUMsR0FBRztBQUFBLE1BQ3JHLElBQUksUUFBUSxLQUFLO0FBQ2YsWUFBSSxPQUFPLFFBQVE7QUFDakIsaUJBQU8sT0FBTztBQUFBLFFBQ2hCLFdBQVcsT0FBTyxxQkFBcUI7QUFDckMsaUJBQU8sb0JBQW9CLEtBQUssUUFBUTtBQUFBLFFBQzFDO0FBQUEsTUFDRjtBQUFBLE1BQ0EsSUFBSSxRQUFRLEtBQUs7QUFDZixlQUFPLE9BQU8sVUFBVSxPQUFPO0FBQUEsTUFDakM7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBQ0Y7QUFDQSxJQUFNLGFBQWE7QUFDbkIsSUFBTSxXQUFXLENBQUMsUUFBUSxJQUFJLFFBQVEsWUFBWSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsRUFBRSxRQUFRLFNBQVMsRUFBRTtBQUM3RixTQUFTLGlCQUFpQixXQUFXLGtCQUFrQixNQUFNO0FBQzNELFNBQU8sV0FBVyxTQUFTLElBQUksVUFBVSxlQUFlLFVBQVUsT0FBTyxVQUFVLFFBQVEsbUJBQW1CLFVBQVU7QUFDMUg7QUFDQSxTQUFTLG9CQUFvQixVQUFVLFdBQVcsU0FBUyxPQUFPO0FBQ2hFLE1BQUksT0FBTyxpQkFBaUIsU0FBUztBQUNyQyxNQUFJLENBQUMsUUFBUSxVQUFVLFFBQVE7QUFDN0IsVUFBTSxRQUFRLFVBQVUsT0FBTyxNQUFNLGlCQUFpQjtBQUN0RCxRQUFJLE9BQU87QUFDVCxhQUFPLE1BQU07QUFBQSxJQUNmO0FBQUEsRUFDRjtBQUNBLE1BQUksQ0FBQyxRQUFRLFlBQVksU0FBUyxRQUFRO0FBQ3hDLFVBQU0sb0JBQW9CLENBQUMsYUFBYTtBQUN0QyxpQkFBVyxPQUFPLFVBQVU7QUFDMUIsWUFBSSxTQUFTLFNBQVMsV0FBVztBQUMvQixpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFdBQU87QUFBQSxNQUNMLFNBQVMsY0FBYyxTQUFTLE9BQU8sS0FBSztBQUFBLElBQzlDLEtBQUssa0JBQWtCLFNBQVMsV0FBVyxVQUFVO0FBQUEsRUFDdkQ7QUFDQSxTQUFPLE9BQU8sU0FBUyxJQUFJLElBQUksU0FBUyxRQUFRO0FBQ2xEO0FBQ0EsU0FBUyxpQkFBaUIsT0FBTztBQUMvQixTQUFPLFdBQVcsS0FBSyxLQUFLLGVBQWU7QUFDN0M7QUFFQSxJQUFNQyxZQUFXLENBQUMsaUJBQWlCLGlCQUFpQjtBQUNsRCxTQUFPLFNBQVcsaUJBQWlCLGNBQWMscUJBQXFCO0FBQ3hFO0FBRUEsU0FBUyxFQUFFLE1BQU0saUJBQWlCLFVBQVU7QUFDMUMsUUFBTSxJQUFJLFVBQVU7QUFDcEIsTUFBSSxNQUFNLEdBQUc7QUFDWCxRQUFJLFNBQVMsZUFBZSxLQUFLLENBQUMsUUFBUSxlQUFlLEdBQUc7QUFDMUQsVUFBSSxRQUFRLGVBQWUsR0FBRztBQUM1QixlQUFPLFlBQVksTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDO0FBQUEsTUFDbEQ7QUFDQSxhQUFPLFlBQVksTUFBTSxlQUFlO0FBQUEsSUFDMUMsT0FBTztBQUNMLGFBQU8sWUFBWSxNQUFNLE1BQU0sZUFBZTtBQUFBLElBQ2hEO0FBQUEsRUFDRixPQUFPO0FBQ0wsUUFBSSxJQUFJLEdBQUc7QUFDVCxpQkFBVyxNQUFNLFVBQVUsTUFBTSxLQUFLLFdBQVcsQ0FBQztBQUFBLElBQ3BELFdBQVcsTUFBTSxLQUFLLFFBQVEsUUFBUSxHQUFHO0FBQ3ZDLGlCQUFXLENBQUMsUUFBUTtBQUFBLElBQ3RCO0FBQ0EsV0FBTyxZQUFZLE1BQU0saUJBQWlCLFFBQVE7QUFBQSxFQUNwRDtBQUNGO0FBRUEsSUFBTSxnQkFBZ0IsT0FBTyxJQUFJLE9BQU87QUFDeEMsSUFBTSxnQkFBZ0IsTUFBTTtBQUMxQjtBQUNFLFVBQU0sTUFBTSxPQUFPLGFBQWE7QUFDaEMsUUFBSSxDQUFDLEtBQUs7QUFBQSxJQUlWO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQStNQSxJQUFNLFVBQVU7OztBQzFpUGhCLElBQU0sUUFBUTtBQUNkLElBQU0sTUFBTSxPQUFPLGFBQWEsY0FBYyxXQUFXO0FBQ3pELElBQU0sb0JBQW9CLE9BQXVCLG9CQUFJLGNBQWMsVUFBVTtBQUM3RSxJQUFNLFVBQVU7QUFBQSxFQUNkLFFBQVEsQ0FBQyxPQUFPLFFBQVEsV0FBVztBQUNqQyxXQUFPLGFBQWEsT0FBTyxVQUFVLElBQUk7QUFBQSxFQUMzQztBQUFBLEVBQ0EsUUFBUSxDQUFDLFVBQVU7QUFDakIsVUFBTSxTQUFTLE1BQU07QUFDckIsUUFBSSxRQUFRO0FBQ1YsYUFBTyxZQUFZLEtBQUs7QUFBQSxJQUMxQjtBQUFBLEVBQ0Y7QUFBQSxFQUNBLGVBQWUsQ0FBQyxLQUFLLE9BQU8sSUFBSSxVQUFVO0FBQ3hDLFVBQU0sS0FBSyxRQUFRLElBQUksZ0JBQWdCLE9BQU8sR0FBRyxJQUFJLElBQUksY0FBYyxLQUFLLEtBQUssRUFBRSxHQUFHLElBQUksTUFBTTtBQUNoRyxRQUFJLFFBQVEsWUFBWSxTQUFTLE1BQU0sWUFBWSxNQUFNO0FBQ3ZELFNBQUcsYUFBYSxZQUFZLE1BQU0sUUFBUTtBQUFBLElBQzVDO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFlBQVksQ0FBQyxTQUFTLElBQUksZUFBZSxJQUFJO0FBQUEsRUFDN0MsZUFBZSxDQUFDLFNBQVMsSUFBSSxjQUFjLElBQUk7QUFBQSxFQUMvQyxTQUFTLENBQUMsTUFBTSxTQUFTO0FBQ3ZCLFNBQUssWUFBWTtBQUFBLEVBQ25CO0FBQUEsRUFDQSxnQkFBZ0IsQ0FBQyxJQUFJLFNBQVM7QUFDNUIsT0FBRyxjQUFjO0FBQUEsRUFDbkI7QUFBQSxFQUNBLFlBQVksQ0FBQyxTQUFTLEtBQUs7QUFBQSxFQUMzQixhQUFhLENBQUMsU0FBUyxLQUFLO0FBQUEsRUFDNUIsZUFBZSxDQUFDLGFBQWEsSUFBSSxjQUFjLFFBQVE7QUFBQSxFQUN2RCxXQUFXLElBQUksSUFBSTtBQUNqQixPQUFHLGFBQWEsSUFBSSxFQUFFO0FBQUEsRUFDeEI7QUFBQSxFQUtBLG9CQUFvQixTQUFTLFFBQVEsUUFBUSxPQUFPLE9BQU8sS0FBSztBQUM5RCxVQUFNLFNBQVMsU0FBUyxPQUFPLGtCQUFrQixPQUFPO0FBQ3hELFFBQUksVUFBVSxVQUFVLE9BQU8sTUFBTSxjQUFjO0FBQ2pELGFBQU8sTUFBTTtBQUNYLGVBQU8sYUFBYSxNQUFNLFVBQVUsSUFBSSxHQUFHLE1BQU07QUFDakQsWUFBSSxVQUFVLE9BQU8sRUFBRSxRQUFRLE1BQU07QUFDbkM7QUFBQSxNQUNKO0FBQUEsSUFDRixPQUFPO0FBQ0wsd0JBQWtCLFlBQVksUUFBUSxRQUFRLGtCQUFrQjtBQUNoRSxZQUFNLFdBQVcsa0JBQWtCO0FBQ25DLFVBQUksT0FBTztBQUNULGNBQU0sVUFBVSxTQUFTO0FBQ3pCLGVBQU8sUUFBUSxZQUFZO0FBQ3pCLG1CQUFTLFlBQVksUUFBUSxVQUFVO0FBQUEsUUFDekM7QUFDQSxpQkFBUyxZQUFZLE9BQU87QUFBQSxNQUM5QjtBQUNBLGFBQU8sYUFBYSxVQUFVLE1BQU07QUFBQSxJQUN0QztBQUNBLFdBQU87QUFBQSxNQUVMLFNBQVMsT0FBTyxjQUFjLE9BQU87QUFBQSxNQUVyQyxTQUFTLE9BQU8sa0JBQWtCLE9BQU87QUFBQSxJQUMzQztBQUFBLEVBQ0Y7QUFDRjtBQUVBLFNBQVMsV0FBVyxJQUFJLE9BQU8sT0FBTztBQUNwQyxRQUFNLG9CQUFvQixHQUFHO0FBQzdCLE1BQUksbUJBQW1CO0FBQ3JCLGFBQVMsUUFBUSxDQUFDLE9BQU8sR0FBRyxpQkFBaUIsSUFBSSxDQUFDLEdBQUcsaUJBQWlCLEdBQUcsS0FBSyxHQUFHO0FBQUEsRUFDbkY7QUFDQSxNQUFJLFNBQVMsTUFBTTtBQUNqQixPQUFHLGdCQUFnQixPQUFPO0FBQUEsRUFDNUIsV0FBVyxPQUFPO0FBQ2hCLE9BQUcsYUFBYSxTQUFTLEtBQUs7QUFBQSxFQUNoQyxPQUFPO0FBQ0wsT0FBRyxZQUFZO0FBQUEsRUFDakI7QUFDRjtBQUVBLFNBQVMsV0FBVyxJQUFJLE1BQU0sTUFBTTtBQUNsQyxRQUFNLFFBQVEsR0FBRztBQUNqQixRQUFNLGNBQWMsU0FBUyxJQUFJO0FBQ2pDLE1BQUksUUFBUSxDQUFDLGFBQWE7QUFDeEIsUUFBSSxRQUFRLENBQUMsU0FBUyxJQUFJLEdBQUc7QUFDM0IsaUJBQVcsT0FBTyxNQUFNO0FBQ3RCLFlBQUksS0FBSyxRQUFRLE1BQU07QUFDckIsbUJBQVMsT0FBTyxLQUFLLEVBQUU7QUFBQSxRQUN6QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsZUFBVyxPQUFPLE1BQU07QUFDdEIsZUFBUyxPQUFPLEtBQUssS0FBSyxJQUFJO0FBQUEsSUFDaEM7QUFBQSxFQUNGLE9BQU87QUFDTCxVQUFNLGlCQUFpQixNQUFNO0FBQzdCLFFBQUksYUFBYTtBQUNmLFVBQUksU0FBUyxNQUFNO0FBQ2pCLGNBQU0sVUFBVTtBQUFBLE1BQ2xCO0FBQUEsSUFDRixXQUFXLE1BQU07QUFDZixTQUFHLGdCQUFnQixPQUFPO0FBQUEsSUFDNUI7QUFDQSxRQUFJLFVBQVUsSUFBSTtBQUNoQixZQUFNLFVBQVU7QUFBQSxJQUNsQjtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU0sY0FBYztBQUNwQixTQUFTLFNBQVMsT0FBTyxNQUFNLEtBQUs7QUFDbEMsTUFBSSxRQUFRLEdBQUcsR0FBRztBQUNoQixRQUFJLFFBQVEsQ0FBQyxNQUFNLFNBQVMsT0FBTyxNQUFNLENBQUMsQ0FBQztBQUFBLEVBQzdDLE9BQU87QUFDTCxRQUFJLE9BQU87QUFDVCxZQUFNO0FBQ1IsUUFBSSxPQUEyQztBQUM3QyxVQUFJLFlBQVksS0FBSyxHQUFHLEdBQUc7QUFDekI7QUFBQSxVQUNFLHVDQUF1Qyx1QkFBdUI7QUFBQSxRQUNoRTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsUUFBSSxLQUFLLFdBQVcsSUFBSSxHQUFHO0FBQ3pCLFlBQU0sWUFBWSxNQUFNLEdBQUc7QUFBQSxJQUM3QixPQUFPO0FBQ0wsWUFBTSxXQUFXLFdBQVcsT0FBTyxJQUFJO0FBQ3ZDLFVBQUksWUFBWSxLQUFLLEdBQUcsR0FBRztBQUN6QixjQUFNO0FBQUEsVUFDSixVQUFVLFFBQVE7QUFBQSxVQUNsQixJQUFJLFFBQVEsYUFBYSxFQUFFO0FBQUEsVUFDM0I7QUFBQSxRQUNGO0FBQUEsTUFDRixPQUFPO0FBQ0wsY0FBTSxZQUFZO0FBQUEsTUFDcEI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTSxXQUFXLENBQUMsVUFBVSxPQUFPLElBQUk7QUFDdkMsSUFBTSxjQUFjLENBQUM7QUFDckIsU0FBUyxXQUFXLE9BQU8sU0FBUztBQUNsQyxRQUFNLFNBQVMsWUFBWTtBQUMzQixNQUFJLFFBQVE7QUFDVixXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksT0FBTyxTQUFTLE9BQU87QUFDM0IsTUFBSSxTQUFTLFlBQVksUUFBUSxPQUFPO0FBQ3RDLFdBQU8sWUFBWSxXQUFXO0FBQUEsRUFDaEM7QUFDQSxTQUFPLFdBQVcsSUFBSTtBQUN0QixXQUFTLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxLQUFLO0FBQ3hDLFVBQU0sV0FBVyxTQUFTLEtBQUs7QUFDL0IsUUFBSSxZQUFZLE9BQU87QUFDckIsYUFBTyxZQUFZLFdBQVc7QUFBQSxJQUNoQztBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFFQSxJQUFNLFVBQVU7QUFDaEIsU0FBUyxVQUFVLElBQUksS0FBSyxPQUFPLE9BQU8sVUFBVTtBQUNsRCxNQUFJLFNBQVMsSUFBSSxXQUFXLFFBQVEsR0FBRztBQUNyQyxRQUFJLFNBQVMsTUFBTTtBQUNqQixTQUFHLGtCQUFrQixTQUFTLElBQUksTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDO0FBQUEsSUFDeEQsT0FBTztBQUNMLFNBQUcsZUFBZSxTQUFTLEtBQUssS0FBSztBQUFBLElBQ3ZDO0FBQUEsRUFDRixPQUFPO0FBQ0wsVUFBTSxZQUFZLHFCQUFxQixHQUFHO0FBQzFDLFFBQUksU0FBUyxRQUFRLGFBQWEsQ0FBQyxtQkFBbUIsS0FBSyxHQUFHO0FBQzVELFNBQUcsZ0JBQWdCLEdBQUc7QUFBQSxJQUN4QixPQUFPO0FBQ0wsU0FBRyxhQUFhLEtBQUssWUFBWSxLQUFLLEtBQUs7QUFBQSxJQUM3QztBQUFBLEVBQ0Y7QUFDRjtBQUVBLFNBQVMsYUFBYSxJQUFJLEtBQUssT0FBTyxjQUFjLGlCQUFpQixnQkFBZ0IsaUJBQWlCO0FBQ3BHLE1BQUksUUFBUSxlQUFlLFFBQVEsZUFBZTtBQUNoRCxRQUFJLGNBQWM7QUFDaEIsc0JBQWdCLGNBQWMsaUJBQWlCLGNBQWM7QUFBQSxJQUMvRDtBQUNBLE9BQUcsT0FBTyxTQUFTLE9BQU8sS0FBSztBQUMvQjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLE1BQU0sR0FBRztBQUNmLE1BQUksUUFBUSxXQUFXLFFBQVEsY0FDL0IsQ0FBQyxJQUFJLFNBQVMsR0FBRyxHQUFHO0FBQ2xCLE9BQUcsU0FBUztBQUNaLFVBQU0sV0FBVyxRQUFRLFdBQVcsR0FBRyxhQUFhLE9BQU8sSUFBSSxHQUFHO0FBQ2xFLFVBQU0sV0FBVyxTQUFTLE9BQU8sS0FBSztBQUN0QyxRQUFJLGFBQWEsVUFBVTtBQUN6QixTQUFHLFFBQVE7QUFBQSxJQUNiO0FBQ0EsUUFBSSxTQUFTLE1BQU07QUFDakIsU0FBRyxnQkFBZ0IsR0FBRztBQUFBLElBQ3hCO0FBQ0E7QUFBQSxFQUNGO0FBQ0EsTUFBSSxhQUFhO0FBQ2pCLE1BQUksVUFBVSxNQUFNLFNBQVMsTUFBTTtBQUNqQyxVQUFNLE9BQU8sT0FBTyxHQUFHO0FBQ3ZCLFFBQUksU0FBUyxXQUFXO0FBQ3RCLGNBQVEsbUJBQW1CLEtBQUs7QUFBQSxJQUNsQyxXQUFXLFNBQVMsUUFBUSxTQUFTLFVBQVU7QUFDN0MsY0FBUTtBQUNSLG1CQUFhO0FBQUEsSUFDZixXQUFXLFNBQVMsVUFBVTtBQUM1QixjQUFRO0FBQ1IsbUJBQWE7QUFBQSxJQUNmO0FBQUEsRUFDRjtBQUNBLE1BQUk7QUFDRixPQUFHLE9BQU87QUFBQSxFQUNaLFNBQVMsR0FBUDtBQUNBLFFBQUksT0FBMEQ7QUFDNUQ7QUFBQSxRQUNFLHdCQUF3QixZQUFZLElBQUksWUFBWSxhQUFhO0FBQUEsUUFDakU7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxnQkFBYyxHQUFHLGdCQUFnQixHQUFHO0FBQ3RDO0FBRUEsU0FBU0Msa0JBQWlCLElBQUksT0FBTyxTQUFTLFNBQVM7QUFDckQsS0FBRyxpQkFBaUIsT0FBTyxTQUFTLE9BQU87QUFDN0M7QUFDQSxTQUFTQyxxQkFBb0IsSUFBSSxPQUFPLFNBQVMsU0FBUztBQUN4RCxLQUFHLG9CQUFvQixPQUFPLFNBQVMsT0FBTztBQUNoRDtBQUNBLFNBQVMsV0FBVyxJQUFJLFNBQVMsV0FBVyxXQUFXLFdBQVcsTUFBTTtBQUN0RSxRQUFNLFdBQVcsR0FBRyxTQUFTLEdBQUcsT0FBTyxDQUFDO0FBQ3hDLFFBQU0sa0JBQWtCLFNBQVM7QUFDakMsTUFBSSxhQUFhLGlCQUFpQjtBQUNoQyxvQkFBZ0IsUUFBUTtBQUFBLEVBQzFCLE9BQU87QUFDTCxVQUFNLENBQUMsTUFBTSxPQUFPLElBQUksVUFBVSxPQUFPO0FBQ3pDLFFBQUksV0FBVztBQUNiLFlBQU0sVUFBVSxTQUFTLFdBQVcsY0FBYyxXQUFXLFFBQVE7QUFDckUsTUFBQUQsa0JBQWlCLElBQUksTUFBTSxTQUFTLE9BQU87QUFBQSxJQUM3QyxXQUFXLGlCQUFpQjtBQUMxQixNQUFBQyxxQkFBb0IsSUFBSSxNQUFNLGlCQUFpQixPQUFPO0FBQ3RELGVBQVMsV0FBVztBQUFBLElBQ3RCO0FBQUEsRUFDRjtBQUNGO0FBQ0EsSUFBTSxvQkFBb0I7QUFDMUIsU0FBUyxVQUFVLE1BQU07QUFDdkIsTUFBSTtBQUNKLE1BQUksa0JBQWtCLEtBQUssSUFBSSxHQUFHO0FBQ2hDLGNBQVUsQ0FBQztBQUNYLFFBQUk7QUFDSixXQUFPLElBQUksS0FBSyxNQUFNLGlCQUFpQixHQUFHO0FBQ3hDLGFBQU8sS0FBSyxNQUFNLEdBQUcsS0FBSyxTQUFTLEVBQUUsR0FBRyxNQUFNO0FBQzlDLGNBQVEsRUFBRSxHQUFHLFlBQVksS0FBSztBQUFBLElBQ2hDO0FBQUEsRUFDRjtBQUNBLFFBQU0sUUFBUSxLQUFLLE9BQU8sTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLFVBQVUsS0FBSyxNQUFNLENBQUMsQ0FBQztBQUN2RSxTQUFPLENBQUMsT0FBTyxPQUFPO0FBQ3hCO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCLElBQU0sSUFBb0Isd0JBQVEsUUFBUTtBQUMxQyxJQUFNLFNBQVMsTUFBTSxjQUFjLEVBQUUsS0FBSyxNQUFNLFlBQVksQ0FBQyxHQUFHLFlBQVksS0FBSyxJQUFJO0FBQ3JGLFNBQVMsY0FBYyxjQUFjLFVBQVU7QUFDN0MsUUFBTSxVQUFVLENBQUMsTUFBTTtBQUNyQixRQUFJLENBQUMsRUFBRSxNQUFNO0FBQ1gsUUFBRSxPQUFPLEtBQUssSUFBSTtBQUFBLElBQ3BCLFdBQVcsRUFBRSxRQUFRLFFBQVEsVUFBVTtBQUNyQztBQUFBLElBQ0Y7QUFDQTtBQUFBLE1BQ0UsOEJBQThCLEdBQUcsUUFBUSxLQUFLO0FBQUEsTUFDOUM7QUFBQSxNQUNBO0FBQUEsTUFDQSxDQUFDLENBQUM7QUFBQSxJQUNKO0FBQUEsRUFDRjtBQUNBLFVBQVEsUUFBUTtBQUNoQixVQUFRLFdBQVcsT0FBTztBQUMxQixTQUFPO0FBQ1Q7QUFDQSxTQUFTLDhCQUE4QixHQUFHLE9BQU87QUFDL0MsTUFBSSxRQUFRLEtBQUssR0FBRztBQUNsQixVQUFNLGVBQWUsRUFBRTtBQUN2QixNQUFFLDJCQUEyQixNQUFNO0FBQ2pDLG1CQUFhLEtBQUssQ0FBQztBQUNuQixRQUFFLFdBQVc7QUFBQSxJQUNmO0FBQ0EsV0FBTyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsWUFBWSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQUEsRUFDL0QsT0FBTztBQUNMLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFFQSxJQUFNLGFBQWE7QUFDbkIsSUFBTSxZQUFZLENBQUMsSUFBSSxLQUFLLFdBQVcsV0FBVyxRQUFRLE9BQU8sY0FBYyxpQkFBaUIsZ0JBQWdCLG9CQUFvQjtBQUNsSSxNQUFJLFFBQVEsU0FBUztBQUNuQixlQUFXLElBQUksV0FBVyxLQUFLO0FBQUEsRUFDakMsV0FBVyxRQUFRLFNBQVM7QUFDMUIsZUFBVyxJQUFJLFdBQVcsU0FBUztBQUFBLEVBQ3JDLFdBQVcsS0FBSyxHQUFHLEdBQUc7QUFDcEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHLEdBQUc7QUFDekIsaUJBQVcsSUFBSSxLQUFLLFdBQVcsV0FBVyxlQUFlO0FBQUEsSUFDM0Q7QUFBQSxFQUNGLFdBQVcsSUFBSSxPQUFPLE9BQU8sTUFBTSxJQUFJLE1BQU0sQ0FBQyxHQUFHLFFBQVEsSUFBSSxPQUFPLE9BQU8sTUFBTSxJQUFJLE1BQU0sQ0FBQyxHQUFHLFNBQVMsZ0JBQWdCLElBQUksS0FBSyxXQUFXLEtBQUssR0FBRztBQUNsSjtBQUFBLE1BQ0U7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBQ0wsUUFBSSxRQUFRLGNBQWM7QUFDeEIsU0FBRyxhQUFhO0FBQUEsSUFDbEIsV0FBVyxRQUFRLGVBQWU7QUFDaEMsU0FBRyxjQUFjO0FBQUEsSUFDbkI7QUFDQSxjQUFVLElBQUksS0FBSyxXQUFXLEtBQUs7QUFBQSxFQUNyQztBQUNGO0FBQ0EsU0FBUyxnQkFBZ0IsSUFBSSxLQUFLLE9BQU8sT0FBTztBQUM5QyxNQUFJLE9BQU87QUFDVCxRQUFJLFFBQVEsZUFBZSxRQUFRLGVBQWU7QUFDaEQsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLE9BQU8sTUFBTSxXQUFXLEtBQUssR0FBRyxLQUFLLFdBQVcsS0FBSyxHQUFHO0FBQzFELGFBQU87QUFBQSxJQUNUO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLFFBQVEsZ0JBQWdCLFFBQVEsZUFBZSxRQUFRLGFBQWE7QUFDdEUsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLFFBQVEsUUFBUTtBQUNsQixXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksUUFBUSxVQUFVLEdBQUcsWUFBWSxTQUFTO0FBQzVDLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxRQUFRLFVBQVUsR0FBRyxZQUFZLFlBQVk7QUFDL0MsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLFdBQVcsS0FBSyxHQUFHLEtBQUssU0FBUyxLQUFLLEdBQUc7QUFDM0MsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPLE9BQU87QUFDaEI7QUF1U0EsSUFBTSxhQUFhO0FBQ25CLElBQU0sWUFBWTtBQUNsQixJQUFNLGFBQWEsQ0FBQyxPQUFPLEVBQUUsTUFBTSxNQUFNLEVBQUUsZ0JBQWdCLHVCQUF1QixLQUFLLEdBQUcsS0FBSztBQUMvRixXQUFXLGNBQWM7QUFDekIsSUFBTSwrQkFBK0I7QUFBQSxFQUNuQyxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsSUFDSCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsRUFDWDtBQUFBLEVBQ0EsVUFBVSxDQUFDLFFBQVEsUUFBUSxNQUFNO0FBQUEsRUFDakMsZ0JBQWdCO0FBQUEsRUFDaEIsa0JBQWtCO0FBQUEsRUFDbEIsY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsbUJBQW1CO0FBQUEsRUFDbkIsZUFBZTtBQUFBLEVBQ2YsZ0JBQWdCO0FBQUEsRUFDaEIsa0JBQWtCO0FBQUEsRUFDbEIsY0FBYztBQUNoQjtBQUNBLElBQU0sNEJBQTRCLFdBQVcsUUFBd0I7QUFBQSxFQUNuRSxDQUFDO0FBQUEsRUFDRDtBQUFBLEVBQ0E7QUFDRjtBQUNBLElBQU1DLFlBQVcsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxNQUFNO0FBQ3BDLE1BQUksUUFBUSxJQUFJLEdBQUc7QUFDakIsU0FBSyxRQUFRLENBQUMsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQUEsRUFDbEMsV0FBVyxNQUFNO0FBQ2YsU0FBSyxHQUFHLElBQUk7QUFBQSxFQUNkO0FBQ0Y7QUFDQSxJQUFNLHNCQUFzQixDQUFDLFNBQVM7QUFDcEMsU0FBTyxPQUFPLFFBQVEsSUFBSSxJQUFJLEtBQUssS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSTtBQUNyRjtBQUNBLFNBQVMsdUJBQXVCLFVBQVU7QUFDeEMsUUFBTSxZQUFZLENBQUM7QUFDbkIsYUFBVyxPQUFPLFVBQVU7QUFDMUIsUUFBSSxFQUFFLE9BQU8sK0JBQStCO0FBQzFDLGdCQUFVLE9BQU8sU0FBUztBQUFBLElBQzVCO0FBQUEsRUFDRjtBQUNBLE1BQUksU0FBUyxRQUFRLE9BQU87QUFDMUIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNO0FBQUEsSUFDSixPQUFPO0FBQUEsSUFDUDtBQUFBLElBQ0E7QUFBQSxJQUNBLGlCQUFpQixHQUFHO0FBQUEsSUFDcEIsbUJBQW1CLEdBQUc7QUFBQSxJQUN0QixlQUFlLEdBQUc7QUFBQSxJQUNsQixrQkFBa0I7QUFBQSxJQUNsQixvQkFBb0I7QUFBQSxJQUNwQixnQkFBZ0I7QUFBQSxJQUNoQixpQkFBaUIsR0FBRztBQUFBLElBQ3BCLG1CQUFtQixHQUFHO0FBQUEsSUFDdEIsZUFBZSxHQUFHO0FBQUEsRUFDcEIsSUFBSTtBQUNKLFFBQU0sWUFBWSxrQkFBa0IsUUFBUTtBQUM1QyxRQUFNLGdCQUFnQixhQUFhLFVBQVU7QUFDN0MsUUFBTSxnQkFBZ0IsYUFBYSxVQUFVO0FBQzdDLFFBQU07QUFBQSxJQUNKO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsaUJBQWlCO0FBQUEsSUFDakIsV0FBVztBQUFBLElBQ1gsb0JBQW9CO0FBQUEsRUFDdEIsSUFBSTtBQUNKLFFBQU0sY0FBYyxDQUFDLElBQUksVUFBVSxTQUFTO0FBQzFDLDBCQUFzQixJQUFJLFdBQVcsZ0JBQWdCLFlBQVk7QUFDakUsMEJBQXNCLElBQUksV0FBVyxvQkFBb0IsZ0JBQWdCO0FBQ3pFLFlBQVEsS0FBSztBQUFBLEVBQ2Y7QUFDQSxRQUFNLGNBQWMsQ0FBQyxJQUFJLFNBQVM7QUFDaEMsT0FBRyxhQUFhO0FBQ2hCLDBCQUFzQixJQUFJLGNBQWM7QUFDeEMsMEJBQXNCLElBQUksWUFBWTtBQUN0QywwQkFBc0IsSUFBSSxnQkFBZ0I7QUFDMUMsWUFBUSxLQUFLO0FBQUEsRUFDZjtBQUNBLFFBQU0sZ0JBQWdCLENBQUMsYUFBYTtBQUNsQyxXQUFPLENBQUMsSUFBSSxTQUFTO0FBQ25CLFlBQU0sT0FBTyxXQUFXLFdBQVc7QUFDbkMsWUFBTSxVQUFVLE1BQU0sWUFBWSxJQUFJLFVBQVUsSUFBSTtBQUNwRCxNQUFBQSxVQUFTLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUM1QixnQkFBVSxNQUFNO0FBQ2QsOEJBQXNCLElBQUksV0FBVyxrQkFBa0IsY0FBYztBQUNyRSwyQkFBbUIsSUFBSSxXQUFXLGdCQUFnQixZQUFZO0FBQzlELFlBQUksQ0FBQyxvQkFBb0IsSUFBSSxHQUFHO0FBQzlCLDZCQUFtQixJQUFJLE1BQU0sZUFBZSxPQUFPO0FBQUEsUUFDckQ7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUNBLFNBQU8sT0FBTyxXQUFXO0FBQUEsSUFDdkIsY0FBYyxJQUFJO0FBQ2hCLE1BQUFBLFVBQVMsZUFBZSxDQUFDLEVBQUUsQ0FBQztBQUM1Qix5QkFBbUIsSUFBSSxjQUFjO0FBQ3JDLHlCQUFtQixJQUFJLGdCQUFnQjtBQUFBLElBQ3pDO0FBQUEsSUFDQSxlQUFlLElBQUk7QUFDakIsTUFBQUEsVUFBUyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7QUFDN0IseUJBQW1CLElBQUksZUFBZTtBQUN0Qyx5QkFBbUIsSUFBSSxpQkFBaUI7QUFBQSxJQUMxQztBQUFBLElBQ0EsU0FBUyxjQUFjLEtBQUs7QUFBQSxJQUM1QixVQUFVLGNBQWMsSUFBSTtBQUFBLElBQzVCLFFBQVEsSUFBSSxNQUFNO0FBQ2hCLFNBQUcsYUFBYTtBQUNoQixZQUFNLFVBQVUsTUFBTSxZQUFZLElBQUksSUFBSTtBQUMxQyx5QkFBbUIsSUFBSSxjQUFjO0FBQ3JDLGtCQUFZO0FBQ1oseUJBQW1CLElBQUksZ0JBQWdCO0FBQ3ZDLGdCQUFVLE1BQU07QUFDZCxZQUFJLENBQUMsR0FBRyxZQUFZO0FBQ2xCO0FBQUEsUUFDRjtBQUNBLDhCQUFzQixJQUFJLGNBQWM7QUFDeEMsMkJBQW1CLElBQUksWUFBWTtBQUNuQyxZQUFJLENBQUMsb0JBQW9CLE9BQU8sR0FBRztBQUNqQyw2QkFBbUIsSUFBSSxNQUFNLGVBQWUsT0FBTztBQUFBLFFBQ3JEO0FBQUEsTUFDRixDQUFDO0FBQ0QsTUFBQUEsVUFBUyxTQUFTLENBQUMsSUFBSSxPQUFPLENBQUM7QUFBQSxJQUNqQztBQUFBLElBQ0EsaUJBQWlCLElBQUk7QUFDbkIsa0JBQVksSUFBSSxLQUFLO0FBQ3JCLE1BQUFBLFVBQVMsa0JBQWtCLENBQUMsRUFBRSxDQUFDO0FBQUEsSUFDakM7QUFBQSxJQUNBLGtCQUFrQixJQUFJO0FBQ3BCLGtCQUFZLElBQUksSUFBSTtBQUNwQixNQUFBQSxVQUFTLG1CQUFtQixDQUFDLEVBQUUsQ0FBQztBQUFBLElBQ2xDO0FBQUEsSUFDQSxpQkFBaUIsSUFBSTtBQUNuQixrQkFBWSxFQUFFO0FBQ2QsTUFBQUEsVUFBUyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7QUFBQSxJQUNqQztBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBQ0EsU0FBUyxrQkFBa0IsVUFBVTtBQUNuQyxNQUFJLFlBQVksTUFBTTtBQUNwQixXQUFPO0FBQUEsRUFDVCxXQUFXLFNBQVMsUUFBUSxHQUFHO0FBQzdCLFdBQU8sQ0FBQyxTQUFTLFNBQVMsS0FBSyxHQUFHLFNBQVMsU0FBUyxLQUFLLENBQUM7QUFBQSxFQUM1RCxPQUFPO0FBQ0wsVUFBTSxJQUFJLFNBQVMsUUFBUTtBQUMzQixXQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsRUFDZDtBQUNGO0FBQ0EsU0FBUyxTQUFTLEtBQUs7QUFDckIsUUFBTSxNQUFNLFNBQVMsR0FBRztBQUN4QixNQUFJLE9BQTJDO0FBQzdDLGlCQUFhLEtBQUssZ0NBQWdDO0FBQUEsRUFDcEQ7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLG1CQUFtQixJQUFJLEtBQUs7QUFDbkMsTUFBSSxNQUFNLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsVUFBVSxJQUFJLENBQUMsQ0FBQztBQUN4RCxHQUFDLEdBQUcsU0FBUyxHQUFHLE9BQXVCLG9CQUFJLElBQUksSUFBSSxJQUFJLEdBQUc7QUFDNUQ7QUFDQSxTQUFTLHNCQUFzQixJQUFJLEtBQUs7QUFDdEMsTUFBSSxNQUFNLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsVUFBVSxPQUFPLENBQUMsQ0FBQztBQUMzRCxRQUFNLEVBQUUsS0FBSyxJQUFJO0FBQ2pCLE1BQUksTUFBTTtBQUNSLFNBQUssT0FBTyxHQUFHO0FBQ2YsUUFBSSxDQUFDLEtBQUssTUFBTTtBQUNkLFNBQUcsT0FBTztBQUFBLElBQ1o7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFVBQVUsSUFBSTtBQUNyQix3QkFBc0IsTUFBTTtBQUMxQiwwQkFBc0IsRUFBRTtBQUFBLEVBQzFCLENBQUM7QUFDSDtBQUNBLElBQUksUUFBUTtBQUNaLFNBQVMsbUJBQW1CLElBQUksY0FBYyxpQkFBaUIsU0FBUztBQUN0RSxRQUFNLEtBQUssR0FBRyxTQUFTLEVBQUU7QUFDekIsUUFBTSxvQkFBb0IsTUFBTTtBQUM5QixRQUFJLE9BQU8sR0FBRyxRQUFRO0FBQ3BCLGNBQVE7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUNBLE1BQUksaUJBQWlCO0FBQ25CLFdBQU8sV0FBVyxtQkFBbUIsZUFBZTtBQUFBLEVBQ3REO0FBQ0EsUUFBTSxFQUFFLE1BQU0sU0FBUyxVQUFVLElBQUksa0JBQWtCLElBQUksWUFBWTtBQUN2RSxNQUFJLENBQUMsTUFBTTtBQUNULFdBQU8sUUFBUTtBQUFBLEVBQ2pCO0FBQ0EsUUFBTSxXQUFXLE9BQU87QUFDeEIsTUFBSSxRQUFRO0FBQ1osUUFBTSxNQUFNLE1BQU07QUFDaEIsT0FBRyxvQkFBb0IsVUFBVSxLQUFLO0FBQ3RDLHNCQUFrQjtBQUFBLEVBQ3BCO0FBQ0EsUUFBTSxRQUFRLENBQUMsTUFBTTtBQUNuQixRQUFJLEVBQUUsV0FBVyxNQUFNLEVBQUUsU0FBUyxXQUFXO0FBQzNDLFVBQUk7QUFBQSxJQUNOO0FBQUEsRUFDRjtBQUNBLGFBQVcsTUFBTTtBQUNmLFFBQUksUUFBUSxXQUFXO0FBQ3JCLFVBQUk7QUFBQSxJQUNOO0FBQUEsRUFDRixHQUFHLFVBQVUsQ0FBQztBQUNkLEtBQUcsaUJBQWlCLFVBQVUsS0FBSztBQUNyQztBQUNBLFNBQVMsa0JBQWtCLElBQUksY0FBYztBQUMzQyxRQUFNLFNBQVMsT0FBTyxpQkFBaUIsRUFBRTtBQUN6QyxRQUFNLHFCQUFxQixDQUFDLFNBQVMsT0FBTyxRQUFRLElBQUksTUFBTSxJQUFJO0FBQ2xFLFFBQU0sbUJBQW1CLG1CQUFtQixHQUFHLGlCQUFpQjtBQUNoRSxRQUFNLHNCQUFzQixtQkFBbUIsR0FBRyxvQkFBb0I7QUFDdEUsUUFBTSxvQkFBb0IsV0FBVyxrQkFBa0IsbUJBQW1CO0FBQzFFLFFBQU0sa0JBQWtCLG1CQUFtQixHQUFHLGdCQUFnQjtBQUM5RCxRQUFNLHFCQUFxQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDcEUsUUFBTSxtQkFBbUIsV0FBVyxpQkFBaUIsa0JBQWtCO0FBQ3ZFLE1BQUksT0FBTztBQUNYLE1BQUksVUFBVTtBQUNkLE1BQUksWUFBWTtBQUNoQixNQUFJLGlCQUFpQixZQUFZO0FBQy9CLFFBQUksb0JBQW9CLEdBQUc7QUFDekIsYUFBTztBQUNQLGdCQUFVO0FBQ1Ysa0JBQVksb0JBQW9CO0FBQUEsSUFDbEM7QUFBQSxFQUNGLFdBQVcsaUJBQWlCLFdBQVc7QUFDckMsUUFBSSxtQkFBbUIsR0FBRztBQUN4QixhQUFPO0FBQ1AsZ0JBQVU7QUFDVixrQkFBWSxtQkFBbUI7QUFBQSxJQUNqQztBQUFBLEVBQ0YsT0FBTztBQUNMLGNBQVUsS0FBSyxJQUFJLG1CQUFtQixnQkFBZ0I7QUFDdEQsV0FBTyxVQUFVLElBQUksb0JBQW9CLG1CQUFtQixhQUFhLFlBQVk7QUFDckYsZ0JBQVksT0FBTyxTQUFTLGFBQWEsb0JBQW9CLFNBQVMsbUJBQW1CLFNBQVM7QUFBQSxFQUNwRztBQUNBLFFBQU0sZUFBZSxTQUFTLGNBQWMseUJBQXlCO0FBQUEsSUFDbkUsbUJBQW1CLEdBQUcsb0JBQW9CLEVBQUUsU0FBUztBQUFBLEVBQ3ZEO0FBQ0EsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxTQUFTLFdBQVcsUUFBUSxXQUFXO0FBQ3JDLFNBQU8sT0FBTyxTQUFTLFVBQVUsUUFBUTtBQUN2QyxhQUFTLE9BQU8sT0FBTyxNQUFNO0FBQUEsRUFDL0I7QUFDQSxTQUFPLEtBQUssSUFBSSxHQUFHLFVBQVUsSUFBSSxDQUFDLEdBQUcsTUFBTSxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDdkU7QUFDQSxTQUFTLEtBQUssR0FBRztBQUNmLFNBQU8sT0FBTyxFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUUsUUFBUSxLQUFLLEdBQUcsQ0FBQyxJQUFJO0FBQ3BEO0FBQ0EsU0FBUyxjQUFjO0FBQ3JCLFNBQU8sU0FBUyxLQUFLO0FBQ3ZCO0FBRUEsSUFBTSxjQUE4QixvQkFBSSxRQUFRO0FBQ2hELElBQU0saUJBQWlDLG9CQUFJLFFBQVE7QUFDbkQsSUFBTSxzQkFBc0I7QUFBQSxFQUMxQixNQUFNO0FBQUEsRUFDTixPQUF1Qix1QkFBTyxDQUFDLEdBQUcsMkJBQTJCO0FBQUEsSUFDM0QsS0FBSztBQUFBLElBQ0wsV0FBVztBQUFBLEVBQ2IsQ0FBQztBQUFBLEVBQ0QsTUFBTSxPQUFPLEVBQUUsTUFBTSxHQUFHO0FBQ3RCLFVBQU0sV0FBVyxtQkFBbUI7QUFDcEMsVUFBTSxRQUFRLG1CQUFtQjtBQUNqQyxRQUFJO0FBQ0osUUFBSTtBQUNKLGNBQVUsTUFBTTtBQUNkLFVBQUksQ0FBQyxhQUFhLFFBQVE7QUFDeEI7QUFBQSxNQUNGO0FBQ0EsWUFBTSxZQUFZLE1BQU0sYUFBYSxHQUFHLE1BQU0sUUFBUTtBQUN0RCxVQUFJLENBQUM7QUFBQSxRQUNILGFBQWEsR0FBRztBQUFBLFFBQ2hCLFNBQVMsTUFBTTtBQUFBLFFBQ2Y7QUFBQSxNQUNGLEdBQUc7QUFDRDtBQUFBLE1BQ0Y7QUFDQSxtQkFBYSxRQUFRLGNBQWM7QUFDbkMsbUJBQWEsUUFBUSxjQUFjO0FBQ25DLFlBQU0sZ0JBQWdCLGFBQWEsT0FBTyxnQkFBZ0I7QUFDMUQsa0JBQVk7QUFDWixvQkFBYyxRQUFRLENBQUMsTUFBTTtBQUMzQixjQUFNLEtBQUssRUFBRTtBQUNiLGNBQU0sUUFBUSxHQUFHO0FBQ2pCLDJCQUFtQixJQUFJLFNBQVM7QUFDaEMsY0FBTSxZQUFZLE1BQU0sa0JBQWtCLE1BQU0scUJBQXFCO0FBQ3JFLGNBQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNO0FBQzdCLGNBQUksS0FBSyxFQUFFLFdBQVcsSUFBSTtBQUN4QjtBQUFBLFVBQ0Y7QUFDQSxjQUFJLENBQUMsS0FBSyxhQUFhLEtBQUssRUFBRSxZQUFZLEdBQUc7QUFDM0MsZUFBRyxvQkFBb0IsaUJBQWlCLEVBQUU7QUFDMUMsZUFBRyxVQUFVO0FBQ2Isa0NBQXNCLElBQUksU0FBUztBQUFBLFVBQ3JDO0FBQUEsUUFDRjtBQUNBLFdBQUcsaUJBQWlCLGlCQUFpQixFQUFFO0FBQUEsTUFDekMsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUNELFdBQU8sTUFBTTtBQUNYLFlBQU0sV0FBVyxNQUFNLEtBQUs7QUFDNUIsWUFBTSxxQkFBcUIsdUJBQXVCLFFBQVE7QUFDMUQsVUFBSSxNQUFNLFNBQVMsT0FBTztBQUMxQixxQkFBZTtBQUNmLGlCQUFXLE1BQU0sVUFBVSx5QkFBeUIsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3hFLGVBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDeEMsY0FBTSxRQUFRLFNBQVM7QUFDdkIsWUFBSSxNQUFNLE9BQU8sTUFBTTtBQUNyQjtBQUFBLFlBQ0U7QUFBQSxZQUNBLHVCQUF1QixPQUFPLG9CQUFvQixPQUFPLFFBQVE7QUFBQSxVQUNuRTtBQUFBLFFBQ0YsV0FBVyxPQUEyQztBQUNwRCxlQUFLLDJDQUEyQztBQUFBLFFBQ2xEO0FBQUEsTUFDRjtBQUNBLFVBQUksY0FBYztBQUNoQixpQkFBUyxJQUFJLEdBQUcsSUFBSSxhQUFhLFFBQVEsS0FBSztBQUM1QyxnQkFBTSxRQUFRLGFBQWE7QUFDM0I7QUFBQSxZQUNFO0FBQUEsWUFDQSx1QkFBdUIsT0FBTyxvQkFBb0IsT0FBTyxRQUFRO0FBQUEsVUFDbkU7QUFDQSxzQkFBWSxJQUFJLE9BQU8sTUFBTSxHQUFHLHNCQUFzQixDQUFDO0FBQUEsUUFDekQ7QUFBQSxNQUNGO0FBQ0EsYUFBTyxZQUFZLEtBQUssTUFBTSxRQUFRO0FBQUEsSUFDeEM7QUFBQSxFQUNGO0FBQ0Y7QUFDQSxJQUFNLGFBQWEsQ0FBQyxVQUFVLE9BQU8sTUFBTTtBQUMzQiwyQkFBVyxvQkFBb0IsS0FBSztBQUVwRCxTQUFTLGVBQWUsR0FBRztBQUN6QixRQUFNLEtBQUssRUFBRTtBQUNiLE1BQUksR0FBRyxTQUFTO0FBQ2QsT0FBRyxRQUFRO0FBQUEsRUFDYjtBQUNBLE1BQUksR0FBRyxVQUFVO0FBQ2YsT0FBRyxTQUFTO0FBQUEsRUFDZDtBQUNGO0FBQ0EsU0FBUyxlQUFlLEdBQUc7QUFDekIsaUJBQWUsSUFBSSxHQUFHLEVBQUUsR0FBRyxzQkFBc0IsQ0FBQztBQUNwRDtBQUNBLFNBQVMsaUJBQWlCLEdBQUc7QUFDM0IsUUFBTSxTQUFTLFlBQVksSUFBSSxDQUFDO0FBQ2hDLFFBQU0sU0FBUyxlQUFlLElBQUksQ0FBQztBQUNuQyxRQUFNLEtBQUssT0FBTyxPQUFPLE9BQU87QUFDaEMsUUFBTSxLQUFLLE9BQU8sTUFBTSxPQUFPO0FBQy9CLE1BQUksTUFBTSxJQUFJO0FBQ1osVUFBTSxJQUFJLEVBQUUsR0FBRztBQUNmLE1BQUUsWUFBWSxFQUFFLGtCQUFrQixhQUFhLFFBQVE7QUFDdkQsTUFBRSxxQkFBcUI7QUFDdkIsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUNBLFNBQVMsZ0JBQWdCLElBQUksTUFBTSxXQUFXO0FBQzVDLFFBQU0sUUFBUSxHQUFHLFVBQVU7QUFDM0IsTUFBSSxHQUFHLE1BQU07QUFDWCxPQUFHLEtBQUssUUFBUSxDQUFDLFFBQVE7QUFDdkIsVUFBSSxNQUFNLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxLQUFLLE1BQU0sVUFBVSxPQUFPLENBQUMsQ0FBQztBQUFBLElBQ2hFLENBQUM7QUFBQSxFQUNIO0FBQ0EsWUFBVSxNQUFNLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxLQUFLLE1BQU0sVUFBVSxJQUFJLENBQUMsQ0FBQztBQUNqRSxRQUFNLE1BQU0sVUFBVTtBQUN0QixRQUFNLFlBQVksS0FBSyxhQUFhLElBQUksT0FBTyxLQUFLO0FBQ3BELFlBQVUsWUFBWSxLQUFLO0FBQzNCLFFBQU0sRUFBRSxhQUFhLElBQUksa0JBQWtCLEtBQUs7QUFDaEQsWUFBVSxZQUFZLEtBQUs7QUFDM0IsU0FBTztBQUNUO0FBeVdBLElBQU0sa0JBQWtDLHVCQUFPLEVBQUUsVUFBVSxHQUFHLE9BQU87QUFDckUsSUFBSTtBQUVKLFNBQVMsaUJBQWlCO0FBQ3hCLFNBQU8sYUFBYSxXQUFXLGVBQWUsZUFBZTtBQUMvRDtBQVlBLElBQU0sWUFBWSxJQUFJLFNBQVM7QUFDN0IsUUFBTSxNQUFNLGVBQWUsRUFBRSxVQUFVLEdBQUcsSUFBSTtBQUM5QyxNQUFJLE9BQTJDO0FBQzdDLHlCQUFxQixHQUFHO0FBQ3hCLCtCQUEyQixHQUFHO0FBQUEsRUFDaEM7QUFDQSxRQUFNLEVBQUUsTUFBTSxJQUFJO0FBQ2xCLE1BQUksUUFBUSxDQUFDLHdCQUF3QjtBQUNuQyxVQUFNLFlBQVksbUJBQW1CLG1CQUFtQjtBQUN4RCxRQUFJLENBQUM7QUFDSDtBQUNGLFVBQU0sWUFBWSxJQUFJO0FBQ3RCLFFBQUksQ0FBQyxXQUFXLFNBQVMsS0FBSyxDQUFDLFVBQVUsVUFBVSxDQUFDLFVBQVUsVUFBVTtBQUN0RSxnQkFBVSxXQUFXLFVBQVU7QUFBQSxJQUNqQztBQUNBLGNBQVUsWUFBWTtBQUN0QixVQUFNLFFBQVEsTUFBTSxXQUFXLE9BQU8scUJBQXFCLFVBQVU7QUFDckUsUUFBSSxxQkFBcUIsU0FBUztBQUNoQyxnQkFBVSxnQkFBZ0IsU0FBUztBQUNuQyxnQkFBVSxhQUFhLGNBQWMsRUFBRTtBQUFBLElBQ3pDO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPO0FBQ1Q7QUFtREEsU0FBUyxtQkFBbUIsV0FBVztBQUNyQyxNQUFJLFNBQVMsU0FBUyxHQUFHO0FBQ3ZCLFVBQU0sTUFBTSxTQUFTLGNBQWMsU0FBUztBQUM1QyxRQUFJLE9BQW1EO0FBQ3JEO0FBQUEsUUFDRSwrQ0FBK0M7QUFBQSxNQUNqRDtBQUFBLElBQ0Y7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksT0FBeUk7QUFDM0k7QUFBQSxNQUNFO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7OztBQ3g5Q0EsSUFBSSxPQUEyQztBQUM3QyxVQUFRO0FBQ1Y7OztBQ05BLElBQU8sY0FBcUIsZ0NBQWlCO0FBQUEsRUFDM0MsUUFBUTtBQUFBLEVBQ1IsTUFBTSxTQUFTO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVixHQUFHO0FBQ0QsYUFBUztBQUNULFFBQUksZ0JBQWdCLG1CQUFtQjtBQUN2QyxRQUFJLFNBQVUsY0FBYyxXQUFXLE9BQU8saUJBQWlCO0FBQy9ELFFBQUksWUFBYSxjQUFjLFdBQVcsT0FBTyxpQkFBaUI7QUFHbEUsUUFBSSxjQUFjLElBQUk7QUFDdEIsY0FBVSxNQUFNO0FBQ2QsdUJBQWlCLGdCQUFnQixLQUFLO0FBQUEsSUFHeEMsQ0FBQztBQUVELGdCQUFZLE1BQU07QUFDaEIsMEJBQW9CLGdCQUFnQixLQUFLO0FBQUEsSUFDM0MsQ0FBQztBQUNELGFBQVMsUUFBUTtBQUNmLFlBQU0sT0FBTyxPQUFPO0FBQ3BCLFlBQU0sTUFBTSxPQUFPLDhDQUE4QyxHQUFHO0FBQ3BFLGtCQUFZLFFBQVEsS0FBSyxZQUFZLEVBQUUsTUFBTSxHQUFHO0FBQUEsSUFRbEQ7QUFFQSxVQUFNLGVBQWU7QUFBQSxNQUNuQixJQUFJLGdCQUFnQjtBQUNsQixlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsSUFBSSxjQUFjLEdBQUc7QUFDbkIsd0JBQWdCO0FBQUEsTUFDbEI7QUFBQSxNQUNBLElBQUksU0FBUztBQUNYLGVBQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxJQUFJLE9BQU8sR0FBRztBQUNaLGlCQUFTO0FBQUEsTUFDWDtBQUFBLE1BQ0EsSUFBSSxZQUFZO0FBQ2QsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLElBQUksVUFBVSxHQUFHO0FBQ2Ysb0JBQVk7QUFBQSxNQUNkO0FBQUEsTUFDQSxJQUFJLGNBQWM7QUFDaEIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLElBQUksWUFBWSxHQUFHO0FBQ2pCLHNCQUFjO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLFdBQU8sZUFBZSxjQUFjLG1CQUFtQjtBQUFBLE1BQ3JELFlBQVk7QUFBQSxNQUNaLE9BQU87QUFBQSxJQUNULENBQUM7QUFDRCxXQUFPO0FBQUEsRUFDVDtBQUNGLENBQUM7OztBQ3RFTSxTQUFTLE9BQU8sTUFBTSxRQUFRLFFBQVEsUUFBUSxPQUFPLFVBQVU7QUFDcEUsU0FBUSxVQUFXLElBQUksR0FBRyxtQkFBb0IsVUFBVyxNQUFNLFdBQVksT0FBTyxhQUFhLENBQUMsU0FBUztBQUN2RyxXQUFRLFVBQVcsR0FBRyxtQkFBb0IsT0FBTyxNQUFNLGdCQUFpQixLQUFLLFFBQVEsWUFBWSxFQUFFLENBQUMsR0FBRyxDQUFZO0FBQUEsRUFDckgsQ0FBQyxHQUFHLEdBQTBCO0FBQ2hDOzs7QUNOc1UsWUFBTyxTQUFTO0FBQU8sWUFBTyxTQUFTO0FBQXFCLFlBQU8sWUFBWTtBQUFrQixJQUFPQyxlQUFROzs7QVJLL2EsSUFBTSxZQUFvQjtBQUUxQixJQUFNLFNBQU4sY0FBcUIsMEJBQVM7QUFBQSxFQUtqQyxZQUFZLE1BQW9CLFFBQWlCO0FBQzdDLFVBQU0sSUFBSTtBQUVWLFNBQUssU0FBUztBQUFBLEVBQ2xCO0FBQUEsRUFDQSxjQUFzQjtBQUNsQixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsaUJBQXlCO0FBQ3JCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxVQUFrQjtBQUNkLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDTSxTQUFTO0FBQUE7QUFDWCxZQUFNLFlBQVksS0FBSyxZQUFZLFNBQVM7QUFDNUMsZ0JBQVUsTUFBTTtBQUNqQixZQUFNLGFBQWMsVUFBVSxTQUFTLE9BQU87QUFBQSxRQUN6QyxLQUFLO0FBQUEsTUFDVCxDQUFDO0FBQ0QsV0FBSyxTQUFTLFVBQVVDLFlBQUc7QUFDM0IsV0FBSyxPQUFPLE9BQU8saUJBQWlCLFNBQVMsS0FBSztBQUNsRCxXQUFLLE9BQU8sT0FBTyxpQkFBaUIsWUFBWTtBQUNoRCxXQUFLLE9BQU8sTUFBTSxpQkFBaUI7QUFBQSxJQUN2QztBQUFBO0FBQUEsRUFDTSxVQUFVO0FBQUE7QUFDWixXQUFLLE9BQU8sUUFBUTtBQUFBLElBQ3hCO0FBQUE7QUFFSjs7O0FKaEJBLElBQU0sbUJBQW1EO0FBQUEsRUFDdkQsT0FBTztBQUFBLEVBQ1AsaUJBQWlCO0FBQ25CO0FBTUEsSUFBcUIsV0FBckIsY0FBc0Msd0JBQU87QUFBQSxFQU1yQyxTQUFTO0FBQUE7QUFFYixZQUFNLEtBQUssYUFBYTtBQUV4QixXQUFLLGNBQWMsSUFBSSxrQkFBa0IsS0FBSyxLQUFLLElBQUksQ0FBQztBQUV4RCxXQUFLO0FBQUEsUUFDSDtBQUFBLFFBQ0EsQ0FBQyxTQUFTLElBQUksT0FBTyxNQUFNLElBQUk7QUFBQSxNQUNqQztBQUVBLFdBQUssY0FBYyxRQUFRLGdCQUFnQixDQUFDLFFBQVE7QUFDbEQsYUFBSyxhQUFhO0FBQUEsTUFDcEIsQ0FBQztBQUVELFdBQUssd0JBQXdCLGtCQUFrQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBRTlELFdBQUssY0FBYyxLQUFLLElBQUksVUFBVSxHQUFHLHNCQUFzQixDQUFPLFNBQVM7QUFDN0UsWUFBSSxPQUFPLEtBQUssSUFBSSxVQUFVLG9CQUFvQiw2QkFBWTtBQUM5RCxZQUFJLE1BQU07QUFDUixlQUFLLGVBQWU7QUFBQSxRQUN0QjtBQUFBLE1BQ0YsRUFBQyxDQUFDO0FBSUYsV0FBSztBQUFBLFFBQ0gsS0FBSyxJQUFJLFVBQVUsR0FBRyxlQUFlLENBQUMsTUFBTSxRQUFRLFNBQVM7QUFDM0QsZUFBSyxRQUFRLENBQUMsU0FBUztBQUNyQixpQkFDRyxTQUFTLG9DQUFTLEVBQ2xCLFFBQVEsVUFBVSxFQUNsQixRQUFRLE1BQVk7QUFDbkIsa0JBQUksYUFBYSxLQUFLLEtBQUssQ0FBQyxXQUFXO0FBQ3JDLHNCQUFNLEtBQUssS0FBSyxPQUFPLEVBQUUsU0FBUyxFQUFFLEVBQUUsTUFBTSxDQUFDO0FBQzdDLHVCQUFPLGlCQUFpQiwrR0FBd0csT0FBTyxzQkFBc0I7QUFBQSxjQUMvSixDQUFDLEVBQUUsS0FBSztBQUFBLFlBRVYsRUFBQztBQUFBLFVBQ0wsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUVGO0FBQUE7QUFBQSxFQUVNLGVBQWU7QUFBQTtBQUNuQixXQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLElBQzNFO0FBQUE7QUFBQSxFQUVNLGVBQWU7QUFBQTtBQUNuQixZQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxJQUNuQztBQUFBO0FBQUEsRUFFQSxXQUFXO0FBQ1QsU0FBSyxJQUFJLFVBQVUsbUJBQW1CLFNBQVM7QUFBQSxFQUNqRDtBQUFBLEVBR00sZUFBZTtBQUFBO0FBQ25CLFVBQUksS0FBSyxJQUFJLFVBQVUsZ0JBQWdCLFNBQVMsRUFBRSxXQUFXLEdBQUc7QUFDOUQsY0FBTSxLQUFLLElBQUksVUFBVSxhQUFhLEtBQUssRUFBRSxhQUFhO0FBQUEsVUFDeEQsTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFFBQ1YsQ0FBQztBQUFBLE1BQ0g7QUFFQSxXQUFLLElBQUksVUFBVTtBQUFBLFFBQ2pCLEtBQUssSUFBSSxVQUFVLGdCQUFnQixTQUFTLEVBQUU7QUFBQSxNQUNoRDtBQUFBLElBQ0Y7QUFBQTtBQUdGOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiZWZmZWN0IiwgImVmZmVjdCIsICJoYXNPd25Qcm9wZXJ0eSIsICJpc1JlYWRvbmx5IiwgImlzU2hhbGxvdyIsICJpc1JlYWRvbmx5IiwgInNlbGYiLCAicCIsICJpc01vZGVsTGlzdGVuZXIiLCAiZW1pdCIsICJyZW5kZXIiLCAicmVuZGVyMiIsICJlZmZlY3QiLCAiY2FsbEhvb2siLCAicmVtb3ZlIiwgInAiLCAicmVuZGVyIiwgImdldCIsICJzZXQiLCAiY29tcHV0ZWQiLCAiaCIsICJjcmVhdGVBcHAiLCAicmVmIiwgInJlZiIsICJlZmZlY3QiLCAicmVtb3ZlMiIsICJyZW1vdmUiLCAicmVuZGVyIiwgInAiLCAicmVmIiwgImNvbXB1dGVkIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJjYWxsSG9vayIsICJBcHBfZGVmYXVsdCIsICJBcHBfZGVmYXVsdCJdCn0K
